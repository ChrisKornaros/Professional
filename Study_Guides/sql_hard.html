<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>sql_hard</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="sql_hard_files/libs/clipboard/clipboard.min.js"></script>
<script src="sql_hard_files/libs/quarto-html/quarto.js"></script>
<script src="sql_hard_files/libs/quarto-html/popper.min.js"></script>
<script src="sql_hard_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="sql_hard_files/libs/quarto-html/anchor.min.js"></script>
<link href="sql_hard_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="sql_hard_files/libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="sql_hard_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="sql_hard_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="sql_hard_files/libs/bootstrap/bootstrap-973236bd072d72a04ee9cd82dcc9cb29.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="sql-hard" class="level3">
<h3 class="anchored" data-anchor-id="sql-hard">SQL Hard</h3>
<section id="department-top-three-salaries" class="level4">
<h4 class="anchored" data-anchor-id="department-top-three-salaries">185. Department Top Three Salaries</h4>
<p><strong>Description:</strong></p>
<table class="caption-top table">
<caption>Employee</caption>
<colgroup>
<col style="width: 20%">
<col style="width: 13%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>id name salary departmentId</td>
<td>int varchar int int</td>
</tr>
</tbody>
</table>
<p>id is the primary key (column with unique values) for this table. departmentId is a foreign key (reference column) of the ID from the Department table. Each row of this table indicates the ID, name, and salary of an employee. It also contains the ID of their department.</p>
<table class="caption-top table">
<caption>Department</caption>
<colgroup>
<col style="width: 19%">
<col style="width: 13%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>id name</td>
<td>int varchar</td>
</tr>
</tbody>
</table>
<p>id is the primary key (column with unique values) for this table. Each row of this table indicates the ID of a department and its name.</p>
<p>A company’s executives are interested in seeing who earns the most money in each of the company’s departments. A high earner in a department is an employee who has a salary in the top three unique salaries for that department.</p>
<p>Write a solution to find the employees who are high earners in each of the departments.</p>
<p>Return the result table in any order.</p>
<p><strong>Solution:</strong></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">WITH</span> base <span class="kw">AS</span> (</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> d.name <span class="kw">AS</span> Department, e.name <span class="kw">AS</span> Employee, e.salary <span class="kw">AS</span> Salary, <span class="fu">DENSE_RANK</span>() <span class="kw">OVER</span> (<span class="kw">PARTITION</span> <span class="kw">BY</span> d.name <span class="kw">ORDER</span> <span class="kw">BY</span> e.salary <span class="kw">DESC</span>) <span class="kw">AS</span> <span class="fu">rank</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> Employee e <span class="kw">INNER</span> <span class="kw">JOIN</span> Department d</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">ON</span> e.departmentId <span class="op">=</span> d.<span class="kw">id</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">GROUP</span> <span class="kw">BY</span> d.name, e.name, e.salary</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> Department, Employee, Salary</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> base</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="kw">WHERE</span> <span class="fu">rank</span> <span class="op">&lt;=</span> <span class="dv">3</span>;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Explanation:</strong></p>
<ul>
<li>This query identifies the highest-paid employees in each department, specifically those with salaries in the top three within their department.</li>
<li>The solution uses a Common Table Expression (CTE) with a window function to rank employees within each department based on salary.</li>
<li><code>DENSE_RANK() OVER (PARTITION BY e.departmentId ORDER BY e.salary DESC)</code> assigns a rank to each employee’s salary within their department, with 1 being the highest.</li>
<li>Unlike regular RANK(), DENSE_RANK() doesn’t skip ranks for ties, which is important when multiple employees have the same salary.</li>
<li>The main query then filters for employees with a rank of 3 or less, capturing the top three salary tiers in each department.</li>
<li>The solution joins the Employee and Department tables to include department names in the output.</li>
<li>Time complexity: O(n log n) where n is the number of employees, due to the sorting operations in the window function.</li>
<li>Space complexity: O(n) for the CTE and result set.</li>
<li>The DENSE_RANK() function ensures that if multiple employees have the same salary, they get the same rank and all count toward the top three.</li>
<li>For example, if two employees have the highest salary in a department, both get rank 1, and the employee with the next highest salary gets rank 2.</li>
<li>This approach efficiently handles departments of different sizes without requiring complex subqueries.</li>
<li>For large datasets, indexes on departmentId and salary would improve join and sorting performance.</li>
</ul>
</section>
<section id="trips-and-users" class="level4">
<h4 class="anchored" data-anchor-id="trips-and-users">262. Trips and Users</h4>
<p><strong>Description:</strong></p>
<table class="caption-top table">
<caption>Trips</caption>
<colgroup>
<col style="width: 19%">
<col style="width: 15%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>id client_id driver_id city_id status request_at</td>
<td>int int int int enum varchar</td>
</tr>
</tbody>
</table>
<p>id is the primary key (column with unique values) for this table. The table holds all taxi trips. Each trip has a unique id, while client_id and driver_id are foreign keys to the users_id at the Users table. Status is an ENUM (category) type of (‘completed’, ‘cancelled_by_driver’, ‘cancelled_by_client’).</p>
<table class="caption-top table">
<caption>Users</caption>
<colgroup>
<col style="width: 19%">
<col style="width: 15%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>users_id banned role</td>
<td>int enum enum</td>
</tr>
</tbody>
</table>
<p>users_id is the primary key (column with unique values) for this table. The table holds all users. Each user has a unique users_id, and role is an ENUM type of (‘client’, ‘driver’, ‘partner’). banned is an ENUM (category) type of (‘Yes’, ‘No’).</p>
<p>The cancellation rate is computed by dividing the number of canceled (by client or driver) requests with unbanned users by the total number of requests with unbanned users on that day.</p>
<p>Write a solution to find the cancellation rate of requests with unbanned users (both client and driver must not be banned) each day between “2013-10-01” and “2013-10-03” with at least one trip. Round Cancellation Rate to two decimal points.</p>
<p>Return the result table in any order.</p>
<p><strong>Solution:</strong></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Write your PostgreSQL query statement below</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">WITH</span> unbanned <span class="kw">AS</span> (</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> <span class="op">*</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> Users</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">WHERE</span> banned <span class="op">=</span> <span class="st">'No'</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>cancelled <span class="kw">AS</span> (</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> <span class="op">*</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> Trips</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">WHERE</span> <span class="kw">LEFT</span>(status, <span class="dv">3</span>) <span class="kw">LIKE</span> <span class="st">'can'</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> t.request_at <span class="kw">AS</span> <span class="ot">"Day"</span>, <span class="fu">ROUND</span>(<span class="fu">COUNT</span>(c.<span class="kw">id</span>):<span class="ch">:numeric</span> <span class="op">/</span> <span class="fu">COUNT</span>(t.<span class="kw">id</span>), <span class="dv">2</span>) <span class="kw">AS</span> <span class="ot">"Cancellation Rate"</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> Trips t <span class="kw">LEFT</span> <span class="kw">JOIN</span> cancelled c</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">ON</span> t.<span class="kw">id</span> <span class="op">=</span> c.<span class="kw">id</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a><span class="kw">WHERE</span> t.client_id <span class="kw">IN</span> (<span class="kw">SELECT</span> users_id <span class="kw">FROM</span> unbanned) </span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">AND</span> t.driver_id <span class="kw">IN</span> (<span class="kw">SELECT</span> users_id <span class="kw">FROM</span> unbanned)</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">AND</span> t.request_at <span class="kw">BETWEEN</span> <span class="st">'2013-10-01'</span> <span class="kw">AND</span> <span class="st">'2013-10-03'</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a><span class="kw">GROUP</span> <span class="kw">BY</span> t.request_at</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Explanation:</strong></p>
<ul>
<li>This query calculates the daily cancellation rate for taxi trips between Oct 1-3, 2013, where both client and driver are not banned.</li>
<li>It creates two Common Table Expressions (CTEs) to simplify the logic: one for unbanned users and another for cancelled trips.</li>
<li>The first CTE (<code>unbanned</code>) filters the Users table to include only those who aren’t banned.</li>
<li>The second CTE (<code>cancelled</code>) identifies all trips with status starting with “can” (cancelled trips).</li>
<li>The main query joins all trips with the cancelled trips using a LEFT JOIN to preserve all eligible trips.</li>
<li>The WHERE clause ensures both driver and client are unbanned by using IN subqueries against the unbanned CTE.</li>
<li>Date filtering with BETWEEN ensures only trips from Oct 1-3, 2013 are included.</li>
<li>The cancellation rate is calculated by dividing cancelled trips count by total trips count for each day.</li>
<li>The ROUND function with type casting to numeric ensures the result is formatted to two decimal places.</li>
<li>Time complexity: O(n + m) where n is the number of trips and m is the number of users, due to the table scans and joins.</li>
<li>Space complexity: O(u + c) where u is the number of unbanned users and c is the number of cancelled trips.</li>
<li>Using CTEs improves query readability and maintenance compared to multiple subqueries.</li>
<li>The LEFT JOIN is crucial as it preserves all trips even if they weren’t cancelled, ensuring correct denominator in the rate calculation.</li>
<li>Using <code>LEFT(status, 3) LIKE 'can'</code> efficiently captures both cancellation types in a single condition.</li>
<li>For large datasets, indexes on users_id, client_id, driver_id, and request_at would significantly improve query performance.</li>
<li>Explicitly casting to numeric when calculating the rate prevents integer division issues that would result in truncated values.</li>
</ul>
</section>
<section id="median-employee-salary" class="level4">
<h4 class="anchored" data-anchor-id="median-employee-salary">569. Median Employee Salary</h4>
<p><strong>Description:</strong></p>
<table class="caption-top table">
<caption>Employee</caption>
<colgroup>
<col style="width: 20%">
<col style="width: 13%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>id company salary</td>
<td>int varchar int</td>
</tr>
</tbody>
</table>
<p>id is the primary key (column with unique values) for this table. Each row of this table indicates the company and the salary of one employee.</p>
<p>Write a solution to find the rows that contain the median salary of each company. While calculating the median, when you sort the salaries of the company, break the ties by id.</p>
<p>Return the result table in any order.</p>
<p>The result format is in the following example.</p>
<p><strong>Solution:</strong></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Write your PostgreSQL query statement below</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">WITH</span> company_counts <span class="kw">AS</span> (</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> company, <span class="fu">COUNT</span>(<span class="op">*</span>) <span class="kw">as</span> emp_count</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> Employee</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">GROUP</span> <span class="kw">BY</span> company</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>ranked_salaries <span class="kw">AS</span> (</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> e.<span class="kw">id</span>, e.company, e.salary, </span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>           <span class="fu">ROW_NUMBER</span>() <span class="kw">OVER</span> (<span class="kw">PARTITION</span> <span class="kw">BY</span> e.company <span class="kw">ORDER</span> <span class="kw">BY</span> e.salary, e.<span class="kw">id</span>) <span class="kw">as</span> row_rank,</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>           cc.emp_count</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> Employee e</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">JOIN</span> company_counts cc <span class="kw">ON</span> e.company <span class="op">=</span> cc.company</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> <span class="kw">id</span>, company, salary</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> ranked_salaries</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="kw">WHERE</span> </span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>    (emp_count % <span class="dv">2</span> <span class="op">=</span> <span class="dv">1</span> <span class="kw">AND</span> row_rank <span class="op">=</span> (emp_count <span class="op">+</span> <span class="dv">1</span>) <span class="op">/</span> <span class="dv">2</span>) <span class="kw">OR</span>  <span class="co">-- Odd count: middle value</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>    (emp_count % <span class="dv">2</span> <span class="op">=</span> <span class="dv">0</span> <span class="kw">AND</span> (row_rank <span class="op">=</span> emp_count <span class="op">/</span> <span class="dv">2</span> <span class="kw">OR</span> row_rank <span class="op">=</span> emp_count <span class="op">/</span> <span class="dv">2</span> <span class="op">+</span> <span class="dv">1</span>))  <span class="co">-- Even count: two middle values</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Explanation:</strong></p>
<ul>
<li>This query identifies rows containing the median salary for each company, breaking ties by employee ID when sorting salaries.</li>
<li>It uses a two-stage approach with Common Table Expressions (CTEs) to first count employees and then assign precise rankings.</li>
<li>The first CTE calculates the total number of employees for each company, which is crucial for determining median positions.</li>
<li>The second CTE employs ROW_NUMBER() to assign a sequential rank to each employee within their company, ordering first by salary and then by ID.</li>
<li>For companies with an odd number of employees, only the middle row is selected (e.g., for 5 employees, the 3rd ranked employee).</li>
<li>For companies with an even number of employees, both middle rows are included (e.g., for 6 employees, both the 3rd and 4th ranked employees).</li>
<li>The WHERE clause uses a conditional expression to filter for the appropriate rows based on whether the employee count is odd or even.</li>
<li>The formula (emp_count + 1) / 2 finds the median position for odd counts, while emp_count / 2 and emp_count / 2 + 1 identify both median positions for even counts.</li>
<li>Time complexity is O(n log n) due to the sorting operations required within each company partition for ranking.</li>
<li>Space complexity is O(n) where n is the number of employees, as we need to store all employee records with additional ranking information.</li>
<li>Using ROW_NUMBER() instead of RANK() ensures unique positions even when salaries are identical, allowing the tie-breaking by ID to work correctly.</li>
<li>The solution efficiently handles the multiple requirements: partitioning by company, ordering by salary, breaking ties by ID, and selecting median values.</li>
<li>For large employee datasets, indexes on company and salary columns would significantly improve query performance.</li>
<li>The modulo operation (%) provides a clean way to differentiate between companies with odd and even employee counts.</li>
<li>This approach maintains data integrity by passing through the original employee IDs, company names, and salary values without manipulation.</li>
<li>The solution is adaptable to handle additional requirements like excluding certain employees or adding weighted calculations.</li>
</ul>
</section>
<section id="find-median-given-frequency-of-numbers" class="level4">
<h4 class="anchored" data-anchor-id="find-median-given-frequency-of-numbers">571. Find Median Given Frequency of Numbers</h4>
<p><strong>Description:</strong></p>
<table class="caption-top table">
<caption>Numbers</caption>
<colgroup>
<col style="width: 19%">
<col style="width: 9%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>num frequency</td>
<td>int int</td>
</tr>
</tbody>
</table>
<p>num is the primary key for this table. Each row of this table shows the frequency of a number in the database.</p>
<p>The median is the value separating the higher half from the lower half of a data set.</p>
<p>Write an SQL query to report the median of all the numbers in the database after decompressing the Numbers table. Round the median to one decimal place.</p>
<p><strong>Solution:</strong></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">WITH</span> expanded <span class="kw">AS</span> (</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> num</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> Numbers</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">CROSS</span> <span class="kw">JOIN</span> GENERATE_SERIES(<span class="dv">1</span>, frequency) <span class="kw">as</span> s</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> <span class="fu">ROUND</span>(</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="fu">PERCENTILE_CONT</span>(<span class="fl">0.5</span>) WITHIN <span class="kw">GROUP</span> (<span class="kw">ORDER</span> <span class="kw">BY</span> num):<span class="ch">:numeric</span>, </span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    <span class="dv">1</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>) <span class="kw">AS</span> <span class="fu">median</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> expanded;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Explanation:</strong></p>
<ul>
<li>This query calculates the median of a set of numbers where each number appears with a specific frequency.</li>
<li>The solution uses a Common Table Expression (CTE) and PostgreSQL’s specific functions:
<ul>
<li>The <code>expanded</code> CTE effectively “decompresses” the Numbers table using CROSS JOIN with GENERATE_SERIES to repeat each number according to its frequency value.</li>
<li>For example, if the row is (3, 5), the number 3 will appear 5 times in the expanded dataset.</li>
<li>GENERATE_SERIES(1, frequency) creates a sequence from 1 to the frequency value for each row.</li>
</ul></li>
<li>The main query uses <code>PERCENTILE_CONT(0.5)</code> window function, which is specifically designed to calculate percentiles (with 0.5 representing the median).</li>
<li>The <code>WITHIN GROUP (ORDER BY num)</code> clause organizes the data in ascending order for the percentile calculation.</li>
<li>The result is cast to numeric and rounded to one decimal place using the <code>ROUND</code> function.</li>
<li>Time complexity: O(n) where n is the total count of numbers after expansion.</li>
<li>Space complexity: O(n) for the expanded table.</li>
<li>For large datasets with high frequencies, this approach may be memory-intensive as it materializes all repeated instances.</li>
<li>An alternative approach for very large datasets would be to use a weighted percentile calculation, but PostgreSQL’s PERCENTILE_CONT handles this scenario elegantly.</li>
<li>The solution handles both odd and even counts correctly, as PERCENTILE_CONT automatically performs linear interpolation for even-count datasets.</li>
<li>The query is compatible with PostgreSQL and takes advantage of its specific functions for percentile calculation.</li>
</ul>
</section>
<section id="find-cumulative-salary-of-an-employee" class="level4">
<h4 class="anchored" data-anchor-id="find-cumulative-salary-of-an-employee">579. Find Cumulative Salary of an Employee</h4>
<p><strong>Description:</strong></p>
<table class="caption-top table">
<caption>Employee</caption>
<colgroup>
<col style="width: 19%">
<col style="width: 9%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>id month salary</td>
<td>int int int</td>
</tr>
</tbody>
</table>
<p>(id, month) is the primary key for this table. Each row in the table indicates the salary of an employee in one month. If the employee did not receive any salary for a month, there will not be an entry with id and month.</p>
<p>Write an SQL query to calculate the cumulative salary summary for every employee.</p>
<p>The cumulative salary summary for an employee can be calculated as follows:</p>
<ul>
<li>For each month that the employee worked, sum up the salaries in that month and the previous two months. This is their 3-month sum for that month. If an employee didn’t work for some month, exclude that month from the calculation.</li>
<li>Do not include the 3-month sum for the most recent month that the employee worked for in the result table.</li>
<li>Do not include the 3-month sum for any month the employee didn’t get any salary.</li>
</ul>
<p>Return the result table ordered by id in ascending order. In case of a tie, order it by month in descending order.</p>
<p><strong>Solution:</strong></p>
<div class="sourceCode" id="cb5"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Write your PostgreSQL query statement below</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="kw">WITH</span> base <span class="kw">AS</span> (</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> <span class="kw">id</span>, <span class="dt">month</span>, salary</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    , <span class="cf">CASE</span> <span class="cf">WHEN</span> <span class="dt">month</span><span class="op">-</span><span class="dv">1</span> <span class="op">=</span> <span class="fu">LAG</span>(<span class="dt">month</span>, <span class="dv">1</span>) <span class="kw">OVER</span> (<span class="kw">PARTITION</span> <span class="kw">BY</span> <span class="kw">id</span> <span class="kw">ORDER</span> <span class="kw">BY</span> <span class="dt">month</span>) </span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">THEN</span> <span class="fu">LAG</span>(salary, <span class="dv">1</span>) <span class="kw">OVER</span> (<span class="kw">PARTITION</span> <span class="kw">BY</span> <span class="kw">id</span> <span class="kw">ORDER</span> <span class="kw">BY</span> <span class="dt">month</span>) <span class="cf">ELSE</span> <span class="dv">0</span> <span class="cf">END</span> <span class="kw">AS</span> sal1</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    , <span class="cf">CASE</span> <span class="cf">WHEN</span> <span class="dt">month</span><span class="op">-</span><span class="dv">2</span> <span class="op">=</span> <span class="fu">LAG</span>(<span class="dt">month</span>, <span class="dv">2</span>) <span class="kw">OVER</span> (<span class="kw">PARTITION</span> <span class="kw">BY</span> <span class="kw">id</span> <span class="kw">ORDER</span> <span class="kw">BY</span> <span class="dt">month</span>)</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">THEN</span> <span class="fu">LAG</span>(salary, <span class="dv">2</span>) <span class="kw">OVER</span> (<span class="kw">PARTITION</span> <span class="kw">BY</span> <span class="kw">id</span> <span class="kw">ORDER</span> <span class="kw">BY</span> <span class="dt">month</span>) <span class="cf">ELSE</span> <span class="dv">0</span> <span class="cf">END</span> <span class="kw">AS</span> sal2 </span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> Employee</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">GROUP</span> <span class="kw">BY</span> <span class="kw">id</span>, <span class="dt">month</span>, salary</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> <span class="kw">id</span>, <span class="dt">month</span>, (salary <span class="op">+</span> sal1 <span class="op">+</span> sal2) <span class="kw">AS</span> <span class="ot">"Salary"</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> base</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a><span class="kw">WHERE</span> (<span class="kw">id</span>, <span class="dt">month</span>) <span class="kw">NOT</span> <span class="kw">IN</span> (<span class="kw">SELECT</span> <span class="kw">id</span>, <span class="fu">MAX</span>(<span class="dt">month</span>) <span class="kw">FROM</span> employee <span class="kw">GROUP</span> <span class="kw">BY</span> <span class="kw">id</span>)</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a><span class="kw">ORDER</span> <span class="kw">BY</span> <span class="kw">id</span> <span class="kw">ASC</span>, <span class="dt">month</span> <span class="kw">DESC</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Explanation:</strong></p>
<ul>
<li>This query calculates a rolling 3-month salary sum for each employee, excluding their most recent month.</li>
<li>The solution uses window functions and CASE statements to access previous months’ salary values without self-joins.</li>
<li>The <code>base</code> CTE retrieves each employee’s monthly salary and uses <code>LAG</code> window functions to access salaries from previous months as long as they are consecutive</li>
<li><code>LAG(salary, 1)</code> gets the salary from 1 month before</li>
<li><code>LAG(salary, 2)</code> gets the salary from 2 months before</li>
<li><code>MAX(month)</code> identifies the most recent month for each employee, which will be excluded from the results</li>
<li>The main query adds the current month’s salary to the previous two months to calculate the 3-month cumulative sum.</li>
<li>The <code>WHERE (id, month) NOT IN...</code> subquery excludes the most recent month for each employee from the results.</li>
<li>Results are ordered by employee ID ascending and month descending, as specified in the requirements.</li>
<li>Time complexity: O(n log n) where n is the number of employee-month records, due to the sorting in window functions.</li>
<li>Space complexity: O(n) for the CTE and result set.</li>
<li>This solution handles edge cases elegantly:
<ul>
<li>For the first month of employment, only that month’s salary is counted (as previous months are 0).</li>
<li>For the second month, only the first two months’ salaries are counted.</li>
<li>Non-consecutive months are handled correctly, as missing months simply don’t appear in the calculation.</li>
</ul></li>
<li>The approach is efficient for large datasets as it avoids multiple self-joins that would otherwise be needed.</li>
<li>For optimal performance, indexes on (id, month) would be beneficial.</li>
<li>Note that this solution assumes that months are represented as integers (e.g., 1-12) rather than dates.</li>
<li>For real-world scenarios with large datasets, partitioning the employee table by id could further improve performance.</li>
</ul>
</section>
<section id="human-traffic-of-stadium" class="level4">
<h4 class="anchored" data-anchor-id="human-traffic-of-stadium">601. Human Traffic of Stadium</h4>
<p><strong>Description:</strong></p>
<table class="caption-top table">
<caption>Stadium</caption>
<colgroup>
<col style="width: 22%">
<col style="width: 13%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>id visit_date people</td>
<td>int date int</td>
</tr>
</tbody>
</table>
<p>id is the primary key for this table. Each row of this table contains the visit date and visit id to the stadium with the number of people during the visit. No two rows will have the same visit_date. The date of a visit is unique.</p>
<p>Write an SQL query to display the records with three or more consecutive rows where the number of people is greater than or equal to 100.</p>
<p>Return the result table ordered by visit_date in ascending order.</p>
<p><strong>Solution:</strong></p>
<div class="sourceCode" id="cb6"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">WITH</span> base <span class="kw">AS</span> (</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> <span class="kw">id</span>, visit_date, people, <span class="kw">id</span> <span class="op">-</span> <span class="fu">ROW_NUMBER</span>() <span class="kw">OVER</span> (<span class="kw">ORDER</span> <span class="kw">BY</span> <span class="kw">id</span>) <span class="kw">AS</span> <span class="fu">group_id</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> Stadium</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">WHERE</span> people <span class="op">&gt;=</span> <span class="dv">100</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> <span class="kw">id</span>, visit_date, people</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> base</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="kw">WHERE</span> <span class="fu">group_id</span> <span class="kw">IN</span> (</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> <span class="fu">group_id</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> base</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">GROUP</span> <span class="kw">BY</span> <span class="fu">group_id</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">HAVING</span> <span class="fu">COUNT</span>(<span class="fu">group_id</span>) <span class="op">&gt;=</span> <span class="dv">3</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a><span class="kw">ORDER</span> <span class="kw">BY</span> visit_date <span class="kw">ASC</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Explanation:</strong></p>
<ul>
<li>This query identifies consecutive days with stadium attendance of 100 or more people.</li>
<li>The solution uses a “gaps and islands” technique to identify consecutive sequences in the data.</li>
<li>The first CTE, <code>high_traffic</code>, filters for days with 100+ visitors and creates a grouping identifier for consecutive days.</li>
<li>The key insight is using <code>id - ROW_NUMBER() OVER (ORDER BY id)</code> to create a constant value for consecutive sequences.</li>
<li>When IDs are consecutive, subtracting their row numbers (which also increment by 1) produces the same value, creating a “group ID” for consecutive records.</li>
<li>For example, if IDs 3, 4, 5 have row numbers 1, 2, 3, then (3-1), (4-2), (5-3) all equal 2, identifying them as part of the same group.</li>
<li>The main query then selects only records from groups that have 3 or more consecutive days of high traffic.</li>
<li>We filter using a subquery that counts records in each group and keeps only those with counts &gt;= 3.</li>
<li>Results are ordered by visit_date as required.</li>
<li>Time complexity: O(n log n) where n is the number of stadium visits, due to the sorting operations.</li>
<li>Space complexity: O(n) for the CTE and result set.</li>
<li>This solution efficiently handles the “consecutive” requirement without complex self-joins or window function chains.</li>
<li>The technique works correctly even with gaps in the id sequence, as long as the ids are still in chronological order.</li>
<li>For large datasets, an index on the people column would improve performance of the initial filtering.</li>
<li>The approach is database-agnostic and works well in PostgreSQL, MySQL, SQL Server, and other major SQL dialects.</li>
<li>An alternative approach could use window functions like LAG() and LEAD() to check adjacent days, but this “gaps and islands” technique is more elegant for identifying consecutive sequences.</li>
<li>For very large datasets, partitioning by date ranges could improve query performance.</li>
</ul>
</section>
<section id="average-salary-departments-vs-company" class="level4">
<h4 class="anchored" data-anchor-id="average-salary-departments-vs-company">615. Average Salary: Departments VS Company</h4>
<p><strong>Description:</strong></p>
<table class="caption-top table">
<caption>Salary</caption>
<colgroup>
<col style="width: 19%">
<col style="width: 9%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>id employee_id amount pay_date</td>
<td>int int int date</td>
</tr>
</tbody>
</table>
<p>id is the primary key column for this table. Each row of this table indicates the salary of an employee in one month. employee_id is a foreign key from the Employee table.</p>
<table class="caption-top table">
<caption>Employee</caption>
<colgroup>
<col style="width: 22%">
<col style="width: 9%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>employee_id department_id</td>
<td>int int</td>
</tr>
</tbody>
</table>
<p>employee_id is the primary key column for this table. Each row of this table indicates the department of an employee.</p>
<p>Write an SQL query to report the comparison result (higher/lower/same) of the average salary of employees in a department to the company’s average salary.</p>
<p>Return the result table in any order.</p>
<p>The comparison result is: - ‘higher’ when the average salary of the department is higher than the company’s average salary. - ‘lower’ when the average salary of the department is lower than the company’s average salary. - ‘same’ when the average salary of the department is the same as the company’s average salary.</p>
<p><strong>Solution:</strong></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">with</span> avgs <span class="kw">as</span> (</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">select</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">to_char</span>(pay_date, <span class="st">'YYYY-MM'</span>) <span class="kw">as</span> pay_month,</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    department_id,</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">avg</span>(amount) <span class="kw">over</span> (<span class="kw">partition</span> <span class="kw">by</span> department_id,<span class="fu">to_char</span>(pay_date, <span class="st">'YYYY-MM'</span>)) <span class="kw">as</span> dept_avg,</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">avg</span>(amount) <span class="kw">over</span> (<span class="kw">partition</span> <span class="kw">by</span> <span class="fu">to_char</span>(pay_date, <span class="st">'YYYY-MM'</span>)) <span class="kw">as</span> co_avg</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">from</span> Salary s <span class="kw">join</span> Employee e <span class="kw">using</span> (employee_id)</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="kw">select</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">distinct</span> pay_month,</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>  department_id,</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">CASE</span> </span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">WHEN</span> dept_avg <span class="op">&gt;</span> co_avg <span class="cf">THEN</span> <span class="st">'higher'</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">WHEN</span> dept_avg <span class="op">&lt;</span> co_avg <span class="cf">THEN</span> <span class="st">'lower'</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">ELSE</span> <span class="st">'same'</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">END</span> <span class="kw">as</span> comparison </span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a><span class="kw">from</span> avgs</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Explanation:</strong></p>
<ul>
<li>Need an explanation</li>
</ul>
</section>
<section id="students-report-by-geography" class="level4">
<h4 class="anchored" data-anchor-id="students-report-by-geography">618. Students Report By Geography</h4>
<p><strong>Description:</strong></p>
<table class="caption-top table">
<caption>Student</caption>
<colgroup>
<col style="width: 19%">
<col style="width: 13%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>name continent</td>
<td>varchar varchar</td>
</tr>
</tbody>
</table>
<p>There is no primary key for this table. It may contain duplicate rows. Each row of this table indicates the name of a student and the continent they came from.</p>
<p>A school has students from Asia, Europe, and America.</p>
<p>Write an SQL query to pivot the continent column in the Student table so that each name is sorted alphabetically and displayed underneath its corresponding continent. The output headers should be America, Asia, and Europe, respectively.</p>
<p>The test cases are generated so that the student number from America is not less than either Asia or Europe.</p>
<p><strong>Solution:</strong></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Write your PostgreSQL query statement below</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="kw">WITH</span> ranked_students <span class="kw">AS</span> (</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>        name,</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>        continent,</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>        <span class="fu">ROW_NUMBER</span>() <span class="kw">OVER</span>(<span class="kw">PARTITION</span> <span class="kw">BY</span> continent <span class="kw">ORDER</span> <span class="kw">BY</span> name) <span class="kw">AS</span> row_num</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> Student</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> </span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    <span class="fu">MAX</span>(<span class="cf">CASE</span> <span class="cf">WHEN</span> continent <span class="op">=</span> <span class="st">'America'</span> <span class="cf">THEN</span> name <span class="cf">END</span>) <span class="kw">AS</span> <span class="ot">"America"</span>,</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    <span class="fu">MAX</span>(<span class="cf">CASE</span> <span class="cf">WHEN</span> continent <span class="op">=</span> <span class="st">'Asia'</span> <span class="cf">THEN</span> name <span class="cf">END</span>) <span class="kw">AS</span> <span class="ot">"Asia"</span>,</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>    <span class="fu">MAX</span>(<span class="cf">CASE</span> <span class="cf">WHEN</span> continent <span class="op">=</span> <span class="st">'Europe'</span> <span class="cf">THEN</span> name <span class="cf">END</span>) <span class="kw">AS</span> <span class="ot">"Europe"</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> ranked_students</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a><span class="kw">GROUP</span> <span class="kw">BY</span> row_num</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a><span class="kw">ORDER</span> <span class="kw">BY</span> <span class="ot">"America"</span>, <span class="ot">"Asia"</span>,  <span class="ot">"Europe"</span>;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Explanation:</strong></p>
<ul>
<li>This query creates a pivot table that reorganizes student data from rows (grouped by continent) into columns (one for each continent).</li>
<li>The solution uses a two-step approach with a CTE and conditional aggregation to achieve the pivoting.</li>
<li>The <code>ranked_students</code> CTE first assigns sequential row numbers to students within each continent, ordered alphabetically by name.</li>
<li>This is done using the <code>ROW_NUMBER() OVER(PARTITION BY continent ORDER BY name)</code> window function.</li>
<li>For example, if America has students [‘Jane’, ‘John’, ‘Mike’] after sorting, they would get row numbers 1, 2, and 3 within the America partition.</li>
<li>The main query then uses conditional aggregation with <code>CASE</code> expressions to pivot the data:
<ul>
<li>Each <code>CASE WHEN continent = X THEN name END</code> returns the name when the continent matches, otherwise NULL.</li>
<li>The <code>MAX</code> function effectively selects the non-NULL value in each group (there will be at most one non-NULL value per continent in each row_num group).</li>
</ul></li>
<li>By grouping by row_num, we align students across continents based on their position within each continent’s alphabet-sorted list.</li>
<li>Time complexity: O(n log n) where n is the number of students, due to the sorting operations.</li>
<li>Space complexity: O(n) for the CTE and result set.</li>
<li>This approach handles the case where continents have different numbers of students - any “missing” positions will show as NULL in the results.</li>
<li>The query automatically adjusts to any number of students and works correctly regardless of data distribution.</li>
<li>For large datasets, indexes on the continent and name columns would improve performance.</li>
<li>This solution is particularly elegant as it doesn’t require hard-coding the names of all possible continents in the query logic.</li>
<li>An alternative approach could use the CROSSTAB function in PostgreSQL, but this method is more portable across different SQL dialects.</li>
<li>Note that the problem specifies that America will always have at least as many students as Asia or Europe, which ensures the pivot will have meaningful results for all rows.</li>
<li>For performance reasons with very large datasets, consider materializing the ranked_students CTE as a temporary table.</li>
</ul>
</section>
<section id="gameplay-analysis-v" class="level4">
<h4 class="anchored" data-anchor-id="gameplay-analysis-v">1097. Gameplay Analysis V</h4>
<p><strong>Description:</strong></p>
<table class="caption-top table">
<caption>Activity</caption>
<colgroup>
<col style="width: 20%">
<col style="width: 13%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>player_id device_id event_date games_played</td>
<td>int int date int</td>
</tr>
</tbody>
</table>
<p>(player_id, event_date) is the primary key of this table. This table shows the activity of players of some games. Each row is a record of a player who logged in and played a number of games (possibly 0) before logging out on someday using some device.</p>
<p>The install date of a player is the first login day of that player.</p>
<p>We define day 1 retention of some date X to be the number of players whose install date is X and they logged in again on the day right after X, divided by the number of players whose install date is X, rounded to 2 decimal places.</p>
<p>Write an SQL query to report for each install date, the number of players that installed the game on that day, and the day 1 retention.</p>
<p><strong>Solution:</strong></p>
<div class="sourceCode" id="cb9"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">WITH</span> install_dates <span class="kw">AS</span> (</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> player_id, <span class="fu">MIN</span>(event_date) <span class="kw">AS</span> install_dt</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> Activity</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">GROUP</span> <span class="kw">BY</span> player_id</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>day1_retention <span class="kw">AS</span> (</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> i.install_dt, <span class="fu">COUNT</span>(<span class="kw">DISTINCT</span> i.player_id) <span class="kw">AS</span> installs</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>        , <span class="fu">COUNT</span>(<span class="kw">DISTINCT</span> a.player_id) <span class="kw">AS</span> retained</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> install_dates i</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">LEFT</span> <span class="kw">JOIN</span> Activity a <span class="kw">ON</span> i.player_id <span class="op">=</span> a.player_id </span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">AND</span> a.event_date <span class="op">=</span> i.install_dt <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">GROUP</span> <span class="kw">BY</span> i.install_dt</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> install_dt,installs</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>    , <span class="fu">ROUND</span>(<span class="fu">COALESCE</span>(retained:<span class="ch">:NUMERIC</span> <span class="op">/</span> installs, <span class="dv">0</span>), <span class="dv">2</span>) <span class="kw">AS</span> Day1_retention</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> day1_retention</span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a><span class="kw">ORDER</span> <span class="kw">BY</span> install_dt;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Explanation:</strong></p>
<ul>
<li>This query calculates “day 1 retention rate” which is the percentage of players who return to play on the day immediately after their first login (install date).</li>
<li>The solution uses a two-step approach with Common Table Expressions (CTEs):
<ul>
<li>The first CTE, <code>install_dates</code>, identifies each player’s first login (install date) using the MIN function.</li>
<li>The second CTE, <code>day1_retention</code>, counts both total installs and the number of retained players for each install date.</li>
</ul></li>
<li>For each install date, we count:
<ul>
<li>The number of distinct players who installed on that date (total installs)</li>
<li>The number of these players who returned the very next day (retained players)</li>
</ul></li>
<li>We use a LEFT JOIN to ensure we capture all install dates, even if no players returned the next day.</li>
<li>The main query calculates the day 1 retention rate by dividing retained count by install count.</li>
<li>The COALESCE function handles cases where there are no retained players (avoiding division by zero).</li>
<li>We convert to NUMERIC type and use ROUND to format the result to 2 decimal places as required.</li>
<li>Time complexity: O(n) where n is the number of activity records, as we scan the table once to find install dates and once to check for retention.</li>
<li>Space complexity: O(p) where p is the number of players, as we store each player’s install date.</li>
<li>This approach efficiently handles players who never return after installation and multiple game sessions on the same day.</li>
<li>For large datasets, indexes on player_id and event_date would significantly improve performance.</li>
</ul>
</section>
<section id="user-purchase-platform" class="level4">
<h4 class="anchored" data-anchor-id="user-purchase-platform">1127. User Purchase Platform</h4>
<p><strong>Description:</strong></p>
<table class="caption-top table">
<caption>Spending</caption>
<colgroup>
<col style="width: 19%">
<col style="width: 13%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>user_id spend_date platform amount</td>
<td>int date enum int</td>
</tr>
</tbody>
</table>
<p>The table records the user spending data on different platforms (mobile, desktop) on different dates. (user_id, spend_date, platform) is the primary key of this table. The platform column is an ENUM type of (‘mobile’, ‘desktop’).</p>
<p>Write an SQL query to find the total number of users and the total amount spent using the mobile only, desktop only, and both platforms for each date.</p>
<p>The query result format is in the following example:</p>
<p>Spending table:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 13%">
<col style="width: 18%">
<col style="width: 15%">
<col style="width: 12%">
</colgroup>
<tbody>
<tr class="odd">
<td>user_id</td>
<td>spend_date</td>
<td>platform</td>
<td>amount</td>
</tr>
<tr class="even">
<td>1 1 2 2 3 3</td>
<td>2019-07-01 2019-07-01 2019-07-01 2019-07-02 2019-07-01 2019-07-02</td>
<td>mobile desktop mobile mobile desktop desktop</td>
<td>100 100 100 100 100 100</td>
</tr>
</tbody>
</table>
<p>Result table:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 18%">
<col style="width: 15%">
<col style="width: 20%">
<col style="width: 19%">
</colgroup>
<tbody>
<tr class="odd">
<td>spend_date</td>
<td>platform</td>
<td>total_amount</td>
<td>total_users</td>
</tr>
<tr class="even">
<td>2019-07-01 2019-07-01 2019-07-01 2019-07-02 2019-07-02 2019-07-02</td>
<td>desktop mobile both desktop mobile both</td>
<td>100 100 200 100 100 0</td>
<td>1 1 1 1 1 0</td>
</tr>
</tbody>
</table>
<p><strong>Solution:</strong></p>
<div class="sourceCode" id="cb10"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Write your PostgreSQL query statement below</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="kw">WITH</span> user_platform <span class="kw">AS</span> (</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> spend_date, user_id</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    , <span class="fu">SUM</span>(<span class="cf">CASE</span> <span class="cf">WHEN</span> platform <span class="op">=</span> <span class="st">'mobile'</span> <span class="cf">THEN</span> amount <span class="cf">ELSE</span> <span class="dv">0</span> <span class="cf">END</span>) <span class="kw">AS</span> mobile_amount</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    , <span class="fu">SUM</span>(<span class="cf">CASE</span> <span class="cf">WHEN</span> platform <span class="op">=</span> <span class="st">'desktop'</span> <span class="cf">THEN</span> amount <span class="cf">ELSE</span> <span class="dv">0</span> <span class="cf">END</span>) <span class="kw">AS</span> desktop_amount</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> Spending</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">GROUP</span> <span class="kw">BY</span> spend_date, user_id</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>user_platform_type <span class="kw">AS</span> (</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> spend_date, user_id</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>        , <span class="cf">CASE</span> <span class="cf">WHEN</span> mobile_amount <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">AND</span> desktop_amount <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">THEN</span> <span class="st">'both'</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">WHEN</span> mobile_amount <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">THEN</span> <span class="st">'mobile'</span> <span class="cf">ELSE</span> <span class="st">'desktop'</span> <span class="cf">END</span> <span class="kw">AS</span> platform</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>        , mobile_amount <span class="op">+</span> desktop_amount <span class="kw">AS</span> amount</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> user_platform</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>all_dates_platforms <span class="kw">AS</span> (</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> <span class="kw">DISTINCT</span> spend_date, p.<span class="op">*</span> </span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> Spending <span class="kw">CROSS</span> <span class="kw">JOIN</span> (</span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>        <span class="kw">SELECT</span> <span class="st">'mobile'</span> <span class="kw">AS</span> platform</span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>        <span class="kw">UNION</span> <span class="kw">ALL</span> <span class="kw">SELECT</span> <span class="st">'desktop'</span></span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>        <span class="kw">UNION</span> <span class="kw">ALL</span> <span class="kw">SELECT</span> <span class="st">'both'</span></span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>    ) p</span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> a.spend_date, a.platform, <span class="fu">COALESCE</span>(<span class="fu">SUM</span>(u.amount), <span class="dv">0</span>) <span class="kw">AS</span> total_amount</span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a>    , <span class="fu">COUNT</span>(u.user_id) <span class="kw">AS</span> total_users</span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> all_dates_platforms a <span class="kw">LEFT</span> <span class="kw">JOIN</span>  user_platform_type u </span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">ON</span> a.spend_date <span class="op">=</span> u.spend_date <span class="kw">AND</span> a.platform <span class="op">=</span> u.platform</span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true" tabindex="-1"></a><span class="kw">GROUP</span> <span class="kw">BY</span> a.spend_date, a.platform</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Explanation:</strong></p>
<ul>
<li>This query analyzes user spending across different platforms (mobile, desktop, or both) for each date.</li>
<li>The solution uses a multi-step approach with three CTEs to transform and aggregate the data:
<ul>
<li>The first CTE, <code>user_platform</code>, aggregates spending by user and date, using conditional sums to separate mobile and desktop amounts.</li>
<li>The second CTE, <code>user_platform_type</code>, categorizes each user on each date as using ‘mobile’, ‘desktop’, or ‘both’ platforms.</li>
<li>The third CTE, <code>all_dates_platforms</code>, creates a complete cartesian product of all dates with all three platform types, ensuring we have rows for all combinations.</li>
</ul></li>
<li>The main query joins these prepared data sets to calculate the total amount and total users for each date-platform combination.</li>
<li>We use LEFT JOIN to ensure all date-platform combinations appear in the result, even those with zero users.</li>
<li>COALESCE handles NULL values for total_amount when there are no users in a specific category.</li>
<li>The COUNT(user_id) function counts only non-NULL values, giving us the correct user count.</li>
<li>The results are ordered by date and then by platform in a specific order (both, desktop, mobile).</li>
<li>Time complexity: O(n log n) where n is the number of spending records, due to the grouping and sorting operations.</li>
<li>Space complexity: O(d × p) where d is the number of distinct dates and p is the number of platform types (3).</li>
<li>The CROSS JOIN ensures we have complete reporting for all possible platform categories, including combinations with zero users.</li>
<li>For large datasets, indexes on user_id, spend_date, and platform would improve performance.</li>
</ul>
</section>
<section id="market-analysis-ii" class="level4">
<h4 class="anchored" data-anchor-id="market-analysis-ii">1159. Market Analysis II</h4>
<p><strong>Description:</strong></p>
<table class="caption-top table">
<caption>Users</caption>
<colgroup>
<col style="width: 23%">
<col style="width: 13%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>user_id join_date favorite_brand</td>
<td>int date varchar</td>
</tr>
</tbody>
</table>
<p>user_id is the primary key of this table. This table has the info of the users of an online shopping website where users can sell and buy items.</p>
<table class="caption-top table">
<caption>Orders</caption>
<colgroup>
<col style="width: 22%">
<col style="width: 13%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>order_id order_date item_id buyer_id seller_id</td>
<td>int date int int int</td>
</tr>
</tbody>
</table>
<p>order_id is the primary key of this table. item_id is a foreign key to the Items table. buyer_id and seller_id are foreign keys to the Users table.</p>
<table class="caption-top table">
<caption>Items</caption>
<colgroup>
<col style="width: 22%">
<col style="width: 13%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>item_id item_brand</td>
<td>int varchar</td>
</tr>
</tbody>
</table>
<p>item_id is the primary key of this table.</p>
<p>Write an SQL query to find for each user whether the brand of their second item (ordered by date) sold is their favorite brand. If a user sold less than two items, report the answer for that user as “no” (case-insensitive).</p>
<p>Return the result table in any order.</p>
<p><strong>Solution:</strong></p>
<div class="sourceCode" id="cb11"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Write your PostgreSQL query statement below</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="kw">WITH</span> ranked_sales <span class="kw">AS</span> (</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> seller_id, item_id</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>        , <span class="fu">ROW_NUMBER</span>() <span class="kw">OVER</span> (<span class="kw">PARTITION</span> <span class="kw">BY</span> seller_id <span class="kw">ORDER</span> <span class="kw">BY</span> order_date) <span class="kw">AS</span> sale_rank</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> Orders</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>second_sales <span class="kw">AS</span> (</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> rs.seller_id, i.item_brand</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> ranked_sales rs <span class="kw">JOIN</span> Items i </span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">ON</span> rs.item_id <span class="op">=</span> i.item_id</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">WHERE</span> rs.sale_rank <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> </span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>    u.user_id <span class="kw">AS</span> seller_id</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>    , <span class="cf">CASE</span> <span class="cf">WHEN</span> ss.item_brand <span class="op">=</span> u.favorite_brand <span class="cf">THEN</span> <span class="st">'yes'</span> <span class="cf">ELSE</span> <span class="st">'no'</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">END</span> <span class="kw">AS</span> <span class="ot">"2nd_item_fav_brand"</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> Users u <span class="kw">LEFT</span> <span class="kw">JOIN</span>  second_sales ss </span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>        <span class="kw">ON</span> u.user_id <span class="op">=</span> ss.seller_id</span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a><span class="kw">ORDER</span> <span class="kw">BY</span> u.user_id;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Explanation:</strong></p>
<ul>
<li>This query determines if a user’s second sold item matches their favorite brand.</li>
<li>The solution uses a two-step approach with Common Table Expressions (CTEs):
<ul>
<li>The first CTE, <code>ranked_sales</code>, assigns a sequential rank to each sale by a seller, ordered by sale date using ROW_NUMBER().</li>
<li>The second CTE, <code>second_sales</code>, joins the ranked sales with the Items table to get the brand of each seller’s second sale.</li>
</ul></li>
<li>The main query joins the Users table with the second_sales CTE to compare each user’s favorite brand with their second sale’s brand.</li>
<li>We use LEFT JOIN to include all users, even those with fewer than two sales.</li>
<li>The CASE expression handles the comparison, returning ‘yes’ when the brands match and ‘no’ otherwise.</li>
<li>When a user has fewer than two sales, the second_sales join will return NULL, and the CASE statement will return ‘no’ as required.</li>
<li>Time complexity: O(n log n) where n is the number of orders, due to the sorting operation for ranking sales.</li>
<li>Space complexity: O(s) where s is the number of sellers who have made at least one sale.</li>
<li>The solution efficiently handles users who have made fewer than two sales and correctly identifies the chronological second sale.</li>
<li>For large datasets, indexes on seller_id and order_date in the Orders table would improve performance.</li>
<li>Breaking down the logic into CTEs improves readability compared to using complex nested subqueries.</li>
</ul>
</section>
<section id="tournament-winners" class="level4">
<h4 class="anchored" data-anchor-id="tournament-winners">1194. Tournament Winners</h4>
<p><strong>Description:</strong></p>
<table class="caption-top table">
<caption>Players</caption>
<colgroup>
<col style="width: 19%">
<col style="width: 11%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>player_id group_id</td>
<td>int int</td>
</tr>
</tbody>
</table>
<p>player_id is the primary key of this table. Each row indicates the group of each player.</p>
<table class="caption-top table">
<caption>Matches</caption>
<colgroup>
<col style="width: 22%">
<col style="width: 13%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>match_id first_player second_player first_score second_score</td>
<td>int int int int int</td>
</tr>
</tbody>
</table>
<p>match_id is the primary key of this table. Each row is a record of a match, first_player and second_player contain the player_id of each player. first_score and second_score contain the number of points of the first_player and second_player respectively. You may assume that, in each match, players belong to the same group.</p>
<p>The winner in each group is the player who scored the maximum total points within the group. In the case of a tie, the lowest player_id wins.</p>
<p>Write an SQL query to find the winner in each group.</p>
<p><strong>Solution:</strong></p>
<div class="sourceCode" id="cb12"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">WITH</span> player_scores <span class="kw">AS</span> (</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Calculate scores from first_player perspective</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> first_player <span class="kw">AS</span> player_id, first_score <span class="kw">AS</span> score</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> Matches</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">UNION</span> <span class="kw">ALL</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Calculate scores from second_player perspective</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> second_player <span class="kw">AS</span> player_id, second_score <span class="kw">AS</span> score</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> Matches</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>total_scores <span class="kw">AS</span> (</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> p.player_id, p.<span class="fu">group_id</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>        , <span class="fu">COALESCE</span>(<span class="fu">SUM</span>(ps.score), <span class="dv">0</span>) <span class="kw">AS</span> total_score</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> Players p</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">LEFT</span> <span class="kw">JOIN</span> player_scores ps <span class="kw">ON</span> p.player_id <span class="op">=</span> ps.player_id</span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">GROUP</span> <span class="kw">BY</span> p.player_id, p.<span class="fu">group_id</span></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>ranked_scores <span class="kw">AS</span> (</span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> player_id, <span class="fu">group_id</span>, total_score</span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>        , <span class="fu">RANK</span>() <span class="kw">OVER</span> (<span class="kw">PARTITION</span> <span class="kw">BY</span> <span class="fu">group_id</span> <span class="kw">ORDER</span> <span class="kw">BY</span> total_score <span class="kw">DESC</span>, player_id) <span class="kw">AS</span> player_rank</span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> total_scores</span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> <span class="fu">group_id</span>, player_id</span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> ranked_scores</span>
<span id="cb12-28"><a href="#cb12-28" aria-hidden="true" tabindex="-1"></a><span class="kw">WHERE</span> player_rank <span class="op">=</span> <span class="dv">1</span>;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Explanation:</strong></p>
<ul>
<li>This query identifies the winner in each player group based on total points scored.</li>
<li>The solution uses a three-step approach with Common Table Expressions (CTEs):
<ul>
<li>The first CTE, <code>player_scores</code>, collects all scores for all players using UNION ALL to combine points scored as both first_player and second_player.</li>
<li>The second CTE, <code>total_scores</code>, calculates the total score for each player by joining Players with the aggregated scores and summing them.</li>
<li>The third CTE, <code>ranked_scores</code>, ranks players within each group using the RANK() window function, ordering by total_score (DESC) and breaking ties with player_id.</li>
</ul></li>
<li>The main query selects only the top-ranked player from each group (player_rank = 1).</li>
<li>Time complexity: O(n log n) where n is the number of players and matches, due to the sorting operations.</li>
<li>Space complexity: O(p) where p is the number of players, as we store scores for each player.</li>
<li>COALESCE handles players who haven’t played any matches (giving them a score of 0).</li>
<li>The LEFT JOIN ensures all players are included in the result, even if they haven’t played any matches.</li>
<li>RANK() is crucial for handling ties according to the specified tiebreaker rule (lowest player_id).</li>
<li>The solution correctly handles cases where a player may appear as both first_player and second_player in different matches.</li>
<li>For large datasets, indexes on player_id in both tables would improve performance.</li>
</ul>
</section>
<section id="report-contiguous-dates" class="level4">
<h4 class="anchored" data-anchor-id="report-contiguous-dates">1225. Report Contiguous Dates</h4>
<p><strong>Description:</strong></p>
<table class="caption-top table">
<caption>Failed</caption>
<colgroup>
<col style="width: 20%">
<col style="width: 13%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>fail_date</td>
<td>date</td>
</tr>
</tbody>
</table>
<p>Primary key for this table is fail_date. Failed table contains the days of failed tasks.</p>
<table class="caption-top table">
<caption>Succeeded</caption>
<colgroup>
<col style="width: 20%">
<col style="width: 13%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>success_date</td>
<td>date</td>
</tr>
</tbody>
</table>
<p>Primary key for this table is success_date. Succeeded table contains the days of succeeded tasks.</p>
<p>A system is running one task every day. Every task is independent of the previous tasks. The tasks can fail or succeed.</p>
<p>Write an SQL query to generate a report of period_state for each continuous interval of days in the period from 2019-01-01 to 2019-12-31.</p>
<p>period_state is ‘failed’ if tasks in this interval failed or ‘succeeded’ if tasks in this interval succeeded. Interval of days are retrieved as start_date and end_date.</p>
<p>Return the result table ordered by start_date.</p>
<p><strong>Solution:</strong></p>
<div class="sourceCode" id="cb13"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Write your PostgreSQL query statement below</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="kw">WITH</span> base <span class="kw">AS</span> (</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> fail_date <span class="kw">AS</span> <span class="ot">"dates"</span>, <span class="st">'failed'</span> <span class="kw">AS</span> <span class="ot">"outcome"</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> Failed</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">WHERE</span> fail_date <span class="kw">BETWEEN</span> <span class="st">'2019-01-01'</span> <span class="kw">AND</span> <span class="st">'2019-12-31'</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">UNION</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> success_date <span class="kw">AS</span> <span class="ot">"dates"</span>, <span class="st">'succeeded'</span> <span class="kw">AS</span> <span class="ot">"outcome"</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> Succeeded</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">WHERE</span> success_date <span class="kw">BETWEEN</span> <span class="st">'2019-01-01'</span> <span class="kw">AND</span> <span class="st">'2019-12-31'</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">ORDER</span> <span class="kw">BY</span> <span class="ot">"dates"</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>periods <span class="kw">AS</span> (</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> dates, outcome, <span class="fu">ROW_NUMBER</span>() <span class="kw">OVER</span> (<span class="kw">ORDER</span> <span class="kw">BY</span> dates) <span class="op">-</span> <span class="fu">ROW_NUMBER</span>() <span class="kw">OVER</span> (<span class="kw">PARTITION</span> <span class="kw">BY</span> outcome <span class="kw">ORDER</span> <span class="kw">BY</span> dates) <span class="kw">AS</span> <span class="fu">group_id</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> base</span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> outcome <span class="kw">AS</span> period_state, <span class="fu">MIN</span>(dates) <span class="kw">AS</span> <span class="ot">"start_date"</span>, <span class="fu">MAX</span>(dates) <span class="kw">AS</span> <span class="ot">"end_date"</span></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> periods</span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a><span class="kw">GROUP</span> <span class="kw">BY</span> <span class="ot">"period_state"</span>, <span class="fu">group_id</span></span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a><span class="kw">ORDER</span> <span class="kw">BY</span> <span class="ot">"start_date"</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Explanation:</strong></p>
<ul>
<li>This query identifies continuous intervals of ‘failed’ or ‘succeeded’ days throughout 2019.</li>
<li>The solution uses a “gaps and islands” technique with Common Table Expressions (CTEs):
<ul>
<li>The first CTE, <code>all_dates</code>, combines dates from both tables with their respective states (‘failed’ or ‘succeeded’).</li>
<li>The second CTE, <code>ranked_dates</code>, implements the core of the technique by calculating a constant value for consecutive dates.</li>
</ul></li>
<li>The key insight is calculating <code>date - ROW_NUMBER()</code> which creates the same value for consecutive dates within each state:
<ul>
<li>For continuous sequences, this difference remains constant</li>
<li>When there’s a gap, the difference changes, creating a new group_id</li>
</ul></li>
<li>The main query then finds the minimum and maximum dates for each group_id within each state to identify continuous periods.</li>
<li>Time complexity: O(n log n) where n is the total number of dates in both tables, due to the sorting operations.</li>
<li>Space complexity: O(n) for the combined dates and result set.</li>
<li>This approach efficiently handles interleaved periods of success and failure and multiple distinct periods of the same state.</li>
<li>The “gaps and islands” technique is particularly elegant for this problem as it naturally identifies continuous sequences.</li>
<li>Results are ordered by start_date as required, showing a chronological view of how the system alternated between success and failure.</li>
<li>For large datasets, indexes on date columns would improve performance.</li>
</ul>
</section>
<section id="number-of-transactions-per-visit" class="level4">
<h4 class="anchored" data-anchor-id="number-of-transactions-per-visit">1336. Number of Transactions per Visit</h4>
<p><strong>Description:</strong></p>
<table class="caption-top table">
<caption>Visits</caption>
<colgroup>
<col style="width: 22%">
<col style="width: 13%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>user_id visit_date</td>
<td>int date</td>
</tr>
</tbody>
</table>
<p>(user_id, visit_date) is the primary key for this table. Each row of this table indicates that user_id has visited the bank in visit_date.</p>
<table class="caption-top table">
<caption>Transactions</caption>
<colgroup>
<col style="width: 26%">
<col style="width: 13%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>user_id transaction_date amount</td>
<td>int date int</td>
</tr>
</tbody>
</table>
<p>There is no primary key for this table, it may contain duplicates. Each row of this table indicates that user_id has done a transaction of amount in transaction_date. It is guaranteed that the user has visited the bank in the transaction_date.(i.e The Visits table contains (user_id, transaction_date) in one row)</p>
<p>Write an SQL query to find how many users visited the bank and didn’t do any transactions, how many visited the bank and did one transaction and so on.</p>
<p>The result table will contain two columns: - transactions_count which is the number of transactions done in one visit. - visits_count which is the corresponding number of visits with transactions_count transactions.</p>
<p>Return the result table ordered by transactions_count.</p>
<p><strong>Solution:</strong></p>
<div class="sourceCode" id="cb14"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Write your PostgreSQL query statement below</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="kw">WITH</span> transactions_per_visit <span class="kw">AS</span> (</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> v.user_id, v.visit_date, <span class="fu">COUNT</span>(t.transaction_date) <span class="kw">AS</span> t_count</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> Visits v <span class="kw">LEFT</span> <span class="kw">JOIN</span> Transactions t</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">ON</span> v.user_id <span class="op">=</span> t.user_id <span class="kw">AND</span> v.visit_date <span class="op">=</span> t.transaction_date</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">GROUP</span> <span class="kw">BY</span> v.user_id, v.visit_date</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>max_transactions <span class="kw">AS</span> (</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> <span class="fu">MAX</span>(t_count) <span class="kw">AS</span> max_t</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> transactions_per_visit</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>t_counts <span class="kw">AS</span> (</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> t_count, <span class="fu">COUNT</span>(<span class="op">*</span>) <span class="kw">AS</span> v_count</span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> transactions_per_visit</span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">GROUP</span> <span class="kw">BY</span> t_count</span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a>all_counts <span class="kw">AS</span> (</span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> GENERATE_SERIES(<span class="dv">0</span>, max_t) <span class="kw">AS</span> transactions_count</span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> max_transactions</span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> a.transactions_count, <span class="fu">COALESCE</span>(tc.v_count, <span class="dv">0</span>) <span class="kw">AS</span> visits_count</span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> all_counts a <span class="kw">LEFT</span> <span class="kw">JOIN</span> t_counts tc </span>
<span id="cb14-27"><a href="#cb14-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">ON</span> a.transactions_count <span class="op">=</span> tc.t_count</span>
<span id="cb14-28"><a href="#cb14-28" aria-hidden="true" tabindex="-1"></a><span class="kw">ORDER</span> <span class="kw">BY</span> a.transactions_count</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Explanation:</strong></p>
<ul>
<li>This query calculates how many users made different numbers of transactions per visit to the bank, including those who made no transactions.</li>
<li>The solution uses a multi-step approach with several Common Table Expressions (CTEs):
<ul>
<li>The first CTE, <code>transactions_per_visit</code>, counts the number of transactions each visitor made on each visit date.</li>
<li>Using LEFT JOIN ensures we include visits with zero transactions.</li>
<li>The second CTE, <code>max_transactions</code>, finds the maximum number of transactions made in any single visit.</li>
<li>The third CTE, <code>transaction_counts</code>, counts visits grouped by their transaction count.</li>
<li>The fourth CTE, <code>all_counts</code>, generates a sequence of numbers from 0 to the maximum transaction count.</li>
</ul></li>
<li>The main query joins the transaction counts with the generated sequence to ensure all possible transaction counts appear in the results.</li>
<li>COALESCE(tc.visits_count, 0) handles transaction counts that didn’t occur in the data, displaying a count of 0.</li>
<li>Results are ordered by transactions_count as specified in the requirements.</li>
<li>Time complexity: O(n log n) where n is the number of visits, due to the grouping and sorting operations.</li>
<li>Space complexity: O(m) where m is the maximum number of transactions made in any visit.</li>
<li>The use of PostgreSQL’s generate_series() function elegantly creates a complete series of transaction counts.</li>
<li>For large datasets, indexes on user_id and visit_date/transaction_date would improve join performance.</li>
<li>An important edge case handled by this solution is when there are gaps in the transaction counts (e.g., some visitors made 0, 1, or 3 transactions but none made exactly 2).</li>
<li>The LEFT JOIN in the main query ensures these gaps are filled with zeros in the final output.</li>
<li>The COALESCE function in the max_transactions CTE handles the edge case where there are no transactions at all.</li>
<li>This approach is particularly efficient as it avoids complex recursive CTEs or self-joins that might be needed in other SQL dialects.</li>
</ul>
</section>
<section id="get-the-second-most-recent-activity" class="level4">
<h4 class="anchored" data-anchor-id="get-the-second-most-recent-activity">1369. Get the Second Most Recent Activity</h4>
<p><strong>Description:</strong></p>
<table class="caption-top table">
<caption>UserActivity</caption>
<colgroup>
<col style="width: 22%">
<col style="width: 13%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>username activity startDate endDate</td>
<td>varchar varchar date date</td>
</tr>
</tbody>
</table>
<p>There is no primary key for this table. It may contain duplicates. This table contains information about the activity performed by each user in a period of time. A person with username performed an activity from startDate to endDate.</p>
<p>Write an SQL query to show the second most recent activity of each user.</p>
<p>If the user only has one activity, return that one. A user cannot perform more than one activity at the same time.</p>
<p>Return the result table in any order.</p>
<p><strong>Solution:</strong></p>
<div class="sourceCode" id="cb15"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Write your PostgreSQL query statement below</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="kw">WITH</span> base <span class="kw">AS</span> (</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> <span class="op">*</span>, <span class="fu">RANK</span>() <span class="kw">OVER</span> (<span class="kw">PARTITION</span> <span class="kw">BY</span> username <span class="kw">ORDER</span> <span class="kw">BY</span> startDate <span class="kw">DESC</span>) <span class="kw">AS</span> act_rank</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>        , <span class="fu">COUNT</span>(<span class="op">*</span>) <span class="kw">OVER</span> (<span class="kw">PARTITION</span> <span class="kw">BY</span> username) <span class="kw">AS</span> act_count</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> UserActivity</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">GROUP</span> <span class="kw">BY</span> username, activity, startDate, endDate</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> username, activity, startdate <span class="kw">AS</span> <span class="ot">"startDate"</span>, enddate <span class="kw">AS</span> <span class="ot">"endDate"</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> base</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a><span class="kw">WHERE</span> act_rank <span class="op">=</span> <span class="dv">2</span> <span class="kw">OR</span> act_count <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a><span class="kw">ORDER</span> <span class="kw">BY</span> username</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Explanation:</strong></p>
<ul>
<li>This query finds the second most recent activity for each user, or their only activity if they have just one.</li>
<li>The solution uses a single Common Table Expression (CTE) with window functions to rank activities and count them for each user:
<ul>
<li><code>ROW_NUMBER() OVER (PARTITION BY username ORDER BY startDate DESC)</code> assigns a rank to each activity based on recency.</li>
<li><code>COUNT(*) OVER (PARTITION BY username)</code> counts the total number of activities for each user.</li>
</ul></li>
<li>The main query then filters the results with two conditions:
<ul>
<li>For users with only one activity (activity_count = 1), return that activity.</li>
<li>For users with multiple activities, return the second most recent (activity_rank = 2).</li>
</ul></li>
<li>Time complexity: O(n log n) where n is the number of activities, due to the sorting operations.</li>
<li>Space complexity: O(n) for the CTE and result set.</li>
<li>The problem statement guarantees that users cannot perform more than one activity at the same time, which simplifies the solution.</li>
<li>ROW_NUMBER() is the appropriate window function here as we need the exact second most recent activity.</li>
<li>The startDate is used for ordering to determine recency, as specified in the problem.</li>
<li>For large datasets, an index on username and startDate would improve performance.</li>
<li>The solution handles the edge case of users with only one activity by explicitly checking for this condition.</li>
<li>This approach is more efficient than using subqueries to filter for the second most recent activity.</li>
<li>The WHERE clause uses a logical OR to combine the two conditions, making the query more readable than using a CASE expression.</li>
<li>If the activities table is very large, this solution scales well as it only requires a single pass through the data.</li>
<li>The window functions eliminate the need for self-joins or multiple aggregations, resulting in a more efficient query.</li>
</ul>
</section>
<section id="total-sales-amount-by-year" class="level4">
<h4 class="anchored" data-anchor-id="total-sales-amount-by-year">1384. Total Sales Amount by Year</h4>
<p><strong>Description:</strong></p>
<table class="caption-top table">
<caption>Product</caption>
<colgroup>
<col style="width: 22%">
<col style="width: 13%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>product_id product_name</td>
<td>int varchar</td>
</tr>
</tbody>
</table>
<p>product_id is the primary key for this table. product_name is the name of the product.</p>
<table class="caption-top table">
<caption>Sales</caption>
<colgroup>
<col style="width: 30%">
<col style="width: 13%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>product_id period_start period_end average_daily_sales</td>
<td>int date date int</td>
</tr>
</tbody>
</table>
<p>product_id is the primary key for this table. period_start and period_end indicate the start and end date for the sales period, and both dates are inclusive. The average_daily_sales column holds the average daily sales amount of the items for the period.</p>
<p>Write an SQL query to report the total sales amount of each item for each year, with corresponding product_name, product_id, product_name, and report_year.</p>
<p>Return the result table ordered by product_id and report_year.</p>
<p><strong>Solution:</strong></p>
<div class="sourceCode" id="cb16"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">WITH</span> RECURSIVE year_ranges <span class="kw">AS</span> (</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>        <span class="fu">EXTRACT</span>(<span class="dt">YEAR</span> <span class="kw">FROM</span> <span class="fu">MIN</span>(period_start)) <span class="kw">AS</span> start_year,</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>        <span class="fu">EXTRACT</span>(<span class="dt">YEAR</span> <span class="kw">FROM</span> <span class="fu">MAX</span>(period_end)) <span class="kw">AS</span> end_year</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>        Sales</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>years <span class="kw">AS</span> (</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> start_year <span class="kw">AS</span> <span class="dt">year</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> year_ranges</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">UNION</span> <span class="kw">ALL</span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> <span class="dt">year</span> <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> years</span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">WHERE</span> <span class="dt">year</span> <span class="op">&lt;</span> (<span class="kw">SELECT</span> end_year <span class="kw">FROM</span> year_ranges)</span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>sales_by_year <span class="kw">AS</span> (</span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span></span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a>        s.product_id,</span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a>        p.product_name,</span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a>        y.<span class="dt">year</span>:<span class="ch">:int</span> <span class="kw">AS</span> report_year,</span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">CASE</span></span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">WHEN</span> <span class="fu">EXTRACT</span>(<span class="dt">YEAR</span> <span class="kw">FROM</span> s.period_start) <span class="op">=</span> <span class="fu">EXTRACT</span>(<span class="dt">YEAR</span> <span class="kw">FROM</span> s.period_end) <span class="cf">THEN</span></span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true" tabindex="-1"></a>                s.average_daily_sales <span class="op">*</span> (s.period_end <span class="op">-</span> s.period_start <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb16-26"><a href="#cb16-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">WHEN</span> y.<span class="dt">year</span> <span class="op">=</span> <span class="fu">EXTRACT</span>(<span class="dt">YEAR</span> <span class="kw">FROM</span> s.period_start) <span class="cf">THEN</span></span>
<span id="cb16-27"><a href="#cb16-27" aria-hidden="true" tabindex="-1"></a>                s.average_daily_sales <span class="op">*</span> (DATE_TRUNC(<span class="st">'year'</span>, s.period_start <span class="op">+</span> <span class="dt">interval</span> <span class="st">'1 year'</span>) <span class="op">-</span> s.period_start):<span class="ch">:int</span></span>
<span id="cb16-28"><a href="#cb16-28" aria-hidden="true" tabindex="-1"></a>            <span class="cf">WHEN</span> y.<span class="dt">year</span> <span class="op">=</span> <span class="fu">EXTRACT</span>(<span class="dt">YEAR</span> <span class="kw">FROM</span> s.period_end) <span class="cf">THEN</span></span>
<span id="cb16-29"><a href="#cb16-29" aria-hidden="true" tabindex="-1"></a>                s.average_daily_sales <span class="op">*</span> (s.period_end <span class="op">-</span> DATE_TRUNC(<span class="st">'year'</span>, s.period_end) <span class="op">+</span> <span class="dv">1</span>):<span class="ch">:int</span></span>
<span id="cb16-30"><a href="#cb16-30" aria-hidden="true" tabindex="-1"></a>            <span class="cf">ELSE</span></span>
<span id="cb16-31"><a href="#cb16-31" aria-hidden="true" tabindex="-1"></a>                s.average_daily_sales <span class="op">*</span> (DATE_TRUNC(<span class="st">'year'</span>, MAKE_DATE(y.<span class="dt">year</span>:<span class="ch">:int</span> <span class="op">+</span> <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>)) <span class="op">-</span> DATE_TRUNC(<span class="st">'year'</span>, MAKE_DATE(y.<span class="dt">year</span>:<span class="ch">:int</span>, <span class="dv">1</span>, <span class="dv">1</span>))):<span class="ch">:int</span></span>
<span id="cb16-32"><a href="#cb16-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">END</span> <span class="kw">AS</span> total_amount</span>
<span id="cb16-33"><a href="#cb16-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span></span>
<span id="cb16-34"><a href="#cb16-34" aria-hidden="true" tabindex="-1"></a>        Sales s</span>
<span id="cb16-35"><a href="#cb16-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">JOIN</span></span>
<span id="cb16-36"><a href="#cb16-36" aria-hidden="true" tabindex="-1"></a>        Product p <span class="kw">ON</span> s.product_id <span class="op">=</span> p.product_id</span>
<span id="cb16-37"><a href="#cb16-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">JOIN</span></span>
<span id="cb16-38"><a href="#cb16-38" aria-hidden="true" tabindex="-1"></a>        years y <span class="kw">ON</span> y.<span class="dt">year</span> <span class="kw">BETWEEN</span> <span class="fu">EXTRACT</span>(<span class="dt">YEAR</span> <span class="kw">FROM</span> s.period_start) <span class="kw">AND</span> <span class="fu">EXTRACT</span>(<span class="dt">YEAR</span> <span class="kw">FROM</span> s.period_end)</span>
<span id="cb16-39"><a href="#cb16-39" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb16-40"><a href="#cb16-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-41"><a href="#cb16-41" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span></span>
<span id="cb16-42"><a href="#cb16-42" aria-hidden="true" tabindex="-1"></a>    product_id,</span>
<span id="cb16-43"><a href="#cb16-43" aria-hidden="true" tabindex="-1"></a>    product_name,</span>
<span id="cb16-44"><a href="#cb16-44" aria-hidden="true" tabindex="-1"></a>    report_year:<span class="ch">:text</span> <span class="kw">AS</span> report_year,</span>
<span id="cb16-45"><a href="#cb16-45" aria-hidden="true" tabindex="-1"></a>    total_amount</span>
<span id="cb16-46"><a href="#cb16-46" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span></span>
<span id="cb16-47"><a href="#cb16-47" aria-hidden="true" tabindex="-1"></a>    sales_by_year</span>
<span id="cb16-48"><a href="#cb16-48" aria-hidden="true" tabindex="-1"></a><span class="kw">ORDER</span> <span class="kw">BY</span></span>
<span id="cb16-49"><a href="#cb16-49" aria-hidden="true" tabindex="-1"></a>    product_id, report_year;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Explanation:</strong></p>
<ul>
<li>This query calculates the total sales amount for each product, broken down by year, for periods that may span multiple years.</li>
<li>The solution uses a three-step approach with recursive Common Table Expressions (CTEs):
<ul>
<li>The first CTE, <code>year_ranges</code>, determines the overall range of years covered by the sales data.</li>
<li>The second CTE, <code>years</code>, recursively generates a list of all years in that range.</li>
<li>The third CTE, <code>sales_by_year</code>, calculates sales for each product in each year using a complex CASE expression.</li>
</ul></li>
<li>The CASE expression handles four scenarios:
<ul>
<li>When the entire sales period is within a single year, simply multiply average_daily_sales by the total number of days.</li>
<li>When calculating for the start year of a multi-year period, compute days from period_start to the end of that year.</li>
<li>When calculating for the end year of a multi-year period, compute days from the start of that year to period_end.</li>
<li>For complete years in the middle of a period, use the full year’s days (accounting for leap years).</li>
</ul></li>
<li>The main query formats the results and orders them by product_id and report_year.</li>
<li>Time complexity: O(n × y) where n is the number of sales records and y is the number of years in the date range.</li>
<li>Space complexity: O(n × y) for the generated result set with each product-year combination.</li>
<li>This solution properly handles sales periods spanning multiple years, a key challenge of this problem.</li>
<li>The recursive CTE to generate years is more efficient than using a calendar table for small to medium datasets.</li>
<li>DATE_TRUNC and MAKE_DATE functions handle the year boundaries precisely, accounting for leap years.</li>
<li>Adding 1 in the date difference calculations ensures inclusive date ranges as specified in the problem.</li>
<li>The conversion of year to text in the final query ensures consistent formatting of the report_year column.</li>
<li>For large datasets with sales periods spanning many years, this solution may create many rows, but remains efficient.</li>
<li>An index on product_id and the period_start/period_end columns would improve join performance.</li>
<li>This approach correctly handles edge cases like sales periods starting or ending on year boundaries.</li>
<li>The solution works for any date range, not just specific years, making it adaptable to different datasets.</li>
</ul>
</section>
<section id="find-the-quiet-students-in-all-exams" class="level4">
<h4 class="anchored" data-anchor-id="find-the-quiet-students-in-all-exams">1412. Find the Quiet Students in All Exams</h4>
<p><strong>Description:</strong></p>
<table class="caption-top table">
<caption>Student</caption>
<colgroup>
<col style="width: 30%">
<col style="width: 13%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>student_id student_name</td>
<td>int varchar</td>
</tr>
</tbody>
</table>
<p>student_id is the primary key for this table. student_name is the name of the student.</p>
<table class="caption-top table">
<caption>Exam</caption>
<colgroup>
<col style="width: 22%">
<col style="width: 13%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>exam_id student_id score</td>
<td>int int int</td>
</tr>
</tbody>
</table>
<p>(exam_id, student_id) is the primary key for this table. Each row of this table indicates that the student with student_id had a score of score in the exam with id exam_id.</p>
<p>A quiet student is the one who took at least one exam and did not score the highest or the lowest score in any of the exams.</p>
<p>Write an SQL query to report the students (student_id, student_name) being quiet in all exams. Don’t return the student who has never taken any exam.</p>
<p>Return the result table ordered by student_id.</p>
<p><strong>Solution:</strong></p>
<div class="sourceCode" id="cb17"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">WITH</span> ranking <span class="kw">AS</span> (</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>        e.exam_id,</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>        e.student_id,</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>        e.score,</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>        <span class="fu">RANK</span>() <span class="kw">OVER</span> (<span class="kw">PARTITION</span> <span class="kw">BY</span> e.exam_id <span class="kw">ORDER</span> <span class="kw">BY</span> e.score <span class="kw">ASC</span>) <span class="kw">AS</span> low_rank,</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>        <span class="fu">RANK</span>() <span class="kw">OVER</span> (<span class="kw">PARTITION</span> <span class="kw">BY</span> e.exam_id <span class="kw">ORDER</span> <span class="kw">BY</span> e.score <span class="kw">DESC</span>) <span class="kw">AS</span> high_rank,</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>        <span class="fu">COUNT</span>(<span class="op">*</span>) <span class="kw">OVER</span> (<span class="kw">PARTITION</span> <span class="kw">BY</span> e.exam_id) <span class="kw">AS</span> exam_count</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>        Exam e</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>extremes <span class="kw">AS</span> (</span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> <span class="kw">DISTINCT</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>        student_id</span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>        ranking</span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">WHERE</span></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>        (low_rank <span class="op">=</span> <span class="dv">1</span> <span class="kw">OR</span> high_rank <span class="op">=</span> <span class="dv">1</span>)</span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a>        <span class="kw">AND</span> exam_count <span class="op">&gt;</span> <span class="dv">1</span>  <span class="co">-- Only consider exams with multiple students</span></span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span></span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a>    s.student_id,</span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a>    s.student_name</span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span></span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true" tabindex="-1"></a>    Student s</span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true" tabindex="-1"></a><span class="kw">JOIN</span></span>
<span id="cb17-28"><a href="#cb17-28" aria-hidden="true" tabindex="-1"></a>    Exam e <span class="kw">ON</span> s.student_id <span class="op">=</span> e.student_id</span>
<span id="cb17-29"><a href="#cb17-29" aria-hidden="true" tabindex="-1"></a><span class="kw">LEFT</span> <span class="kw">JOIN</span></span>
<span id="cb17-30"><a href="#cb17-30" aria-hidden="true" tabindex="-1"></a>    extremes ex <span class="kw">ON</span> s.student_id <span class="op">=</span> ex.student_id</span>
<span id="cb17-31"><a href="#cb17-31" aria-hidden="true" tabindex="-1"></a><span class="kw">WHERE</span></span>
<span id="cb17-32"><a href="#cb17-32" aria-hidden="true" tabindex="-1"></a>    ex.student_id <span class="kw">IS</span> <span class="kw">NULL</span></span>
<span id="cb17-33"><a href="#cb17-33" aria-hidden="true" tabindex="-1"></a><span class="kw">GROUP</span> <span class="kw">BY</span></span>
<span id="cb17-34"><a href="#cb17-34" aria-hidden="true" tabindex="-1"></a>    s.student_id, s.student_name</span>
<span id="cb17-35"><a href="#cb17-35" aria-hidden="true" tabindex="-1"></a><span class="kw">ORDER</span> <span class="kw">BY</span></span>
<span id="cb17-36"><a href="#cb17-36" aria-hidden="true" tabindex="-1"></a>    s.student_id;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Explanation:</strong></p>
<ul>
<li>This query finds “quiet students” who took at least one exam but never scored the highest or lowest in any exam they took.</li>
<li>The solution uses a two-step approach with Common Table Expressions (CTEs):
<ul>
<li>The first CTE, <code>ranking</code>, assigns both low and high ranks to each student’s score within each exam using RANK().</li>
<li>The second CTE, <code>extremes</code>, identifies students who scored either the highest or lowest in any exam.</li>
</ul></li>
<li>RANK() is used instead of ROW_NUMBER() to handle ties properly—multiple students can share the highest or lowest score.</li>
<li>The main query joins the Student table with Exam to ensure we only include students who took at least one exam.</li>
<li>The LEFT JOIN with the extremes CTE, combined with WHERE ex.student_id IS NULL, filters out students who ever had extreme scores.</li>
<li>The GROUP BY ensures each student appears only once in the results, even if they took multiple exams.</li>
<li>Time complexity: O(n log n) where n is the number of exam records, due to the sorting operations.</li>
<li>Space complexity: O(n) for the CTEs and result set.</li>
<li>The solution properly handles edge cases:
<ul>
<li>Exams with only one student are handled by checking exam_count &gt; 1 in the extremes CTE.</li>
<li>Students who tied for highest/lowest scores are all excluded, as required.</li>
</ul></li>
<li>The COUNT(*) OVER window function efficiently counts students in each exam without additional grouping.</li>
<li>For large datasets, indexes on student_id and exam_id would improve join performance.</li>
<li>The DISTINCT in the extremes CTE ensures that if a student scored highest in one exam and lowest in another, they’re only counted once.</li>
<li>This solution efficiently excludes students who never took any exam by using an INNER JOIN with Exam in the main query.</li>
<li>The query follows the requirement to order results by student_id.</li>
<li>An alternative approach could use NOT EXISTS subqueries, but the CTE method is more readable and often performs better.</li>
</ul>
</section>
<section id="sales-by-day-of-the-week" class="level4">
<h4 class="anchored" data-anchor-id="sales-by-day-of-the-week">1479. Sales by Day of the Week</h4>
<p><strong>Description:</strong></p>
<table class="caption-top table">
<caption>Orders</caption>
<colgroup>
<col style="width: 22%">
<col style="width: 13%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>order_id customer_id order_date item_id quantity</td>
<td>int int date varchar int</td>
</tr>
</tbody>
</table>
<p>(order_id, item_id) is the primary key for this table. This table contains information on the orders placed. order_date is the date when the order was placed. item_id is the id of the item. quantity is the number of items ordered.</p>
<table class="caption-top table">
<caption>Items</caption>
<colgroup>
<col style="width: 30%">
<col style="width: 13%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>item_id item_name item_category</td>
<td>varchar varchar varchar</td>
</tr>
</tbody>
</table>
<p>item_id is the primary key for this table. item_name is the name of the item. item_category is the category of the item.</p>
<p>Write an SQL query to report how many units in each category were ordered on each day of the week.</p>
<p>Return the result table ordered by category.</p>
<p><strong>Solution:</strong></p>
<div class="sourceCode" id="cb18"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">WITH</span> daily_sales <span class="kw">AS</span> (</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>        i.item_category <span class="kw">AS</span> <span class="kw">Category</span>,</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>        <span class="fu">EXTRACT</span>(DOW <span class="kw">FROM</span> o.order_date) <span class="kw">AS</span> day_of_week,</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>        <span class="fu">COALESCE</span>(<span class="fu">SUM</span>(o.quantity), <span class="dv">0</span>) <span class="kw">AS</span> total_quantity</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>        Items i</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">LEFT</span> <span class="kw">JOIN</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>        Orders o <span class="kw">ON</span> i.item_id <span class="op">=</span> o.item_id</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">GROUP</span> <span class="kw">BY</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>        i.item_category, <span class="fu">EXTRACT</span>(DOW <span class="kw">FROM</span> o.order_date)</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">Category</span>,</span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>    <span class="fu">COALESCE</span>(<span class="fu">SUM</span>(<span class="cf">CASE</span> <span class="cf">WHEN</span> day_of_week <span class="op">=</span> <span class="dv">0</span> <span class="cf">THEN</span> total_quantity <span class="cf">ELSE</span> <span class="dv">0</span> <span class="cf">END</span>), <span class="dv">0</span>) <span class="kw">AS</span> Monday,</span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>    <span class="fu">COALESCE</span>(<span class="fu">SUM</span>(<span class="cf">CASE</span> <span class="cf">WHEN</span> day_of_week <span class="op">=</span> <span class="dv">1</span> <span class="cf">THEN</span> total_quantity <span class="cf">ELSE</span> <span class="dv">0</span> <span class="cf">END</span>), <span class="dv">0</span>) <span class="kw">AS</span> Tuesday,</span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>    <span class="fu">COALESCE</span>(<span class="fu">SUM</span>(<span class="cf">CASE</span> <span class="cf">WHEN</span> day_of_week <span class="op">=</span> <span class="dv">2</span> <span class="cf">THEN</span> total_quantity <span class="cf">ELSE</span> <span class="dv">0</span> <span class="cf">END</span>), <span class="dv">0</span>) <span class="kw">AS</span> Wednesday,</span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a>    <span class="fu">COALESCE</span>(<span class="fu">SUM</span>(<span class="cf">CASE</span> <span class="cf">WHEN</span> day_of_week <span class="op">=</span> <span class="dv">3</span> <span class="cf">THEN</span> total_quantity <span class="cf">ELSE</span> <span class="dv">0</span> <span class="cf">END</span>), <span class="dv">0</span>) <span class="kw">AS</span> Thursday,</span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a>    <span class="fu">COALESCE</span>(<span class="fu">SUM</span>(<span class="cf">CASE</span> <span class="cf">WHEN</span> day_of_week <span class="op">=</span> <span class="dv">4</span> <span class="cf">THEN</span> total_quantity <span class="cf">ELSE</span> <span class="dv">0</span> <span class="cf">END</span>), <span class="dv">0</span>) <span class="kw">AS</span> Friday,</span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a>    <span class="fu">COALESCE</span>(<span class="fu">SUM</span>(<span class="cf">CASE</span> <span class="cf">WHEN</span> day_of_week <span class="op">=</span> <span class="dv">5</span> <span class="cf">THEN</span> total_quantity <span class="cf">ELSE</span> <span class="dv">0</span> <span class="cf">END</span>), <span class="dv">0</span>) <span class="kw">AS</span> Saturday,</span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a>    <span class="fu">COALESCE</span>(<span class="fu">SUM</span>(<span class="cf">CASE</span> <span class="cf">WHEN</span> day_of_week <span class="op">=</span> <span class="dv">6</span> <span class="cf">THEN</span> total_quantity <span class="cf">ELSE</span> <span class="dv">0</span> <span class="cf">END</span>), <span class="dv">0</span>) <span class="kw">AS</span> Sunday</span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span></span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true" tabindex="-1"></a>    daily_sales</span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true" tabindex="-1"></a><span class="kw">GROUP</span> <span class="kw">BY</span></span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">Category</span></span>
<span id="cb18-27"><a href="#cb18-27" aria-hidden="true" tabindex="-1"></a><span class="kw">ORDER</span> <span class="kw">BY</span></span>
<span id="cb18-28"><a href="#cb18-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">Category</span>;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Explanation:</strong></p>
<ul>
<li>This query reports the number of units ordered for each item category, broken down by day of the week.</li>
<li>The solution uses a pivot table approach with a Common Table Expression (CTE):
<ul>
<li>The <code>daily_sales</code> CTE calculates the total quantity of items ordered in each category for each day of the week.</li>
<li>EXTRACT(DOW FROM order_date) converts the order date to a day of week number (0-6, where 0 is Sunday).</li>
<li>The LEFT JOIN ensures all item categories are included, even if they have no orders.</li>
</ul></li>
<li>The main query then pivots the data using CASE expressions and SUM aggregation:
<ul>
<li>Each day gets its own column by filtering on the day_of_week value.</li>
<li>COALESCE handles NULL values by converting them to 0 as required.</li>
</ul></li>
<li>Results are ordered by Category as specified in the requirements.</li>
<li>Time complexity: O(n log n) where n is the number of order records, due to the grouping and sorting operations.</li>
<li>Space complexity: O(c × 7) where c is the number of item categories, as we aggregate into a fixed structure.</li>
<li>Note: PostgreSQL’s EXTRACT(DOW) function numbers days from 0 (Sunday) to 6 (Saturday), but the query adapts by mapping these values to the correct day names.</li>
<li>The solution handles cases where a category has no orders on specific days by using COALESCE to convert NULLs to 0.</li>
<li>For large datasets, indexes on item_id in both tables would improve join performance.</li>
<li>This approach effectively transforms row-level data into a column-based report format, a common requirement in business reporting.</li>
<li>Using a CTE first to aggregate the data and then pivoting it is often more efficient than pivoting directly from the base tables.</li>
<li>The solution correctly accounts for multiple orders of the same item on the same day by summing quantities.</li>
<li>For very large datasets, consider partitioning the Orders table by date range to improve query performance.</li>
</ul>
</section>
<section id="hopper-company-queries-i" class="level4">
<h4 class="anchored" data-anchor-id="hopper-company-queries-i">1635. Hopper Company Queries I</h4>
<p><strong>Description:</strong></p>
<table class="caption-top table">
<caption>Drivers</caption>
<colgroup>
<col style="width: 19%">
<col style="width: 13%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>driver_id join_date</td>
<td>int date</td>
</tr>
</tbody>
</table>
<p>driver_id is the primary key for this table. Each row of this table contains the driver’s ID and the date they joined the Hopper company.</p>
<table class="caption-top table">
<caption>Rides</caption>
<colgroup>
<col style="width: 20%">
<col style="width: 13%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>ride_id user_id requested_at</td>
<td>int int date</td>
</tr>
</tbody>
</table>
<p>ride_id is the primary key for this table. Each row of this table contains the ID of a ride, the user’s ID that requested it, and the day they requested it. There may be some ride requests in this table that were not accepted.</p>
<table class="caption-top table">
<caption>AcceptedRides</caption>
<colgroup>
<col style="width: 22%">
<col style="width: 13%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>ride_id driver_id ride_distance ride_duration</td>
<td>int int int int</td>
</tr>
</tbody>
</table>
<p>ride_id is the primary key for this table. Each row of this table contains information about an accepted ride. It is guaranteed that each accepted ride exists in the Rides table.</p>
<p>Write an SQL query to report the following statistics for each month of 2020:</p>
<ul>
<li>The number of drivers currently with the Hopper company by the end of the month (active_drivers).</li>
<li>The number of accepted rides in that month (accepted_rides).</li>
</ul>
<p>Return the result table ordered by month in ascending order, where month is the month’s number (January is 1, February is 2, etc.).</p>
<p><strong>Solution:</strong></p>
<div class="sourceCode" id="cb19"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">WITH</span> RECURSIVE months <span class="kw">AS</span> (</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> <span class="dv">1</span> <span class="kw">AS</span> <span class="dt">month</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">UNION</span> <span class="kw">ALL</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> <span class="dt">month</span> <span class="op">+</span> <span class="dv">1</span> <span class="kw">FROM</span> months <span class="kw">WHERE</span> <span class="dt">month</span> <span class="op">&lt;</span> <span class="dv">12</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>active_drivers_by_month <span class="kw">AS</span> (</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">month</span>,</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>        <span class="fu">COUNT</span>(driver_id) <span class="kw">AS</span> active_drivers</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>        months m</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">CROSS</span> <span class="kw">JOIN</span> </span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>        Drivers d</span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">WHERE</span> </span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>        <span class="fu">EXTRACT</span>(<span class="dt">YEAR</span> <span class="kw">FROM</span> d.join_date) <span class="op">&lt;</span> <span class="dv">2020</span> <span class="kw">OR</span></span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>        (<span class="fu">EXTRACT</span>(<span class="dt">YEAR</span> <span class="kw">FROM</span> d.join_date) <span class="op">=</span> <span class="dv">2020</span> <span class="kw">AND</span> <span class="fu">EXTRACT</span>(<span class="dt">MONTH</span> <span class="kw">FROM</span> d.join_date) <span class="op">&lt;=</span> m.<span class="dt">month</span>)</span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">GROUP</span> <span class="kw">BY</span></span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a>        <span class="dt">month</span></span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a>accepted_rides_by_month <span class="kw">AS</span> (</span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a>        <span class="fu">EXTRACT</span>(<span class="dt">MONTH</span> <span class="kw">FROM</span> r.requested_at) <span class="kw">AS</span> <span class="dt">month</span>,</span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true" tabindex="-1"></a>        <span class="fu">COUNT</span>(ar.ride_id) <span class="kw">AS</span> accepted_rides</span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb19-25"><a href="#cb19-25" aria-hidden="true" tabindex="-1"></a>        Rides r</span>
<span id="cb19-26"><a href="#cb19-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">JOIN</span> </span>
<span id="cb19-27"><a href="#cb19-27" aria-hidden="true" tabindex="-1"></a>        AcceptedRides ar <span class="kw">ON</span> r.ride_id <span class="op">=</span> ar.ride_id</span>
<span id="cb19-28"><a href="#cb19-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">WHERE</span> </span>
<span id="cb19-29"><a href="#cb19-29" aria-hidden="true" tabindex="-1"></a>        <span class="fu">EXTRACT</span>(<span class="dt">YEAR</span> <span class="kw">FROM</span> r.requested_at) <span class="op">=</span> <span class="dv">2020</span></span>
<span id="cb19-30"><a href="#cb19-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">GROUP</span> <span class="kw">BY</span> </span>
<span id="cb19-31"><a href="#cb19-31" aria-hidden="true" tabindex="-1"></a>        <span class="fu">EXTRACT</span>(<span class="dt">MONTH</span> <span class="kw">FROM</span> r.requested_at)</span>
<span id="cb19-32"><a href="#cb19-32" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb19-33"><a href="#cb19-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-34"><a href="#cb19-34" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> </span>
<span id="cb19-35"><a href="#cb19-35" aria-hidden="true" tabindex="-1"></a>    m.<span class="dt">month</span>,</span>
<span id="cb19-36"><a href="#cb19-36" aria-hidden="true" tabindex="-1"></a>    <span class="fu">COALESCE</span>(ad.active_drivers, <span class="dv">0</span>) <span class="kw">AS</span> active_drivers,</span>
<span id="cb19-37"><a href="#cb19-37" aria-hidden="true" tabindex="-1"></a>    <span class="fu">COALESCE</span>(ar.accepted_rides, <span class="dv">0</span>) <span class="kw">AS</span> accepted_rides</span>
<span id="cb19-38"><a href="#cb19-38" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> </span>
<span id="cb19-39"><a href="#cb19-39" aria-hidden="true" tabindex="-1"></a>    months m</span>
<span id="cb19-40"><a href="#cb19-40" aria-hidden="true" tabindex="-1"></a><span class="kw">LEFT</span> <span class="kw">JOIN</span> </span>
<span id="cb19-41"><a href="#cb19-41" aria-hidden="true" tabindex="-1"></a>    active_drivers_by_month ad <span class="kw">ON</span> m.<span class="dt">month</span> <span class="op">=</span> ad.<span class="dt">month</span></span>
<span id="cb19-42"><a href="#cb19-42" aria-hidden="true" tabindex="-1"></a><span class="kw">LEFT</span> <span class="kw">JOIN</span> </span>
<span id="cb19-43"><a href="#cb19-43" aria-hidden="true" tabindex="-1"></a>    accepted_rides_by_month ar <span class="kw">ON</span> m.<span class="dt">month</span> <span class="op">=</span> ar.<span class="dt">month</span></span>
<span id="cb19-44"><a href="#cb19-44" aria-hidden="true" tabindex="-1"></a><span class="kw">ORDER</span> <span class="kw">BY</span> </span>
<span id="cb19-45"><a href="#cb19-45" aria-hidden="true" tabindex="-1"></a>    m.<span class="dt">month</span>;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Explanation:</strong></p>
<ul>
<li>This query generates monthly statistics for a ride-sharing company, focusing on active drivers and accepted rides for each month of 2020.</li>
<li>The solution uses a three-step approach with recursive Common Table Expressions (CTEs):
<ul>
<li>The first CTE, <code>months</code>, generates all 12 months of the year as a base for our report.</li>
<li>The second CTE, <code>active_drivers_by_month</code>, calculates the cumulative count of drivers who joined by the end of each month.</li>
<li>The third CTE, <code>accepted_rides_by_month</code>, counts the accepted rides for each month in 2020.</li>
</ul></li>
<li>For active drivers, we include both drivers who joined in previous years (EXTRACT(YEAR FROM join_date) &lt; 2020) and those who joined in 2020 up to the current month.</li>
<li>The CROSS JOIN ensures each driver is evaluated against every month of the year.</li>
<li>The main query joins all three CTEs to produce the final report, ordered by month.</li>
<li>LEFT JOINs are used to ensure all months appear in the result, even if they have no active drivers or accepted rides.</li>
<li>COALESCE handles NULL values by converting them to 0 as required.</li>
<li>Time complexity: O((m × d) + r) where m is the number of months (12), d is the number of drivers, and r is the number of rides.</li>
<li>Space complexity: O(m) for the result set (12 rows).</li>
<li>This solution correctly handles edge cases:
<ul>
<li>Months with no accepted rides show 0 for accepted_rides</li>
<li>The cumulative count of drivers is maintained across months</li>
</ul></li>
<li>For large datasets, indexes on join_date in Drivers and requested_at in Rides would improve performance.</li>
<li>The recursive CTE approach to generate months is more elegant and portable than using a calendar table for this specific report.</li>
<li>EXTRACT() functions efficiently isolate the year and month components from dates for filtering and grouping.</li>
<li>The query is designed to work in PostgreSQL, using its specific date functions and recursive CTE syntax.</li>
</ul>
</section>
<section id="hopper-company-queries-ii" class="level4">
<h4 class="anchored" data-anchor-id="hopper-company-queries-ii">1645. Hopper Company Queries II</h4>
<p><strong>Description:</strong></p>
<table class="caption-top table">
<caption>Drivers</caption>
<colgroup>
<col style="width: 19%">
<col style="width: 13%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>driver_id join_date</td>
<td>int date</td>
</tr>
</tbody>
</table>
<p>driver_id is the primary key for this table. Each row of this table contains the driver’s ID and the date they joined the Hopper company.</p>
<table class="caption-top table">
<caption>Rides</caption>
<colgroup>
<col style="width: 20%">
<col style="width: 13%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>ride_id user_id requested_at</td>
<td>int int date</td>
</tr>
</tbody>
</table>
<p>ride_id is the primary key for this table. Each row of this table contains the ID of a ride, the user’s ID that requested it, and the day they requested it. There may be some ride requests in this table that were not accepted.</p>
<table class="caption-top table">
<caption>AcceptedRides</caption>
<colgroup>
<col style="width: 22%">
<col style="width: 13%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>ride_id driver_id ride_distance ride_duration</td>
<td>int int int int</td>
</tr>
</tbody>
</table>
<p>ride_id is the primary key for this table. Each row of this table contains information about an accepted ride. It is guaranteed that each accepted ride exists in the Rides table.</p>
<p>Write an SQL query to report the percentage of working drivers (working_percentage) for each month of 2020 where:</p>
<pre><code>Working Percentage = (100 * Number of drivers that accepted at least one ride during the month) / (Number of available drivers during the month)</code></pre>
<p>An available driver is a driver who joined the company before or during the current month and has not quit the company before or during the current month.</p>
<p>Return the result table ordered by month in ascending order, where month is the month’s number (January is 1, February is 2, etc.). Round working_percentage to the nearest 2 decimal places.</p>
<p><strong>Solution:</strong></p>
<div class="sourceCode" id="cb21"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">WITH</span> RECURSIVE months <span class="kw">AS</span> (</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> <span class="dv">1</span> <span class="kw">AS</span> <span class="dt">month</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">UNION</span> <span class="kw">ALL</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> <span class="dt">month</span> <span class="op">+</span> <span class="dv">1</span> <span class="kw">FROM</span> months <span class="kw">WHERE</span> <span class="dt">month</span> <span class="op">&lt;</span> <span class="dv">12</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>available_drivers <span class="kw">AS</span> (</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>        m.<span class="dt">month</span>,</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>        <span class="fu">COUNT</span>(<span class="kw">DISTINCT</span> d.driver_id) <span class="kw">AS</span> available_drivers_count</span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>        months m</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">CROSS</span> <span class="kw">JOIN</span> </span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>        Drivers d</span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">WHERE</span> </span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>        <span class="fu">EXTRACT</span>(<span class="dt">YEAR</span> <span class="kw">FROM</span> d.join_date) <span class="op">&lt;</span> <span class="dv">2020</span> <span class="kw">OR</span></span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>        (<span class="fu">EXTRACT</span>(<span class="dt">YEAR</span> <span class="kw">FROM</span> d.join_date) <span class="op">=</span> <span class="dv">2020</span> <span class="kw">AND</span> <span class="fu">EXTRACT</span>(<span class="dt">MONTH</span> <span class="kw">FROM</span> d.join_date) <span class="op">&lt;=</span> m.<span class="dt">month</span>)</span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">GROUP</span> <span class="kw">BY</span> </span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>        m.<span class="dt">month</span></span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a>working_drivers <span class="kw">AS</span> (</span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a>        <span class="fu">EXTRACT</span>(<span class="dt">MONTH</span> <span class="kw">FROM</span> r.requested_at) <span class="kw">AS</span> <span class="dt">month</span>,</span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true" tabindex="-1"></a>        <span class="fu">COUNT</span>(<span class="kw">DISTINCT</span> ar.driver_id) <span class="kw">AS</span> active_drivers_count</span>
<span id="cb21-24"><a href="#cb21-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb21-25"><a href="#cb21-25" aria-hidden="true" tabindex="-1"></a>        Rides r</span>
<span id="cb21-26"><a href="#cb21-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">JOIN</span> </span>
<span id="cb21-27"><a href="#cb21-27" aria-hidden="true" tabindex="-1"></a>        AcceptedRides ar <span class="kw">ON</span> r.ride_id <span class="op">=</span> ar.ride_id</span>
<span id="cb21-28"><a href="#cb21-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">WHERE</span> </span>
<span id="cb21-29"><a href="#cb21-29" aria-hidden="true" tabindex="-1"></a>        <span class="fu">EXTRACT</span>(<span class="dt">YEAR</span> <span class="kw">FROM</span> r.requested_at) <span class="op">=</span> <span class="dv">2020</span></span>
<span id="cb21-30"><a href="#cb21-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">GROUP</span> <span class="kw">BY</span> </span>
<span id="cb21-31"><a href="#cb21-31" aria-hidden="true" tabindex="-1"></a>        <span class="fu">EXTRACT</span>(<span class="dt">MONTH</span> <span class="kw">FROM</span> r.requested_at)</span>
<span id="cb21-32"><a href="#cb21-32" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb21-33"><a href="#cb21-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-34"><a href="#cb21-34" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> </span>
<span id="cb21-35"><a href="#cb21-35" aria-hidden="true" tabindex="-1"></a>    m.<span class="dt">month</span>,</span>
<span id="cb21-36"><a href="#cb21-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">CASE</span> </span>
<span id="cb21-37"><a href="#cb21-37" aria-hidden="true" tabindex="-1"></a>        <span class="cf">WHEN</span> ad.available_drivers_count <span class="op">=</span> <span class="dv">0</span> <span class="cf">THEN</span> <span class="fl">0.00</span></span>
<span id="cb21-38"><a href="#cb21-38" aria-hidden="true" tabindex="-1"></a>        <span class="cf">ELSE</span> <span class="fu">ROUND</span>((<span class="fu">COALESCE</span>(wd.active_drivers_count, <span class="dv">0</span>) <span class="op">*</span> <span class="fl">100.0</span>) <span class="op">/</span> ad.available_drivers_count, <span class="dv">2</span>)</span>
<span id="cb21-39"><a href="#cb21-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">END</span> <span class="kw">AS</span> working_percentage</span>
<span id="cb21-40"><a href="#cb21-40" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> </span>
<span id="cb21-41"><a href="#cb21-41" aria-hidden="true" tabindex="-1"></a>    months m</span>
<span id="cb21-42"><a href="#cb21-42" aria-hidden="true" tabindex="-1"></a><span class="kw">LEFT</span> <span class="kw">JOIN</span> </span>
<span id="cb21-43"><a href="#cb21-43" aria-hidden="true" tabindex="-1"></a>    available_drivers ad <span class="kw">ON</span> m.<span class="dt">month</span> <span class="op">=</span> ad.<span class="dt">month</span></span>
<span id="cb21-44"><a href="#cb21-44" aria-hidden="true" tabindex="-1"></a><span class="kw">LEFT</span> <span class="kw">JOIN</span> </span>
<span id="cb21-45"><a href="#cb21-45" aria-hidden="true" tabindex="-1"></a>    working_drivers wd <span class="kw">ON</span> m.<span class="dt">month</span> <span class="op">=</span> wd.<span class="dt">month</span></span>
<span id="cb21-46"><a href="#cb21-46" aria-hidden="true" tabindex="-1"></a><span class="kw">ORDER</span> <span class="kw">BY</span> </span>
<span id="cb21-47"><a href="#cb21-47" aria-hidden="true" tabindex="-1"></a>    m.<span class="dt">month</span>;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Explanation:</strong></p>
<ul>
<li>This query calculates the monthly percentage of active drivers (those who accepted at least one ride) out of all available drivers for each month of 2020.</li>
<li>The solution uses a three-step approach with Common Table Expressions (CTEs):
<ul>
<li>The first CTE, <code>months</code>, recursively generates all 12 months of the year as a basis for the report.</li>
<li>The second CTE, <code>available_drivers</code>, counts distinct drivers available in each month (joined before or during the month).</li>
<li>The third CTE, <code>working_drivers</code>, counts distinct drivers who actually accepted rides each month.</li>
</ul></li>
<li>The main query calculates the working percentage using the formula: (active drivers ÷ available drivers) × 100.</li>
<li>ROUND(…, 2) ensures the percentages are rounded to two decimal places as required.</li>
<li>The LEFT JOINs ensure all months appear in the result, even if they have no working drivers.</li>
<li>The CASE expression handles the potential division by zero if there are no available drivers in a month.</li>
<li>Time complexity: O((m × d) + r) where m is the number of months (12), d is the number of drivers, and r is the number of rides.</li>
<li>Space complexity: O(m) for the result set (12 rows).</li>
<li>The DISTINCT keyword in COUNT(DISTINCT driver_id) ensures each driver is counted only once per month, even if they accepted multiple rides.</li>
<li>For large datasets, indexes on join_date, requested_at, and driver_id would improve performance.</li>
<li>The solution correctly handles edge cases:
<ul>
<li>Months with no active drivers show 0.00%</li>
<li>Months with no available drivers show 0.00% (avoiding division by zero)</li>
</ul></li>
<li>The COALESCE function ensures proper calculation even if a month has no working drivers.</li>
<li>Using 100.0 (not 100) in the calculation ensures decimal division rather than integer division, preserving precision.</li>
<li>The query follows the requirement to order results by month in ascending order.</li>
</ul>
</section>
<section id="hopper-company-queries-iii" class="level4">
<h4 class="anchored" data-anchor-id="hopper-company-queries-iii">1651. Hopper Company Queries III</h4>
<p><strong>Description:</strong></p>
<table class="caption-top table">
<caption>Drivers</caption>
<colgroup>
<col style="width: 19%">
<col style="width: 13%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>driver_id join_date</td>
<td>int date</td>
</tr>
</tbody>
</table>
<p>driver_id is the primary key for this table. Each row of this table contains the driver’s ID and the date they joined the Hopper company.</p>
<table class="caption-top table">
<caption>Rides</caption>
<colgroup>
<col style="width: 20%">
<col style="width: 13%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>ride_id user_id requested_at</td>
<td>int int date</td>
</tr>
</tbody>
</table>
<p>ride_id is the primary key for this table. Each row of this table contains the ID of a ride, the user’s ID that requested it, and the day they requested it. There may be some ride requests in this table that were not accepted.</p>
<table class="caption-top table">
<caption>AcceptedRides</caption>
<colgroup>
<col style="width: 22%">
<col style="width: 13%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>ride_id driver_id ride_distance ride_duration</td>
<td>int int int int</td>
</tr>
</tbody>
</table>
<p>ride_id is the primary key for this table. Each row of this table contains information about an accepted ride. It is guaranteed that each accepted ride exists in the Rides table.</p>
<p>Write an SQL query to compute the average_ride_distance and average_ride_duration of every 3-month window starting from January - March 2020 to October - December 2020. Round average_ride_distance and average_ride_duration to the nearest two decimal places.</p>
<p>The average_ride_distance is calculated by summing up the total ride_distance values from the three months and dividing it by 3. The average_ride_duration is calculated in a similar way.</p>
<p>Return the result table ordered by month in ascending order, where month is the starting month’s number (January is 1, February is 2, etc.).</p>
<p><strong>Solution:</strong></p>
<div class="sourceCode" id="cb22"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">WITH</span> RECURSIVE months <span class="kw">AS</span> (</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> generate_series(<span class="dv">1</span>, <span class="dv">10</span>) <span class="kw">AS</span> <span class="dt">month</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>monthly_stats <span class="kw">AS</span> (</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>        <span class="fu">EXTRACT</span>(<span class="dt">MONTH</span> <span class="kw">FROM</span> r.requested_at) <span class="kw">AS</span> <span class="dt">month</span>,</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>        <span class="fu">SUM</span>(ar.ride_distance) <span class="kw">AS</span> total_distance,</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>        <span class="fu">SUM</span>(ar.ride_duration) <span class="kw">AS</span> total_duration,</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>        <span class="fu">COUNT</span>(ar.ride_id) <span class="kw">AS</span> ride_count</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>        Rides r</span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">JOIN</span> </span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>        AcceptedRides ar <span class="kw">ON</span> r.ride_id <span class="op">=</span> ar.ride_id</span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">WHERE</span> </span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>        <span class="fu">EXTRACT</span>(<span class="dt">YEAR</span> <span class="kw">FROM</span> r.requested_at) <span class="op">=</span> <span class="dv">2020</span></span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">GROUP</span> <span class="kw">BY</span> </span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>        <span class="fu">EXTRACT</span>(<span class="dt">MONTH</span> <span class="kw">FROM</span> r.requested_at)</span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a>rolling_window <span class="kw">AS</span> (</span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a>        m1.<span class="dt">month</span>,</span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a>        <span class="fu">COALESCE</span>(ms1.total_distance, <span class="dv">0</span>) <span class="op">+</span> </span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a>        <span class="fu">COALESCE</span>(ms2.total_distance, <span class="dv">0</span>) <span class="op">+</span> </span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true" tabindex="-1"></a>        <span class="fu">COALESCE</span>(ms3.total_distance, <span class="dv">0</span>) <span class="kw">AS</span> three_month_distance,</span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb22-26"><a href="#cb22-26" aria-hidden="true" tabindex="-1"></a>        <span class="fu">COALESCE</span>(ms1.total_duration, <span class="dv">0</span>) <span class="op">+</span> </span>
<span id="cb22-27"><a href="#cb22-27" aria-hidden="true" tabindex="-1"></a>        <span class="fu">COALESCE</span>(ms2.total_duration, <span class="dv">0</span>) <span class="op">+</span> </span>
<span id="cb22-28"><a href="#cb22-28" aria-hidden="true" tabindex="-1"></a>        <span class="fu">COALESCE</span>(ms3.total_duration, <span class="dv">0</span>) <span class="kw">AS</span> three_month_duration,</span>
<span id="cb22-29"><a href="#cb22-29" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb22-30"><a href="#cb22-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">CASE</span> </span>
<span id="cb22-31"><a href="#cb22-31" aria-hidden="true" tabindex="-1"></a>            <span class="cf">WHEN</span> <span class="fu">COALESCE</span>(ms1.ride_count, <span class="dv">0</span>) <span class="op">+</span> <span class="fu">COALESCE</span>(ms2.ride_count, <span class="dv">0</span>) <span class="op">+</span> <span class="fu">COALESCE</span>(ms3.ride_count, <span class="dv">0</span>) <span class="op">=</span> <span class="dv">0</span> </span>
<span id="cb22-32"><a href="#cb22-32" aria-hidden="true" tabindex="-1"></a>            <span class="cf">THEN</span> <span class="dv">1</span> </span>
<span id="cb22-33"><a href="#cb22-33" aria-hidden="true" tabindex="-1"></a>            <span class="cf">ELSE</span> <span class="dv">3</span> </span>
<span id="cb22-34"><a href="#cb22-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">END</span> <span class="kw">AS</span> divisor</span>
<span id="cb22-35"><a href="#cb22-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb22-36"><a href="#cb22-36" aria-hidden="true" tabindex="-1"></a>        months m1</span>
<span id="cb22-37"><a href="#cb22-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">LEFT</span> <span class="kw">JOIN</span> </span>
<span id="cb22-38"><a href="#cb22-38" aria-hidden="true" tabindex="-1"></a>        monthly_stats ms1 <span class="kw">ON</span> m1.<span class="dt">month</span> <span class="op">=</span> ms1.<span class="dt">month</span></span>
<span id="cb22-39"><a href="#cb22-39" aria-hidden="true" tabindex="-1"></a>    <span class="kw">LEFT</span> <span class="kw">JOIN</span> </span>
<span id="cb22-40"><a href="#cb22-40" aria-hidden="true" tabindex="-1"></a>        monthly_stats ms2 <span class="kw">ON</span> m1.<span class="dt">month</span> <span class="op">+</span> <span class="dv">1</span> <span class="op">=</span> ms2.<span class="dt">month</span></span>
<span id="cb22-41"><a href="#cb22-41" aria-hidden="true" tabindex="-1"></a>    <span class="kw">LEFT</span> <span class="kw">JOIN</span> </span>
<span id="cb22-42"><a href="#cb22-42" aria-hidden="true" tabindex="-1"></a>        monthly_stats ms3 <span class="kw">ON</span> m1.<span class="dt">month</span> <span class="op">+</span> <span class="dv">2</span> <span class="op">=</span> ms3.<span class="dt">month</span></span>
<span id="cb22-43"><a href="#cb22-43" aria-hidden="true" tabindex="-1"></a>    <span class="kw">WHERE</span> </span>
<span id="cb22-44"><a href="#cb22-44" aria-hidden="true" tabindex="-1"></a>        m1.<span class="dt">month</span> <span class="op">&lt;=</span> <span class="dv">10</span>  <span class="co">-- Only start windows that can be completed in 2020</span></span>
<span id="cb22-45"><a href="#cb22-45" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb22-46"><a href="#cb22-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-47"><a href="#cb22-47" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> </span>
<span id="cb22-48"><a href="#cb22-48" aria-hidden="true" tabindex="-1"></a>    <span class="dt">month</span>,</span>
<span id="cb22-49"><a href="#cb22-49" aria-hidden="true" tabindex="-1"></a>    <span class="fu">ROUND</span>(<span class="cf">CASE</span> <span class="cf">WHEN</span> three_month_distance <span class="op">=</span> <span class="dv">0</span> <span class="cf">THEN</span> <span class="fl">0.00</span> <span class="cf">ELSE</span> three_month_distance <span class="op">/</span> divisor <span class="cf">END</span>, <span class="dv">2</span>) <span class="kw">AS</span> average_ride_distance,</span>
<span id="cb22-50"><a href="#cb22-50" aria-hidden="true" tabindex="-1"></a>    <span class="fu">ROUND</span>(<span class="cf">CASE</span> <span class="cf">WHEN</span> three_month_duration <span class="op">=</span> <span class="dv">0</span> <span class="cf">THEN</span> <span class="fl">0.00</span> <span class="cf">ELSE</span> three_month_duration <span class="op">/</span> divisor <span class="cf">END</span>, <span class="dv">2</span>) <span class="kw">AS</span> average_ride_duration</span>
<span id="cb22-51"><a href="#cb22-51" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> </span>
<span id="cb22-52"><a href="#cb22-52" aria-hidden="true" tabindex="-1"></a>    rolling_window</span>
<span id="cb22-53"><a href="#cb22-53" aria-hidden="true" tabindex="-1"></a><span class="kw">ORDER</span> <span class="kw">BY</span> </span>
<span id="cb22-54"><a href="#cb22-54" aria-hidden="true" tabindex="-1"></a>    <span class="dt">month</span>;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Explanation:</strong></p>
<ul>
<li>This query calculates three-month rolling window averages for ride distances and durations throughout 2020.</li>
<li>The solution uses a three-step approach with Common Table Expressions (CTEs):
<ul>
<li>The first CTE, <code>months</code>, generates the first 10 months of the year (as we need complete 3-month windows ending in December).</li>
<li>The second CTE, <code>monthly_stats</code>, aggregates the total distance, duration, and count of rides for each month.</li>
<li>The third CTE, <code>rolling_window</code>, joins each month with the following two months to create 3-month windows.</li>
</ul></li>
<li>For each window, we sum the total distances and durations across all three months.</li>
<li>The CASE expression for the divisor handles windows with zero rides (to avoid division by zero).</li>
<li>The query only includes starting months up to October (month &lt;= 10) to ensure each window has three complete months in 2020.</li>
<li>ROUND(…, 2) ensures the averages are rounded to two decimal places as required.</li>
<li>Time complexity: O(r + m) where r is the number of rides and m is the number of months (10).</li>
<li>Space complexity: O(m) for the result set (10 rows).</li>
<li>This solution correctly handles edge cases:
<ul>
<li>Months with no rides show 0.00 for both average metrics</li>
<li>The COALESCE function handles missing months in the data</li>
</ul></li>
<li>For large datasets, indexes on requested_at in Rides and ride_id in AcceptedRides would improve performance.</li>
<li>Using LEFT JOINs between months and stats ensures all months appear in the results, even those with no rides.</li>
<li>The generate_series() function provides a concise way to create the sequence of months in PostgreSQL.</li>
<li>The solution efficiently computes rolling windows without needing window functions or complex self-joins.</li>
<li>The query follows the requirement to order results by starting month in ascending order.</li>
</ul>
</section>
<section id="find-the-subtasks-that-did-not-execute" class="level4">
<h4 class="anchored" data-anchor-id="find-the-subtasks-that-did-not-execute">1767. Find the Subtasks That Did Not Execute</h4>
<p><strong>Description:</strong></p>
<table class="caption-top table">
<caption>Tasks</caption>
<colgroup>
<col style="width: 23%">
<col style="width: 13%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>task_id subtasks_count</td>
<td>int int</td>
</tr>
</tbody>
</table>
<p>task_id is the primary key for this table. Each row in this table indicates that task_id contains subtasks_count subtasks.</p>
<table class="caption-top table">
<caption>Executed</caption>
<colgroup>
<col style="width: 22%">
<col style="width: 13%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>task_id subtask_id</td>
<td>int int</td>
</tr>
</tbody>
</table>
<p>(task_id, subtask_id) is the primary key for this table. Each row in this table indicates that the subtask subtask_id from task task_id was executed.</p>
<p>Write an SQL query to report the IDs of the missing subtasks for each task_id.</p>
<p>Task_id is the ID of the task, and subtask_id is the ID of the subtask. Subtask IDs are numbered from 1 to subtasks_count.</p>
<p>Return the result table in any order.</p>
<p><strong>Solution:</strong></p>
<div class="sourceCode" id="cb23"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">WITH</span> RECURSIVE all_subtasks <span class="kw">AS</span> (</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>        t.task_id,</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>        generate_series(<span class="dv">1</span>, t.subtasks_count) <span class="kw">AS</span> subtask_id</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>        Tasks t</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> </span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>    a.task_id,</span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>    a.subtask_id</span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> </span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a>    all_subtasks a</span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a><span class="kw">LEFT</span> <span class="kw">JOIN</span> </span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a>    Executed e <span class="kw">ON</span> a.task_id <span class="op">=</span> e.task_id <span class="kw">AND</span> a.subtask_id <span class="op">=</span> e.subtask_id</span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a><span class="kw">WHERE</span> </span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true" tabindex="-1"></a>    e.task_id <span class="kw">IS</span> <span class="kw">NULL</span></span>
<span id="cb23-18"><a href="#cb23-18" aria-hidden="true" tabindex="-1"></a><span class="kw">ORDER</span> <span class="kw">BY</span> </span>
<span id="cb23-19"><a href="#cb23-19" aria-hidden="true" tabindex="-1"></a>    a.task_id, a.subtask_id;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Explanation:</strong></p>
<ul>
<li>This query identifies subtasks that were expected to be executed (based on the subtasks_count) but do not appear in the Executed table.</li>
<li>The solution uses a single Common Table Expression (CTE) with PostgreSQL’s generate_series function:
<ul>
<li>The <code>all_subtasks</code> CTE generates all expected subtask IDs for each task based on its subtasks_count.</li>
<li>generate_series(1, subtasks_count) creates a sequence from 1 to the total number of subtasks for each task.</li>
</ul></li>
<li>The main query then uses a LEFT JOIN to find subtasks that don’t have a matching record in the Executed table.</li>
<li>The WHERE clause filters for rows where no match was found (e.task_id IS NULL), identifying subtasks that weren’t executed.</li>
<li>Results are ordered by task_id and subtask_id for readability.</li>
<li>Time complexity: O(n × s) where n is the number of tasks and s is the maximum subtasks_count.</li>
<li>Space complexity: O(n × s) for the full set of potential subtasks.</li>
<li>This solution efficiently handles both executed and missing subtasks, even for tasks with a large number of subtasks.</li>
<li>For large datasets, indexes on (task_id, subtask_id) in both tables would improve join performance.</li>
<li>The generate_series function is a PostgreSQL feature that elegantly solves the problem of generating sequences.</li>
<li>An alternative approach in databases without generate_series would require a numbers or tally table, making this PostgreSQL solution particularly concise.</li>
<li>The query correctly handles edge cases:
<ul>
<li>Tasks with all subtasks executed won’t appear in the results</li>
<li>Tasks with no subtasks executed will have all their subtasks in the results</li>
<li>Tasks with partially executed subtasks will show only the missing ones</li>
</ul></li>
<li>This approach avoids complex recursive queries that might be needed in other database systems.</li>
</ul>
</section>
<section id="page-recommendations-ii" class="level4">
<h4 class="anchored" data-anchor-id="page-recommendations-ii">1892. Page Recommendations II</h4>
<p><strong>Description:</strong></p>
<table class="caption-top table">
<caption>Friendship</caption>
<colgroup>
<col style="width: 22%">
<col style="width: 13%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>user1_id user2_id</td>
<td>int int</td>
</tr>
</tbody>
</table>
<p>(user1_id, user2_id) is the primary key for this table. Each row of this table indicates that there is a friendship relation between user1_id and user2_id.</p>
<table class="caption-top table">
<caption>Likes</caption>
<colgroup>
<col style="width: 19%">
<col style="width: 13%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>user_id page_id</td>
<td>int int</td>
</tr>
</tbody>
</table>
<p>(user_id, page_id) is the primary key for this table. Each row of this table indicates that user_id likes page_id.</p>
<p>Write an SQL query to recommend pages to the users using the following approach:</p>
<p>If a user A likes a page P1, another user B likes a page P2, and both users A and B are friends, then page P2 should be recommended to user A. Note that page P1 should not be recommended to user B since user B already likes it.</p>
<p>Return the result table in any order.</p>
<p><strong>Solution:</strong></p>
<div class="sourceCode" id="cb24"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">WITH</span> friendship_normalized <span class="kw">AS</span> (</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Normalize friendship to ensure consistent directional representation</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> user1_id <span class="kw">AS</span> user_id, user2_id <span class="kw">AS</span> friend_id <span class="kw">FROM</span> Friendship</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">UNION</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> user2_id <span class="kw">AS</span> user_id, user1_id <span class="kw">AS</span> friend_id <span class="kw">FROM</span> Friendship</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>friend_likes <span class="kw">AS</span> (</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Find pages liked by friends</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>        fn.user_id,</span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>        l.page_id,</span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a>        <span class="fu">COUNT</span>(fn.friend_id) <span class="kw">AS</span> friends_count</span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a>        friendship_normalized fn</span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">JOIN</span> </span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true" tabindex="-1"></a>        Likes l <span class="kw">ON</span> fn.friend_id <span class="op">=</span> l.user_id</span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">LEFT</span> <span class="kw">JOIN</span> </span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true" tabindex="-1"></a>        Likes ul <span class="kw">ON</span> fn.user_id <span class="op">=</span> ul.user_id <span class="kw">AND</span> l.page_id <span class="op">=</span> ul.page_id</span>
<span id="cb24-19"><a href="#cb24-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">WHERE</span> </span>
<span id="cb24-20"><a href="#cb24-20" aria-hidden="true" tabindex="-1"></a>        ul.user_id <span class="kw">IS</span> <span class="kw">NULL</span>  <span class="co">-- User doesn't already like this page</span></span>
<span id="cb24-21"><a href="#cb24-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">GROUP</span> <span class="kw">BY</span> </span>
<span id="cb24-22"><a href="#cb24-22" aria-hidden="true" tabindex="-1"></a>        fn.user_id, l.page_id</span>
<span id="cb24-23"><a href="#cb24-23" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb24-24"><a href="#cb24-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-25"><a href="#cb24-25" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> </span>
<span id="cb24-26"><a href="#cb24-26" aria-hidden="true" tabindex="-1"></a>    user_id,</span>
<span id="cb24-27"><a href="#cb24-27" aria-hidden="true" tabindex="-1"></a>    page_id,</span>
<span id="cb24-28"><a href="#cb24-28" aria-hidden="true" tabindex="-1"></a>    friends_count</span>
<span id="cb24-29"><a href="#cb24-29" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> </span>
<span id="cb24-30"><a href="#cb24-30" aria-hidden="true" tabindex="-1"></a>    friend_likes</span>
<span id="cb24-31"><a href="#cb24-31" aria-hidden="true" tabindex="-1"></a><span class="kw">ORDER</span> <span class="kw">BY</span> </span>
<span id="cb24-32"><a href="#cb24-32" aria-hidden="true" tabindex="-1"></a>    user_id, friends_count <span class="kw">DESC</span>, page_id;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Explanation:</strong></p>
<ul>
<li>This query recommends pages to users based on what their friends like, but only if the user doesn’t already like that page.</li>
<li>The solution uses a two-step approach with Common Table Expressions (CTEs):
<ul>
<li>The first CTE, <code>friendship_normalized</code>, converts the bidirectional friendship relation into a normalized directional format.</li>
<li>The second CTE, <code>friend_likes</code>, identifies pages liked by a user’s friends that the user doesn’t already like.</li>
</ul></li>
<li>The UNION operation in the first CTE ensures that friendships are represented in both directions, as they are bidirectional.</li>
<li>The JOIN between friendship_normalized and Likes finds pages liked by friends.</li>
<li>The LEFT JOIN with another instance of Likes checks if the user already likes the page.</li>
<li>The WHERE clause with ul.user_id IS NULL filters out pages the user already likes.</li>
<li>GROUP BY with COUNT aggregates recommendations by friends, counting how many friends like each page.</li>
<li>Time complexity: O(f × l) where f is the number of friendships and l is the number of likes.</li>
<li>Space complexity: O(f + r) where r is the number of recommendations.</li>
<li>This solution correctly handles edge cases:
<ul>
<li>Users with no friends or whose friends have no likes will receive no recommendations</li>
<li>Users who already like all the pages their friends like will receive no recommendations</li>
</ul></li>
<li>For large datasets, indexes on user_id, friend_id, and page_id would significantly improve join performance.</li>
<li>The final ORDER BY clause sorts recommendations first by user_id, then by popularity (friends_count in descending order), and finally by page_id.</li>
<li>The solution avoids complex self-joins by normalizing the friendship relation first.</li>
<li>The approach efficiently handles the mutual friendship relation which is often a challenging aspect of social network queries.</li>
<li>Using COUNT(friend_id) provides additional context about the recommendation’s strength (how many friends like it).</li>
</ul>
</section>
<section id="leetcodify-friends-recommendations" class="level4">
<h4 class="anchored" data-anchor-id="leetcodify-friends-recommendations">1917. Leetcodify Friends Recommendations</h4>
<p><strong>Description:</strong></p>
<table class="caption-top table">
<caption>Listens</caption>
<colgroup>
<col style="width: 19%">
<col style="width: 13%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>user_id song_id day</td>
<td>int int date</td>
</tr>
</tbody>
</table>
<p>There is no primary key for this table. It may contain duplicates. Each row of this table indicates that the user user_id listened to the song song_id on the day day.</p>
<table class="caption-top table">
<caption>Friendship</caption>
<colgroup>
<col style="width: 22%">
<col style="width: 13%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>user1_id user2_id</td>
<td>int int</td>
</tr>
</tbody>
</table>
<p>(user1_id, user2_id) is the primary key for this table. Each row of this table indicates that the users user1_id and user2_id are friends. Note that user1_id &lt; user2_id.</p>
<p>Write an SQL query to recommend friends to Leetcodify users. We recommend user x to user y if:</p>
<ul>
<li>Users x and y are not friends, and</li>
<li>Users x and y listened to the same three or more different songs on the same day.</li>
</ul>
<p>Note that friend recommendations are unidirectional, meaning if user x is recommended to user y, user y is not necessarily recommended to user x.</p>
<p>Return the result table in any order.</p>
<p><strong>Solution:</strong></p>
<div class="sourceCode" id="cb25"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">WITH</span> user_song_days <span class="kw">AS</span> (</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Get distinct user-song-day combinations to avoid duplicates</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> <span class="kw">DISTINCT</span> </span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>        user_id, </span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>        song_id, </span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">day</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>        Listens</span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>common_songs <span class="kw">AS</span> (</span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Count common songs listened to by user pairs on the same day</span></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>        u1.user_id <span class="kw">AS</span> user1_id,</span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>        u2.user_id <span class="kw">AS</span> user2_id,</span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a>        u1.<span class="dt">day</span>,</span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a>        <span class="fu">COUNT</span>(<span class="kw">DISTINCT</span> u1.song_id) <span class="kw">AS</span> song_count</span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a>        user_song_days u1</span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">JOIN</span> </span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a>        user_song_days u2 <span class="kw">ON</span> u1.song_id <span class="op">=</span> u2.song_id <span class="kw">AND</span> u1.<span class="dt">day</span> <span class="op">=</span> u2.<span class="dt">day</span></span>
<span id="cb25-21"><a href="#cb25-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">WHERE</span> </span>
<span id="cb25-22"><a href="#cb25-22" aria-hidden="true" tabindex="-1"></a>        u1.user_id <span class="op">&lt;&gt;</span> u2.user_id</span>
<span id="cb25-23"><a href="#cb25-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">GROUP</span> <span class="kw">BY</span> </span>
<span id="cb25-24"><a href="#cb25-24" aria-hidden="true" tabindex="-1"></a>        u1.user_id, u2.user_id, u1.<span class="dt">day</span></span>
<span id="cb25-25"><a href="#cb25-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">HAVING</span> </span>
<span id="cb25-26"><a href="#cb25-26" aria-hidden="true" tabindex="-1"></a>        <span class="fu">COUNT</span>(<span class="kw">DISTINCT</span> u1.song_id) <span class="op">&gt;=</span> <span class="dv">3</span></span>
<span id="cb25-27"><a href="#cb25-27" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb25-28"><a href="#cb25-28" aria-hidden="true" tabindex="-1"></a>friendship_normalized <span class="kw">AS</span> (</span>
<span id="cb25-29"><a href="#cb25-29" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Normalize friendship to consider both directions</span></span>
<span id="cb25-30"><a href="#cb25-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> user1_id, user2_id <span class="kw">FROM</span> Friendship</span>
<span id="cb25-31"><a href="#cb25-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">UNION</span></span>
<span id="cb25-32"><a href="#cb25-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> user2_id, user1_id <span class="kw">FROM</span> Friendship</span>
<span id="cb25-33"><a href="#cb25-33" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb25-34"><a href="#cb25-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-35"><a href="#cb25-35" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> </span>
<span id="cb25-36"><a href="#cb25-36" aria-hidden="true" tabindex="-1"></a>    cs.user1_id <span class="kw">AS</span> user_id,</span>
<span id="cb25-37"><a href="#cb25-37" aria-hidden="true" tabindex="-1"></a>    cs.user2_id <span class="kw">AS</span> recommended_id</span>
<span id="cb25-38"><a href="#cb25-38" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> </span>
<span id="cb25-39"><a href="#cb25-39" aria-hidden="true" tabindex="-1"></a>    common_songs cs</span>
<span id="cb25-40"><a href="#cb25-40" aria-hidden="true" tabindex="-1"></a><span class="kw">LEFT</span> <span class="kw">JOIN</span> </span>
<span id="cb25-41"><a href="#cb25-41" aria-hidden="true" tabindex="-1"></a>    friendship_normalized fn <span class="kw">ON</span> cs.user1_id <span class="op">=</span> fn.user1_id <span class="kw">AND</span> cs.user2_id <span class="op">=</span> fn.user2_id</span>
<span id="cb25-42"><a href="#cb25-42" aria-hidden="true" tabindex="-1"></a><span class="kw">WHERE</span> </span>
<span id="cb25-43"><a href="#cb25-43" aria-hidden="true" tabindex="-1"></a>    fn.user1_id <span class="kw">IS</span> <span class="kw">NULL</span></span>
<span id="cb25-44"><a href="#cb25-44" aria-hidden="true" tabindex="-1"></a><span class="kw">GROUP</span> <span class="kw">BY</span> </span>
<span id="cb25-45"><a href="#cb25-45" aria-hidden="true" tabindex="-1"></a>    cs.user1_id, cs.user2_id;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Explanation:</strong></p>
<ul>
<li>This query finds potential friend recommendations based on music listening patterns, specifically recommending users who listened to at least 3 of the same songs on the same day but are not already friends.</li>
<li>The solution uses a three-step approach with Common Table Expressions (CTEs):
<ul>
<li>The first CTE, <code>user_song_days</code>, gets distinct user-song-day combinations to avoid counting duplicated listens.</li>
<li>The second CTE, <code>common_songs</code>, identifies pairs of users who listened to at least 3 of the same songs on the same day.</li>
<li>The third CTE, <code>friendship_normalized</code>, normalizes the friendship relation to consider it bidirectional.</li>
</ul></li>
<li>The JOIN in the common_songs CTE pairs users who listened to the same song on the same day.</li>
<li>The HAVING clause ensures we only consider pairs with at least 3 common songs.</li>
<li>The main query excludes pairs that are already friends using a LEFT JOIN and WHERE fn.user1_id IS NULL.</li>
<li>The final GROUP BY eliminates any potential duplicates in the recommendations.</li>
<li>Time complexity: O(n²) where n is the number of user-song-day combinations, due to the self-join operation.</li>
<li>Space complexity: O(n² + f) where f is the number of friendships.</li>
<li>This solution correctly handles edge cases:
<ul>
<li>Users who listened to the same song multiple times on the same day (handled by DISTINCT in the first CTE)</li>
<li>Bidirectional friendship relations (handled by the UNION in the friendship_normalized CTE)</li>
</ul></li>
<li>For large datasets, indexes on user_id, song_id, and day in the Listens table would significantly improve join performance.</li>
<li>The query ensures that recommendations are unidirectional as specified in the requirements.</li>
<li>The approach efficiently identifies common listening patterns without complex window functions or recursive queries.</li>
<li>The DISTINCT keyword in COUNT(DISTINCT song_id) ensures each common song is counted only once.</li>
<li>For particularly large datasets, consider partitioning the Listens table by day to improve query performance.</li>
</ul>
</section>
<section id="leetcodify-similar-friends" class="level4">
<h4 class="anchored" data-anchor-id="leetcodify-similar-friends">1919. Leetcodify Similar Friends</h4>
<p><strong>Description:</strong></p>
<table class="caption-top table">
<caption>Listens</caption>
<colgroup>
<col style="width: 19%">
<col style="width: 13%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>user_id song_id day</td>
<td>int int date</td>
</tr>
</tbody>
</table>
<p>There is no primary key for this table. It may contain duplicates. Each row of this table indicates that the user user_id listened to the song song_id on the day day.</p>
<table class="caption-top table">
<caption>Friendship</caption>
<colgroup>
<col style="width: 22%">
<col style="width: 13%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>user1_id user2_id</td>
<td>int int</td>
</tr>
</tbody>
</table>
<p>(user1_id, user2_id) is the primary key for this table. Each row of this table indicates that the users user1_id and user2_id are friends. Note that user1_id &lt; user2_id.</p>
<p>Write an SQL query to report the similar friends of Leetcodify users. A user x and user y are similar friends if:</p>
<ul>
<li>Users x and y are friends, and</li>
<li>Users x and y listened to the same three or more different songs on the same day.</li>
</ul>
<p>Return the result table in any order.</p>
<p><strong>Solution:</strong></p>
<div class="sourceCode" id="cb26"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">WITH</span> user_song_days <span class="kw">AS</span> (</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Get distinct user-song-day combinations to avoid duplicates</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> <span class="kw">DISTINCT</span> </span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>        user_id, </span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>        song_id, </span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">day</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>        Listens</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>common_songs <span class="kw">AS</span> (</span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Count common songs listened to by user pairs on the same day</span></span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">CASE</span> <span class="cf">WHEN</span> u1.user_id <span class="op">&lt;</span> u2.user_id <span class="cf">THEN</span> u1.user_id <span class="cf">ELSE</span> u2.user_id <span class="cf">END</span> <span class="kw">AS</span> user1_id,</span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">CASE</span> <span class="cf">WHEN</span> u1.user_id <span class="op">&lt;</span> u2.user_id <span class="cf">THEN</span> u2.user_id <span class="cf">ELSE</span> u1.user_id <span class="cf">END</span> <span class="kw">AS</span> user2_id,</span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a>        u1.<span class="dt">day</span>,</span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true" tabindex="-1"></a>        <span class="fu">COUNT</span>(<span class="kw">DISTINCT</span> u1.song_id) <span class="kw">AS</span> song_count</span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb26-18"><a href="#cb26-18" aria-hidden="true" tabindex="-1"></a>        user_song_days u1</span>
<span id="cb26-19"><a href="#cb26-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">JOIN</span> </span>
<span id="cb26-20"><a href="#cb26-20" aria-hidden="true" tabindex="-1"></a>        user_song_days u2 <span class="kw">ON</span> u1.song_id <span class="op">=</span> u2.song_id <span class="kw">AND</span> u1.<span class="dt">day</span> <span class="op">=</span> u2.<span class="dt">day</span></span>
<span id="cb26-21"><a href="#cb26-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">WHERE</span> </span>
<span id="cb26-22"><a href="#cb26-22" aria-hidden="true" tabindex="-1"></a>        u1.user_id <span class="op">&lt;&gt;</span> u2.user_id</span>
<span id="cb26-23"><a href="#cb26-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">GROUP</span> <span class="kw">BY</span> </span>
<span id="cb26-24"><a href="#cb26-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">CASE</span> <span class="cf">WHEN</span> u1.user_id <span class="op">&lt;</span> u2.user_id <span class="cf">THEN</span> u1.user_id <span class="cf">ELSE</span> u2.user_id <span class="cf">END</span>,</span>
<span id="cb26-25"><a href="#cb26-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">CASE</span> <span class="cf">WHEN</span> u1.user_id <span class="op">&lt;</span> u2.user_id <span class="cf">THEN</span> u2.user_id <span class="cf">ELSE</span> u1.user_id <span class="cf">END</span>,</span>
<span id="cb26-26"><a href="#cb26-26" aria-hidden="true" tabindex="-1"></a>        u1.<span class="dt">day</span></span>
<span id="cb26-27"><a href="#cb26-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">HAVING</span> </span>
<span id="cb26-28"><a href="#cb26-28" aria-hidden="true" tabindex="-1"></a>        <span class="fu">COUNT</span>(<span class="kw">DISTINCT</span> u1.song_id) <span class="op">&gt;=</span> <span class="dv">3</span></span>
<span id="cb26-29"><a href="#cb26-29" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb26-30"><a href="#cb26-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-31"><a href="#cb26-31" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> </span>
<span id="cb26-32"><a href="#cb26-32" aria-hidden="true" tabindex="-1"></a>    cs.user1_id,</span>
<span id="cb26-33"><a href="#cb26-33" aria-hidden="true" tabindex="-1"></a>    cs.user2_id</span>
<span id="cb26-34"><a href="#cb26-34" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> </span>
<span id="cb26-35"><a href="#cb26-35" aria-hidden="true" tabindex="-1"></a>    common_songs cs</span>
<span id="cb26-36"><a href="#cb26-36" aria-hidden="true" tabindex="-1"></a><span class="kw">JOIN</span> </span>
<span id="cb26-37"><a href="#cb26-37" aria-hidden="true" tabindex="-1"></a>    Friendship f <span class="kw">ON</span> cs.user1_id <span class="op">=</span> f.user1_id <span class="kw">AND</span> cs.user2_id <span class="op">=</span> f.user2_id</span>
<span id="cb26-38"><a href="#cb26-38" aria-hidden="true" tabindex="-1"></a><span class="kw">GROUP</span> <span class="kw">BY</span> </span>
<span id="cb26-39"><a href="#cb26-39" aria-hidden="true" tabindex="-1"></a>    cs.user1_id, cs.user2_id;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Explanation:</strong></p>
<ul>
<li>This query identifies pairs of friends who are “similar” because they listened to at least 3 of the same songs on the same day.</li>
<li>The solution uses a two-step approach with Common Table Expressions (CTEs):
<ul>
<li>The first CTE, <code>user_song_days</code>, gets distinct user-song-day combinations to avoid counting duplicated listens.</li>
<li>The second CTE, <code>common_songs</code>, identifies pairs of users who listened to at least 3 of the same songs on the same day, ensuring user1_id &lt; user2_id for consistency.</li>
</ul></li>
<li>The CASE expressions in common_songs ensure that user pairs are ordered correctly (smaller ID first) to match the Friendship table’s convention.</li>
<li>The main query joins with the Friendship table to ensure we only include pairs who are actually friends.</li>
<li>The GROUP BY eliminates any potential duplicates if friends have multiple days with 3+ common songs.</li>
<li>Time complexity: O(n²) where n is the number of user-song-day combinations, due to the self-join operation.</li>
<li>Space complexity: O(n²) for the potential user pairs.</li>
<li>This solution correctly handles edge cases:
<ul>
<li>Users who listened to the same song multiple times on the same day (handled by DISTINCT in the first CTE)</li>
<li>The ordering of user IDs in the friendship relation (handled by the CASE expressions)</li>
</ul></li>
<li>For large datasets, indexes on user_id, song_id, and day in the Listens table would significantly improve join performance.</li>
<li>The DISTINCT keyword in COUNT(DISTINCT song_id) ensures each common song is counted only once.</li>
<li>This query efficiently builds on the previous problem (Leetcodify Friends Recommendations) but with the additional constraint that the users must be friends.</li>
<li>The approach avoids unnecessary data processing by joining with the Friendship table only after identifying user pairs with common songs.</li>
<li>The solution maintains the requirement that user1_id &lt; user2_id in the final results, matching the convention in the Friendship table.</li>
</ul>
</section>
<section id="first-and-last-call-on-the-same-day" class="level4">
<h4 class="anchored" data-anchor-id="first-and-last-call-on-the-same-day">1972. First and Last Call On the Same Day</h4>
<p><strong>Description:</strong></p>
<table class="caption-top table">
<caption>Calls</caption>
<colgroup>
<col style="width: 19%">
<col style="width: 13%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>caller_id recipient_id call_time</td>
<td>int int varchar</td>
</tr>
</tbody>
</table>
<p>(caller_id, recipient_id, call_time) is the primary key for this table. Each row contains information about a call made between a caller_id and a recipient_id at call_time. call_time is of the format ‘HH:MM:SS’.</p>
<p>Write an SQL query to report the IDs of the users whose first and last calls on any day were with the same person. Calls are counted regardless of being the caller or the recipient.</p>
<p>Return the result table in any order.</p>
<p><strong>Solution:</strong></p>
<div class="sourceCode" id="cb27"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">WITH</span> normalized_calls <span class="kw">AS</span> (</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Normalize the calls to handle both caller and recipient perspectives</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>        caller_id <span class="kw">AS</span> user_id, </span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>        recipient_id <span class="kw">AS</span> other_id, </span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>        <span class="fu">CAST</span>(call_time <span class="kw">AS</span> <span class="dt">TIME</span>) <span class="kw">AS</span> call_time,</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>        DATE_TRUNC(<span class="st">'day'</span>, <span class="fu">TO_TIMESTAMP</span>(call_time, <span class="st">'HH24:MI:SS'</span>)) <span class="kw">AS</span> call_date</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>        Calls</span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">UNION</span> <span class="kw">ALL</span></span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a>        recipient_id <span class="kw">AS</span> user_id, </span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a>        caller_id <span class="kw">AS</span> other_id, </span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true" tabindex="-1"></a>        <span class="fu">CAST</span>(call_time <span class="kw">AS</span> <span class="dt">TIME</span>) <span class="kw">AS</span> call_time,</span>
<span id="cb27-17"><a href="#cb27-17" aria-hidden="true" tabindex="-1"></a>        DATE_TRUNC(<span class="st">'day'</span>, <span class="fu">TO_TIMESTAMP</span>(call_time, <span class="st">'HH24:MI:SS'</span>)) <span class="kw">AS</span> call_date</span>
<span id="cb27-18"><a href="#cb27-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb27-19"><a href="#cb27-19" aria-hidden="true" tabindex="-1"></a>        Calls</span>
<span id="cb27-20"><a href="#cb27-20" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb27-21"><a href="#cb27-21" aria-hidden="true" tabindex="-1"></a>daily_extremes <span class="kw">AS</span> (</span>
<span id="cb27-22"><a href="#cb27-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Find first and last call for each user on each day</span></span>
<span id="cb27-23"><a href="#cb27-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb27-24"><a href="#cb27-24" aria-hidden="true" tabindex="-1"></a>        user_id,</span>
<span id="cb27-25"><a href="#cb27-25" aria-hidden="true" tabindex="-1"></a>        call_date,</span>
<span id="cb27-26"><a href="#cb27-26" aria-hidden="true" tabindex="-1"></a>        <span class="fu">FIRST_VALUE</span>(other_id) <span class="kw">OVER</span> (</span>
<span id="cb27-27"><a href="#cb27-27" aria-hidden="true" tabindex="-1"></a>            <span class="kw">PARTITION</span> <span class="kw">BY</span> user_id, call_date </span>
<span id="cb27-28"><a href="#cb27-28" aria-hidden="true" tabindex="-1"></a>            <span class="kw">ORDER</span> <span class="kw">BY</span> call_time</span>
<span id="cb27-29"><a href="#cb27-29" aria-hidden="true" tabindex="-1"></a>            <span class="kw">ROWS</span> <span class="kw">BETWEEN</span> <span class="kw">UNBOUNDED</span> <span class="kw">PRECEDING</span> <span class="kw">AND</span> <span class="kw">UNBOUNDED</span> <span class="kw">FOLLOWING</span></span>
<span id="cb27-30"><a href="#cb27-30" aria-hidden="true" tabindex="-1"></a>        ) <span class="kw">AS</span> first_call_id,</span>
<span id="cb27-31"><a href="#cb27-31" aria-hidden="true" tabindex="-1"></a>        <span class="fu">LAST_VALUE</span>(other_id) <span class="kw">OVER</span> (</span>
<span id="cb27-32"><a href="#cb27-32" aria-hidden="true" tabindex="-1"></a>            <span class="kw">PARTITION</span> <span class="kw">BY</span> user_id, call_date </span>
<span id="cb27-33"><a href="#cb27-33" aria-hidden="true" tabindex="-1"></a>            <span class="kw">ORDER</span> <span class="kw">BY</span> call_time</span>
<span id="cb27-34"><a href="#cb27-34" aria-hidden="true" tabindex="-1"></a>            <span class="kw">ROWS</span> <span class="kw">BETWEEN</span> <span class="kw">UNBOUNDED</span> <span class="kw">PRECEDING</span> <span class="kw">AND</span> <span class="kw">UNBOUNDED</span> <span class="kw">FOLLOWING</span></span>
<span id="cb27-35"><a href="#cb27-35" aria-hidden="true" tabindex="-1"></a>        ) <span class="kw">AS</span> last_call_id</span>
<span id="cb27-36"><a href="#cb27-36" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb27-37"><a href="#cb27-37" aria-hidden="true" tabindex="-1"></a>        normalized_calls</span>
<span id="cb27-38"><a href="#cb27-38" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb27-39"><a href="#cb27-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-40"><a href="#cb27-40" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> <span class="kw">DISTINCT</span></span>
<span id="cb27-41"><a href="#cb27-41" aria-hidden="true" tabindex="-1"></a>    user_id</span>
<span id="cb27-42"><a href="#cb27-42" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> </span>
<span id="cb27-43"><a href="#cb27-43" aria-hidden="true" tabindex="-1"></a>    daily_extremes</span>
<span id="cb27-44"><a href="#cb27-44" aria-hidden="true" tabindex="-1"></a><span class="kw">WHERE</span> </span>
<span id="cb27-45"><a href="#cb27-45" aria-hidden="true" tabindex="-1"></a>    first_call_id <span class="op">=</span> last_call_id</span>
<span id="cb27-46"><a href="#cb27-46" aria-hidden="true" tabindex="-1"></a><span class="kw">GROUP</span> <span class="kw">BY</span> </span>
<span id="cb27-47"><a href="#cb27-47" aria-hidden="true" tabindex="-1"></a>    user_id;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Explanation:</strong></p>
<ul>
<li>This query identifies users whose first and last calls on any day were with the same person, regardless of who initiated the call.</li>
<li>The solution uses a two-step approach with Common Table Expressions (CTEs):
<ul>
<li>The first CTE, <code>normalized_calls</code>, flattens the call data to consider both perspectives (caller and recipient).</li>
<li>The second CTE, <code>daily_extremes</code>, uses window functions to identify the first and last call for each user on each day.</li>
</ul></li>
<li>The UNION ALL in normalized_calls ensures each call is represented from both users’ perspectives.</li>
<li>CAST and DATE_TRUNC functions handle the time and date components of call_time.</li>
<li>FIRST_VALUE and LAST_VALUE window functions efficiently identify the first and last call within each day.</li>
<li>The ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING frame ensures the entire partition is considered.</li>
<li>The main query filters for users where first_call_id equals last_call_id.</li>
<li>Time complexity: O(n log n) where n is the number of calls, due to the sorting operations in the window functions.</li>
<li>Space complexity: O(n) for the normalized calls.</li>
<li>This solution correctly handles edge cases:
<ul>
<li>Users who made only one call on a day (first and last are the same)</li>
<li>Users who called the same person multiple times</li>
<li>Users who had calls across multiple days</li>
</ul></li>
<li>For large datasets, indexes on caller_id, recipient_id, and call_time would improve performance.</li>
<li>The DISTINCT keyword in the final selection ensures each user is reported only once, even if they had matching first/last calls on multiple days.</li>
<li>The solution elegantly handles the bidirectional nature of calls without complex self-joins.</li>
<li>TO_TIMESTAMP with the format string ‘HH24:MI:SS’ properly parses the time strings in PostgreSQL.</li>
<li>Alternative approaches might use MIN and MAX functions, but the window functions provide a more elegant solution.</li>
</ul>
</section>
<section id="the-number-of-seniors-and-juniors-to-join-the-company" class="level4">
<h4 class="anchored" data-anchor-id="the-number-of-seniors-and-juniors-to-join-the-company">2004. The Number of Seniors and Juniors to Join the Company</h4>
<p><strong>Description:</strong></p>
<table class="caption-top table">
<caption>Candidates</caption>
<colgroup>
<col style="width: 19%">
<col style="width: 9%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>employee_id experience salary</td>
<td>int enum int</td>
</tr>
</tbody>
</table>
<p>employee_id is the primary key column for this table. experience is an enum with one of the values (‘Senior’, ‘Junior’). Each row of this table indicates the id of a candidate, their experience, and their salary.</p>
<p>A company wants to hire new employees. The budget of the company for the salaries is $70000. The company’s hiring criteria are:</p>
<ol type="1">
<li>Keep hiring the senior with the smallest salary until you cannot hire any more seniors.</li>
<li>Use the remaining budget to hire the junior with the smallest salary.</li>
<li>Keep hiring the junior with the smallest salary until you cannot hire any more juniors.</li>
</ol>
<p>Write an SQL query to find the employee_id of the seniors and juniors who will be hired.</p>
<p>Return the result table in any order.</p>
<p><strong>Solution:</strong></p>
<div class="sourceCode" id="cb28"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">WITH</span> senior_budgeting <span class="kw">AS</span> (</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>        employee_id,</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>        experience,</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>        salary,</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>        <span class="fu">SUM</span>(salary) <span class="kw">OVER</span> (</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>            <span class="kw">PARTITION</span> <span class="kw">BY</span> experience </span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>            <span class="kw">ORDER</span> <span class="kw">BY</span> salary, employee_id</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>            <span class="kw">ROWS</span> <span class="kw">BETWEEN</span> <span class="kw">UNBOUNDED</span> <span class="kw">PRECEDING</span> <span class="kw">AND</span> <span class="kw">CURRENT</span> <span class="kw">ROW</span></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>        ) <span class="kw">AS</span> running_total</span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a>        Candidates</span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">WHERE</span> </span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a>        experience <span class="op">=</span> <span class="st">'Senior'</span></span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a>junior_budgeting <span class="kw">AS</span> (</span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true" tabindex="-1"></a>        employee_id,</span>
<span id="cb28-19"><a href="#cb28-19" aria-hidden="true" tabindex="-1"></a>        experience,</span>
<span id="cb28-20"><a href="#cb28-20" aria-hidden="true" tabindex="-1"></a>        salary,</span>
<span id="cb28-21"><a href="#cb28-21" aria-hidden="true" tabindex="-1"></a>        <span class="fu">SUM</span>(salary) <span class="kw">OVER</span> (</span>
<span id="cb28-22"><a href="#cb28-22" aria-hidden="true" tabindex="-1"></a>            <span class="kw">PARTITION</span> <span class="kw">BY</span> experience </span>
<span id="cb28-23"><a href="#cb28-23" aria-hidden="true" tabindex="-1"></a>            <span class="kw">ORDER</span> <span class="kw">BY</span> salary, employee_id</span>
<span id="cb28-24"><a href="#cb28-24" aria-hidden="true" tabindex="-1"></a>            <span class="kw">ROWS</span> <span class="kw">BETWEEN</span> <span class="kw">UNBOUNDED</span> <span class="kw">PRECEDING</span> <span class="kw">AND</span> <span class="kw">CURRENT</span> <span class="kw">ROW</span></span>
<span id="cb28-25"><a href="#cb28-25" aria-hidden="true" tabindex="-1"></a>        ) <span class="kw">AS</span> running_total</span>
<span id="cb28-26"><a href="#cb28-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb28-27"><a href="#cb28-27" aria-hidden="true" tabindex="-1"></a>        Candidates</span>
<span id="cb28-28"><a href="#cb28-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">WHERE</span> </span>
<span id="cb28-29"><a href="#cb28-29" aria-hidden="true" tabindex="-1"></a>        experience <span class="op">=</span> <span class="st">'Junior'</span></span>
<span id="cb28-30"><a href="#cb28-30" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb28-31"><a href="#cb28-31" aria-hidden="true" tabindex="-1"></a>senior_hired <span class="kw">AS</span> (</span>
<span id="cb28-32"><a href="#cb28-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb28-33"><a href="#cb28-33" aria-hidden="true" tabindex="-1"></a>        employee_id, </span>
<span id="cb28-34"><a href="#cb28-34" aria-hidden="true" tabindex="-1"></a>        salary,</span>
<span id="cb28-35"><a href="#cb28-35" aria-hidden="true" tabindex="-1"></a>        running_total</span>
<span id="cb28-36"><a href="#cb28-36" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb28-37"><a href="#cb28-37" aria-hidden="true" tabindex="-1"></a>        senior_budgeting</span>
<span id="cb28-38"><a href="#cb28-38" aria-hidden="true" tabindex="-1"></a>    <span class="kw">WHERE</span> </span>
<span id="cb28-39"><a href="#cb28-39" aria-hidden="true" tabindex="-1"></a>        running_total <span class="op">&lt;=</span> <span class="dv">70000</span></span>
<span id="cb28-40"><a href="#cb28-40" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb28-41"><a href="#cb28-41" aria-hidden="true" tabindex="-1"></a>senior_budget_used <span class="kw">AS</span> (</span>
<span id="cb28-42"><a href="#cb28-42" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> <span class="fu">COALESCE</span>(<span class="fu">MAX</span>(running_total), <span class="dv">0</span>) <span class="kw">AS</span> used</span>
<span id="cb28-43"><a href="#cb28-43" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> senior_hired</span>
<span id="cb28-44"><a href="#cb28-44" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb28-45"><a href="#cb28-45" aria-hidden="true" tabindex="-1"></a>junior_hired <span class="kw">AS</span> (</span>
<span id="cb28-46"><a href="#cb28-46" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb28-47"><a href="#cb28-47" aria-hidden="true" tabindex="-1"></a>        jb.employee_id,</span>
<span id="cb28-48"><a href="#cb28-48" aria-hidden="true" tabindex="-1"></a>        jb.salary</span>
<span id="cb28-49"><a href="#cb28-49" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb28-50"><a href="#cb28-50" aria-hidden="true" tabindex="-1"></a>        junior_budgeting jb,</span>
<span id="cb28-51"><a href="#cb28-51" aria-hidden="true" tabindex="-1"></a>        senior_budget_used sbu</span>
<span id="cb28-52"><a href="#cb28-52" aria-hidden="true" tabindex="-1"></a>    <span class="kw">WHERE</span> </span>
<span id="cb28-53"><a href="#cb28-53" aria-hidden="true" tabindex="-1"></a>        jb.running_total <span class="op">&lt;=</span> (<span class="dv">70000</span> <span class="op">-</span> sbu.used)</span>
<span id="cb28-54"><a href="#cb28-54" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb28-55"><a href="#cb28-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-56"><a href="#cb28-56" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> employee_id</span>
<span id="cb28-57"><a href="#cb28-57" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> senior_hired</span>
<span id="cb28-58"><a href="#cb28-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-59"><a href="#cb28-59" aria-hidden="true" tabindex="-1"></a><span class="kw">UNION</span> <span class="kw">ALL</span></span>
<span id="cb28-60"><a href="#cb28-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-61"><a href="#cb28-61" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> employee_id</span>
<span id="cb28-62"><a href="#cb28-62" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> junior_hired</span>
<span id="cb28-63"><a href="#cb28-63" aria-hidden="true" tabindex="-1"></a><span class="kw">ORDER</span> <span class="kw">BY</span> employee_id;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Explanation:</strong></p>
<ul>
<li>This query implements a hiring strategy based on experience and salary within a fixed budget of $70,000.</li>
<li>The solution uses a multi-step approach with Common Table Expressions (CTEs):
<ul>
<li>The first two CTEs, <code>senior_budgeting</code> and <code>junior_budgeting</code>, calculate running totals of salaries for seniors and juniors separately.</li>
<li>The third CTE, <code>senior_hired</code>, identifies seniors who can be hired within the budget.</li>
<li>The fourth CTE, <code>senior_budget_used</code>, calculates the total budget used for seniors.</li>
<li>The fifth CTE, <code>junior_hired</code>, identifies juniors who can be hired with the remaining budget.</li>
</ul></li>
<li>The SUM() OVER() window function with the ROWS frame creates a running total of salaries in order of increasing salary.</li>
<li>The WHERE clauses in senior_hired and junior_hired ensure we stay within the budget limits.</li>
<li>The final query combines hired seniors and juniors using UNION ALL.</li>
<li>Time complexity: O(n log n) where n is the number of candidates, due to the sorting operations.</li>
<li>Space complexity: O(n) for the intermediate results.</li>
<li>This solution correctly implements the hiring strategy:
<ul>
<li>Prioritizes seniors with smallest salaries</li>
<li>Uses remaining budget for juniors with smallest salaries</li>
<li>Handles the case where no seniors or no juniors are hired</li>
</ul></li>
<li>For large datasets, indexes on experience and salary would improve performance.</li>
<li>COALESCE(MAX(running_total), 0) handles the edge case where no seniors are hired.</li>
<li>The solution efficiently handles the budget allocation without complex recursive logic.</li>
<li>The ORDER BY within the window functions ensures ties in salary are broken by employee_id.</li>
<li>This approach directly translates the business rules into SQL operations.</li>
<li>The final ORDER BY ensures results are returned in employee_id order, though this is not required by the problem.</li>
</ul>
</section>
<section id="the-number-of-seniors-and-juniors-to-join-the-company-ii" class="level4">
<h4 class="anchored" data-anchor-id="the-number-of-seniors-and-juniors-to-join-the-company-ii">2010. The Number of Seniors and Juniors to Join the Company II</h4>
<p><strong>Description:</strong></p>
<table class="caption-top table">
<caption>Candidates</caption>
<colgroup>
<col style="width: 19%">
<col style="width: 9%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>employee_id experience salary</td>
<td>int enum int</td>
</tr>
</tbody>
</table>
<p>employee_id is the primary key column for this table. experience is an enum with one of the values (‘Senior’, ‘Junior’). Each row of this table indicates the id of a candidate, their experience, and their salary.</p>
<p>A company wants to hire new employees. The company’s maximum budget for salaries is $70000.</p>
<p>The company wants to first use the budget to hire the most senior employees. Then, if they still have budget left, they will start hiring the most junior employees. If they still have budget left, they will repeat this hiring process.</p>
<p>Write an SQL query to find the number of seniors and juniors the company can hire under the budget.</p>
<p>Return the result as a single row with 2 columns: senior_count representing the number of seniors the company can hire, and junior_count representing the number of juniors the company can hire.</p>
<p><strong>Solution:</strong></p>
<div class="sourceCode" id="cb29"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">WITH</span> senior_budgeting <span class="kw">AS</span> (</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>        employee_id,</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>        salary,</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>        <span class="fu">SUM</span>(salary) <span class="kw">OVER</span> (</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>            <span class="kw">ORDER</span> <span class="kw">BY</span> salary, employee_id</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>            <span class="kw">ROWS</span> <span class="kw">BETWEEN</span> <span class="kw">UNBOUNDED</span> <span class="kw">PRECEDING</span> <span class="kw">AND</span> <span class="kw">CURRENT</span> <span class="kw">ROW</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>        ) <span class="kw">AS</span> running_total</span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>        Candidates</span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">WHERE</span> </span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a>        experience <span class="op">=</span> <span class="st">'Senior'</span></span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true" tabindex="-1"></a>junior_budgeting <span class="kw">AS</span> (</span>
<span id="cb29-15"><a href="#cb29-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb29-16"><a href="#cb29-16" aria-hidden="true" tabindex="-1"></a>        employee_id,</span>
<span id="cb29-17"><a href="#cb29-17" aria-hidden="true" tabindex="-1"></a>        salary,</span>
<span id="cb29-18"><a href="#cb29-18" aria-hidden="true" tabindex="-1"></a>        <span class="fu">SUM</span>(salary) <span class="kw">OVER</span> (</span>
<span id="cb29-19"><a href="#cb29-19" aria-hidden="true" tabindex="-1"></a>            <span class="kw">ORDER</span> <span class="kw">BY</span> salary, employee_id</span>
<span id="cb29-20"><a href="#cb29-20" aria-hidden="true" tabindex="-1"></a>            <span class="kw">ROWS</span> <span class="kw">BETWEEN</span> <span class="kw">UNBOUNDED</span> <span class="kw">PRECEDING</span> <span class="kw">AND</span> <span class="kw">CURRENT</span> <span class="kw">ROW</span></span>
<span id="cb29-21"><a href="#cb29-21" aria-hidden="true" tabindex="-1"></a>        ) <span class="kw">AS</span> running_total</span>
<span id="cb29-22"><a href="#cb29-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb29-23"><a href="#cb29-23" aria-hidden="true" tabindex="-1"></a>        Candidates</span>
<span id="cb29-24"><a href="#cb29-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">WHERE</span> </span>
<span id="cb29-25"><a href="#cb29-25" aria-hidden="true" tabindex="-1"></a>        experience <span class="op">=</span> <span class="st">'Junior'</span></span>
<span id="cb29-26"><a href="#cb29-26" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb29-27"><a href="#cb29-27" aria-hidden="true" tabindex="-1"></a>senior_hires <span class="kw">AS</span> (</span>
<span id="cb29-28"><a href="#cb29-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb29-29"><a href="#cb29-29" aria-hidden="true" tabindex="-1"></a>        <span class="fu">COUNT</span>(<span class="op">*</span>) <span class="kw">AS</span> senior_count,</span>
<span id="cb29-30"><a href="#cb29-30" aria-hidden="true" tabindex="-1"></a>        <span class="fu">COALESCE</span>(<span class="fu">MAX</span>(running_total), <span class="dv">0</span>) <span class="kw">AS</span> senior_budget</span>
<span id="cb29-31"><a href="#cb29-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb29-32"><a href="#cb29-32" aria-hidden="true" tabindex="-1"></a>        senior_budgeting</span>
<span id="cb29-33"><a href="#cb29-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">WHERE</span> </span>
<span id="cb29-34"><a href="#cb29-34" aria-hidden="true" tabindex="-1"></a>        running_total <span class="op">&lt;=</span> <span class="dv">70000</span></span>
<span id="cb29-35"><a href="#cb29-35" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb29-36"><a href="#cb29-36" aria-hidden="true" tabindex="-1"></a>junior_hires <span class="kw">AS</span> (</span>
<span id="cb29-37"><a href="#cb29-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb29-38"><a href="#cb29-38" aria-hidden="true" tabindex="-1"></a>        <span class="fu">COUNT</span>(<span class="op">*</span>) <span class="kw">AS</span> junior_count</span>
<span id="cb29-39"><a href="#cb29-39" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb29-40"><a href="#cb29-40" aria-hidden="true" tabindex="-1"></a>        junior_budgeting jb, </span>
<span id="cb29-41"><a href="#cb29-41" aria-hidden="true" tabindex="-1"></a>        senior_hires sh</span>
<span id="cb29-42"><a href="#cb29-42" aria-hidden="true" tabindex="-1"></a>    <span class="kw">WHERE</span> </span>
<span id="cb29-43"><a href="#cb29-43" aria-hidden="true" tabindex="-1"></a>        jb.running_total <span class="op">&lt;=</span> (<span class="dv">70000</span> <span class="op">-</span> sh.senior_budget)</span>
<span id="cb29-44"><a href="#cb29-44" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb29-45"><a href="#cb29-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-46"><a href="#cb29-46" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> </span>
<span id="cb29-47"><a href="#cb29-47" aria-hidden="true" tabindex="-1"></a>    sh.senior_count,</span>
<span id="cb29-48"><a href="#cb29-48" aria-hidden="true" tabindex="-1"></a>    <span class="fu">COALESCE</span>(jh.junior_count, <span class="dv">0</span>) <span class="kw">AS</span> junior_count</span>
<span id="cb29-49"><a href="#cb29-49" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> </span>
<span id="cb29-50"><a href="#cb29-50" aria-hidden="true" tabindex="-1"></a>    senior_hires sh</span>
<span id="cb29-51"><a href="#cb29-51" aria-hidden="true" tabindex="-1"></a><span class="kw">LEFT</span> <span class="kw">JOIN</span> </span>
<span id="cb29-52"><a href="#cb29-52" aria-hidden="true" tabindex="-1"></a>    junior_hires jh <span class="kw">ON</span> <span class="dv">1</span><span class="op">=</span><span class="dv">1</span>;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Explanation:</strong></p>
<ul>
<li>This query determines the maximum number of senior and junior employees that can be hired within a $70,000 budget, prioritizing seniors by salary.</li>
<li>The solution uses a four-step approach with Common Table Expressions (CTEs):
<ul>
<li>The first two CTEs, <code>senior_budgeting</code> and <code>junior_budgeting</code>, calculate running totals of salaries for each experience level.</li>
<li>The third CTE, <code>senior_hires</code>, counts how many seniors can be hired and calculates the total budget used.</li>
<li>The fourth CTE, <code>junior_hires</code>, counts how many juniors can be hired with the remaining budget.</li>
</ul></li>
<li>The SUM() OVER() window function creates running totals of salaries ordered by increasing salary.</li>
<li>The main query joins the senior_hires and junior_hires CTEs to produce the final counts.</li>
<li>Time complexity: O(n log n) where n is the number of candidates, due to the sorting operations.</li>
<li>Space complexity: O(n) for the intermediate results.</li>
<li>This solution correctly handles edge cases:
<ul>
<li>No seniors or no juniors in the candidate pool</li>
<li>Not enough budget to hire any candidates</li>
<li>Budget sufficient to hire all candidates</li>
</ul></li>
<li>For large datasets, indexes on experience and salary would improve performance.</li>
<li>COALESCE handles NULL values that might occur if no juniors can be hired.</li>
<li>The LEFT JOIN ensures the query returns a result even if no juniors can be hired.</li>
<li>The ORDER BY within the window functions ensures ties in salary are broken by employee_id.</li>
<li>The solution efficiently implements the hiring strategy without complex recursive logic.</li>
<li>The approach directly models the business requirements in SQL operations.</li>
<li>The condition “1=1” in the LEFT JOIN is a PostgreSQL technique to create a cross join with a LEFT JOIN syntax.</li>
</ul>
</section>
<section id="build-the-equation" class="level4">
<h4 class="anchored" data-anchor-id="build-the-equation">2118. Build the Equation</h4>
<p><strong>Description:</strong></p>
<table class="caption-top table">
<caption>Terms</caption>
<colgroup>
<col style="width: 19%">
<col style="width: 9%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>power factor</td>
<td>int int</td>
</tr>
</tbody>
</table>
<p>power is the primary key column for this table. Each row of this table contains information about one term of the equation. power is an integer in the range [0, 100]. factor is an integer in the range [-100, 100] and cannot be zero.</p>
<p>You have a very powerful program that can solve any equation of one variable in the world. The equation passed to the program must be formatted as follows:</p>
<ul>
<li>The left-hand side (LHS) should contain all the terms.</li>
<li>The right-hand side (RHS) should be zero.</li>
<li>Each term of the LHS should follow the format “<sign><factor>X^<power>” where:
<ul>
<li><sign> is either “+” or “-”.</sign></li>
<li><factor> is the absolute value of the factor.</factor></li>
<li>X is the uppercase letter “X”.</li>
<li><power> is the value of the power.</power></li>
</ul></power></factor></sign></li>
<li>If the power is 0, do not include “^<power>”.</power></li>
<li>If the power is 1, include “X” but do not include “^<power>”.</power></li>
<li>Terms must be sorted by the value of the power in descending order.</li>
<li>There should be no leading “+” sign for the first term.</li>
<li>There should be a single space between “+” or “-” and the term.</li>
<li>There should be no extra spaces.</li>
</ul>
<p>Write an SQL query to build the equation.</p>
<p><strong>Solution:</strong></p>
<div class="sourceCode" id="cb30"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">WITH</span> ordered_terms <span class="kw">AS</span> (</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>        <span class="fu">power</span>,</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>        factor,</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">CASE</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">WHEN</span> <span class="fu">power</span> <span class="op">=</span> <span class="dv">0</span> <span class="cf">THEN</span> <span class="st">''</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">WHEN</span> <span class="fu">power</span> <span class="op">=</span> <span class="dv">1</span> <span class="cf">THEN</span> <span class="st">'X'</span></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">ELSE</span> <span class="fu">CONCAT</span>(<span class="st">'X^'</span>, <span class="fu">power</span>)</span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">END</span> <span class="kw">AS</span> power_string,</span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>        <span class="fu">ROW_NUMBER</span>() <span class="kw">OVER</span> (<span class="kw">ORDER</span> <span class="kw">BY</span> <span class="fu">power</span> <span class="kw">DESC</span>) <span class="kw">AS</span> term_order</span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a>        Terms</span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> </span>
<span id="cb30-16"><a href="#cb30-16" aria-hidden="true" tabindex="-1"></a>    <span class="fu">CONCAT</span>(</span>
<span id="cb30-17"><a href="#cb30-17" aria-hidden="true" tabindex="-1"></a>        STRING_AGG(</span>
<span id="cb30-18"><a href="#cb30-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">CASE</span> </span>
<span id="cb30-19"><a href="#cb30-19" aria-hidden="true" tabindex="-1"></a>                <span class="cf">WHEN</span> term_order <span class="op">=</span> <span class="dv">1</span> <span class="cf">THEN</span></span>
<span id="cb30-20"><a href="#cb30-20" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">CASE</span> </span>
<span id="cb30-21"><a href="#cb30-21" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">WHEN</span> factor <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">THEN</span> <span class="fu">CONCAT</span>(factor, power_string)</span>
<span id="cb30-22"><a href="#cb30-22" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">ELSE</span> <span class="fu">CONCAT</span>(<span class="st">'-'</span>, <span class="fu">ABS</span>(factor), power_string)</span>
<span id="cb30-23"><a href="#cb30-23" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">END</span></span>
<span id="cb30-24"><a href="#cb30-24" aria-hidden="true" tabindex="-1"></a>                <span class="cf">ELSE</span></span>
<span id="cb30-25"><a href="#cb30-25" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">CASE</span> </span>
<span id="cb30-26"><a href="#cb30-26" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">WHEN</span> factor <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">THEN</span> <span class="fu">CONCAT</span>(<span class="st">'+ '</span>, factor, power_string)</span>
<span id="cb30-27"><a href="#cb30-27" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">ELSE</span> <span class="fu">CONCAT</span>(<span class="st">'- '</span>, <span class="fu">ABS</span>(factor), power_string)</span>
<span id="cb30-28"><a href="#cb30-28" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">END</span></span>
<span id="cb30-29"><a href="#cb30-29" aria-hidden="true" tabindex="-1"></a>            <span class="cf">END</span>,</span>
<span id="cb30-30"><a href="#cb30-30" aria-hidden="true" tabindex="-1"></a>            <span class="st">' '</span></span>
<span id="cb30-31"><a href="#cb30-31" aria-hidden="true" tabindex="-1"></a>        ),</span>
<span id="cb30-32"><a href="#cb30-32" aria-hidden="true" tabindex="-1"></a>        <span class="st">' = 0'</span></span>
<span id="cb30-33"><a href="#cb30-33" aria-hidden="true" tabindex="-1"></a>    ) <span class="kw">AS</span> equation</span>
<span id="cb30-34"><a href="#cb30-34" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> </span>
<span id="cb30-35"><a href="#cb30-35" aria-hidden="true" tabindex="-1"></a>    ordered_terms;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Explanation:</strong></p>
<ul>
<li>This query builds a mathematical equation from terms stored in a table, following specific formatting rules.</li>
<li>The solution uses a Common Table Expression (CTE) approach:
<ul>
<li>The <code>ordered_terms</code> CTE processes each term to generate the proper power notation and orders them by power descending.</li>
<li>CASE expressions handle special cases for powers of 0 (no “X” term) and 1 (just “X” without exponent).</li>
<li>ROW_NUMBER() identifies the first term, which has special formatting (no leading sign).</li>
</ul></li>
<li>The main query uses STRING_AGG to concatenate all terms with proper spacing and signs.</li>
<li>For the first term, we simply use the factor value (or its negation) without a leading “+” sign.</li>
<li>For subsequent terms, we add either “+” or “-” before the factor value.</li>
<li>The ABS() function ensures we only show the absolute value of the factor, handling the sign separately.</li>
<li>Finally, we append ” = 0” to complete the equation as required.</li>
<li>Time complexity: O(n log n) where n is the number of terms, due to the sorting operation.</li>
<li>Space complexity: O(n) for the intermediate expressions and final equation.</li>
<li>This solution correctly handles all the formatting requirements:
<ul>
<li>Descending order of powers</li>
<li>Special cases for powers of 0 and 1</li>
<li>Proper sign handling with spacing</li>
<li>No leading “+” for the first term</li>
</ul></li>
<li>For large datasets, an index on the power column would improve performance.</li>
<li>STRING_AGG is a PostgreSQL function that elegantly handles the concatenation with separator.</li>
<li>The approach directly translates the mathematical notation rules into SQL string manipulation.</li>
<li>The solution works for the full range of valid inputs (powers 0-100, factors -100 to 100 except 0).</li>
<li>Nested CASE expressions provide a clean way to handle the multiple conditional formatting rules.</li>
</ul>
</section>
<section id="the-number-of-passengers-in-each-bus-ii" class="level4">
<h4 class="anchored" data-anchor-id="the-number-of-passengers-in-each-bus-ii">2153. The Number of Passengers in Each Bus II</h4>
<p><strong>Description:</strong></p>
<table class="caption-top table">
<caption>Buses</caption>
<colgroup>
<col style="width: 20%">
<col style="width: 9%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>bus_id arrival_time capacity</td>
<td>int int int</td>
</tr>
</tbody>
</table>
<p>bus_id is the primary key column for this table. Each row of this table contains information about the arrival time of a bus at the LeetCode station and its capacity. No two buses will arrive at the same time.</p>
<table class="caption-top table">
<caption>Passengers</caption>
<colgroup>
<col style="width: 20%">
<col style="width: 9%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>passenger_id arrival_time</td>
<td>int int</td>
</tr>
</tbody>
</table>
<p>passenger_id is the primary key column for this table. Each row of this table contains information about the arrival time of a passenger at the LeetCode station.</p>
<p>Buses and passengers arrive at the LeetCode station. If a bus arrives at the station at time tbus and a passenger arrived at time tpassenger where tpassenger &lt;= tbus, the passenger will take the bus only if the passenger did not take any other bus before that.</p>
<p>Write an SQL query to report the number of passengers that took each bus. Return the result table ordered by bus_id in ascending order.</p>
<p><strong>Solution:</strong></p>
<div class="sourceCode" id="cb31"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="kw">WITH</span> ordered_buses <span class="kw">AS</span> (</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>        bus_id,</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>        arrival_time,</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>        capacity,</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>        <span class="fu">LAG</span>(arrival_time, <span class="dv">1</span>, <span class="dv">0</span>) <span class="kw">OVER</span> (<span class="kw">ORDER</span> <span class="kw">BY</span> arrival_time) <span class="kw">AS</span> prev_arrival_time,</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>        <span class="fu">ROW_NUMBER</span>() <span class="kw">OVER</span> (<span class="kw">ORDER</span> <span class="kw">BY</span> arrival_time) <span class="kw">AS</span> bus_order</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>        Buses</span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>eligible_passengers <span class="kw">AS</span> (</span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a>        p.passenger_id,</span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a>        p.arrival_time,</span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a>        <span class="fu">MIN</span>(b.bus_order) <span class="kw">OVER</span> (<span class="kw">PARTITION</span> <span class="kw">BY</span> p.passenger_id) <span class="kw">AS</span> first_available_bus</span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb31-17"><a href="#cb31-17" aria-hidden="true" tabindex="-1"></a>        Passengers p</span>
<span id="cb31-18"><a href="#cb31-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">JOIN</span> </span>
<span id="cb31-19"><a href="#cb31-19" aria-hidden="true" tabindex="-1"></a>        ordered_buses b <span class="kw">ON</span> p.arrival_time <span class="op">&lt;=</span> b.arrival_time</span>
<span id="cb31-20"><a href="#cb31-20" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb31-21"><a href="#cb31-21" aria-hidden="true" tabindex="-1"></a>passengers_per_bus <span class="kw">AS</span> (</span>
<span id="cb31-22"><a href="#cb31-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb31-23"><a href="#cb31-23" aria-hidden="true" tabindex="-1"></a>        ob.bus_id,</span>
<span id="cb31-24"><a href="#cb31-24" aria-hidden="true" tabindex="-1"></a>        ob.bus_order,</span>
<span id="cb31-25"><a href="#cb31-25" aria-hidden="true" tabindex="-1"></a>        ob.capacity,</span>
<span id="cb31-26"><a href="#cb31-26" aria-hidden="true" tabindex="-1"></a>        (</span>
<span id="cb31-27"><a href="#cb31-27" aria-hidden="true" tabindex="-1"></a>            <span class="kw">SELECT</span> <span class="fu">COUNT</span>(<span class="op">*</span>) </span>
<span id="cb31-28"><a href="#cb31-28" aria-hidden="true" tabindex="-1"></a>            <span class="kw">FROM</span> eligible_passengers ep</span>
<span id="cb31-29"><a href="#cb31-29" aria-hidden="true" tabindex="-1"></a>            <span class="kw">WHERE</span> ep.first_available_bus <span class="op">=</span> ob.bus_order</span>
<span id="cb31-30"><a href="#cb31-30" aria-hidden="true" tabindex="-1"></a>        ) <span class="kw">AS</span> raw_passengers</span>
<span id="cb31-31"><a href="#cb31-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb31-32"><a href="#cb31-32" aria-hidden="true" tabindex="-1"></a>        ordered_buses ob</span>
<span id="cb31-33"><a href="#cb31-33" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb31-34"><a href="#cb31-34" aria-hidden="true" tabindex="-1"></a>bus_allocation <span class="kw">AS</span> (</span>
<span id="cb31-35"><a href="#cb31-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb31-36"><a href="#cb31-36" aria-hidden="true" tabindex="-1"></a>        bus_id,</span>
<span id="cb31-37"><a href="#cb31-37" aria-hidden="true" tabindex="-1"></a>        bus_order,</span>
<span id="cb31-38"><a href="#cb31-38" aria-hidden="true" tabindex="-1"></a>        capacity,</span>
<span id="cb31-39"><a href="#cb31-39" aria-hidden="true" tabindex="-1"></a>        raw_passengers,</span>
<span id="cb31-40"><a href="#cb31-40" aria-hidden="true" tabindex="-1"></a>        <span class="fu">SUM</span>(raw_passengers) <span class="kw">OVER</span> (<span class="kw">ORDER</span> <span class="kw">BY</span> bus_order) <span class="kw">AS</span> cumulative_passengers,</span>
<span id="cb31-41"><a href="#cb31-41" aria-hidden="true" tabindex="-1"></a>        <span class="fu">SUM</span>(capacity) <span class="kw">OVER</span> (<span class="kw">ORDER</span> <span class="kw">BY</span> bus_order) <span class="kw">AS</span> cumulative_capacity</span>
<span id="cb31-42"><a href="#cb31-42" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb31-43"><a href="#cb31-43" aria-hidden="true" tabindex="-1"></a>        passengers_per_bus</span>
<span id="cb31-44"><a href="#cb31-44" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb31-45"><a href="#cb31-45" aria-hidden="true" tabindex="-1"></a>final_counts <span class="kw">AS</span> (</span>
<span id="cb31-46"><a href="#cb31-46" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb31-47"><a href="#cb31-47" aria-hidden="true" tabindex="-1"></a>        ba.bus_id,</span>
<span id="cb31-48"><a href="#cb31-48" aria-hidden="true" tabindex="-1"></a>        <span class="cf">CASE</span> </span>
<span id="cb31-49"><a href="#cb31-49" aria-hidden="true" tabindex="-1"></a>            <span class="cf">WHEN</span> ba.bus_order <span class="op">=</span> <span class="dv">1</span> <span class="cf">THEN</span> <span class="fu">LEAST</span>(ba.raw_passengers, ba.capacity)</span>
<span id="cb31-50"><a href="#cb31-50" aria-hidden="true" tabindex="-1"></a>            <span class="cf">ELSE</span> <span class="fu">LEAST</span>(</span>
<span id="cb31-51"><a href="#cb31-51" aria-hidden="true" tabindex="-1"></a>                ba.raw_passengers,</span>
<span id="cb31-52"><a href="#cb31-52" aria-hidden="true" tabindex="-1"></a>                ba.capacity <span class="op">-</span> <span class="fu">GREATEST</span>(<span class="dv">0</span>, prev_ba.cumulative_passengers <span class="op">-</span> prev_ba.cumulative_capacity)</span>
<span id="cb31-53"><a href="#cb31-53" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb31-54"><a href="#cb31-54" aria-hidden="true" tabindex="-1"></a>        <span class="cf">END</span> <span class="kw">AS</span> passengers_count</span>
<span id="cb31-55"><a href="#cb31-55" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb31-56"><a href="#cb31-56" aria-hidden="true" tabindex="-1"></a>        bus_allocation ba</span>
<span id="cb31-57"><a href="#cb31-57" aria-hidden="true" tabindex="-1"></a>    <span class="kw">LEFT</span> <span class="kw">JOIN</span> </span>
<span id="cb31-58"><a href="#cb31-58" aria-hidden="true" tabindex="-1"></a>        bus_allocation prev_ba <span class="kw">ON</span> ba.bus_order <span class="op">=</span> prev_ba.bus_order <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb31-59"><a href="#cb31-59" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb31-60"><a href="#cb31-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-61"><a href="#cb31-61" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> </span>
<span id="cb31-62"><a href="#cb31-62" aria-hidden="true" tabindex="-1"></a>    bus_id,</span>
<span id="cb31-63"><a href="#cb31-63" aria-hidden="true" tabindex="-1"></a>    passengers_count</span>
<span id="cb31-64"><a href="#cb31-64" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> </span>
<span id="cb31-65"><a href="#cb31-65" aria-hidden="true" tabindex="-1"></a>    final_counts</span>
<span id="cb31-66"><a href="#cb31-66" aria-hidden="true" tabindex="-1"></a><span class="kw">ORDER</span> <span class="kw">BY</span> </span>
<span id="cb31-67"><a href="#cb31-67" aria-hidden="true" tabindex="-1"></a>    bus_id;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Explanation:</strong></p>
<ul>
<li>This query calculates how many passengers can fit on each bus, considering capacity limits and the rule that passengers take the first available bus after their arrival.</li>
<li>The solution uses a multi-step approach with Common Table Expressions (CTEs):
<ul>
<li>The <code>ordered_buses</code> CTE arranges buses by arrival time and identifies the previous bus’s arrival time.</li>
<li>The <code>eligible_passengers</code> CTE matches passengers to their first available bus using window functions.</li>
<li>The <code>passengers_per_bus</code> CTE calculates how many passengers would initially be assigned to each bus.</li>
<li>The <code>bus_allocation</code> CTE tracks cumulative passengers and capacity to handle overflow.</li>
<li>The <code>final_counts</code> CTE adjusts passenger counts based on capacity constraints and overflow from previous buses.</li>
</ul></li>
<li>The LEAST function ensures no bus exceeds its capacity.</li>
<li>The combination of window functions and self-join handles the complex logic of passenger allocation across buses.</li>
<li>Time complexity: O((b+p) log (b+p)) where b is the number of buses and p is the number of passengers.</li>
<li>Space complexity: O(b+p) for the intermediate results.</li>
<li>This solution correctly handles edge cases:
<ul>
<li>Buses with excess capacity</li>
<li>Buses that cannot accommodate all waiting passengers</li>
<li>Overflows to subsequent buses</li>
</ul></li>
<li>For large datasets, indexes on arrival_time in both tables would improve join performance.</li>
<li>The approach efficiently models the “first available bus” requirement using window functions.</li>
<li>The LEFT JOIN in the final_counts CTE handles the first bus, which has no previous bus.</li>
<li>The solution carefully tracks both cumulative passengers and cumulative capacity to handle capacity constraints.</li>
<li>The GREATEST(0, …) function prevents negative overflow calculations if early buses have excess capacity.</li>
<li>The final ORDER BY ensures results are returned in bus_id order as required.</li>
</ul>
</section>
<section id="longest-winning-streak" class="level4">
<h4 class="anchored" data-anchor-id="longest-winning-streak">2173. Longest Winning Streak</h4>
<p><strong>Description:</strong></p>
<table class="caption-top table">
<caption>Matches</caption>
<colgroup>
<col style="width: 19%">
<col style="width: 9%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>player_id match_day result</td>
<td>int date enum</td>
</tr>
</tbody>
</table>
<p>(player_id, match_day) is the primary key for this table. Each row of this table contains the ID of a player, the day of the match they played, and the result of that match. The result column is an ENUM type of (‘Win’, ‘Draw’, ‘Lose’).</p>
<p>Write an SQL query to report the longest winning streak for each player. If there is a tie, report all of them.</p>
<p>A winning streak is a consecutive sequence of matches where a player wins. The streak ends once the player loses or has a draw.</p>
<p>Return the result table ordered by player_id.</p>
<p><strong>Solution:</strong></p>
<div class="sourceCode" id="cb32"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">WITH</span> match_groups <span class="kw">AS</span> (</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>        player_id,</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>        match_day,</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>        result,</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>        match_day <span class="op">-</span> <span class="fu">ROW_NUMBER</span>() <span class="kw">OVER</span> (</span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>            <span class="kw">PARTITION</span> <span class="kw">BY</span> player_id, result </span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>            <span class="kw">ORDER</span> <span class="kw">BY</span> match_day</span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>        ):<span class="ch">:integer</span> <span class="kw">AS</span> <span class="fu">group_id</span></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a>        Matches</span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">WHERE</span> </span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a>        result <span class="op">=</span> <span class="st">'Win'</span></span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb32-15"><a href="#cb32-15" aria-hidden="true" tabindex="-1"></a>streak_lengths <span class="kw">AS</span> (</span>
<span id="cb32-16"><a href="#cb32-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb32-17"><a href="#cb32-17" aria-hidden="true" tabindex="-1"></a>        player_id,</span>
<span id="cb32-18"><a href="#cb32-18" aria-hidden="true" tabindex="-1"></a>        <span class="fu">group_id</span>,</span>
<span id="cb32-19"><a href="#cb32-19" aria-hidden="true" tabindex="-1"></a>        <span class="fu">COUNT</span>(<span class="op">*</span>) <span class="kw">AS</span> streak_length</span>
<span id="cb32-20"><a href="#cb32-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb32-21"><a href="#cb32-21" aria-hidden="true" tabindex="-1"></a>        match_groups</span>
<span id="cb32-22"><a href="#cb32-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">GROUP</span> <span class="kw">BY</span> </span>
<span id="cb32-23"><a href="#cb32-23" aria-hidden="true" tabindex="-1"></a>        player_id, <span class="fu">group_id</span></span>
<span id="cb32-24"><a href="#cb32-24" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb32-25"><a href="#cb32-25" aria-hidden="true" tabindex="-1"></a>max_streaks <span class="kw">AS</span> (</span>
<span id="cb32-26"><a href="#cb32-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb32-27"><a href="#cb32-27" aria-hidden="true" tabindex="-1"></a>        player_id,</span>
<span id="cb32-28"><a href="#cb32-28" aria-hidden="true" tabindex="-1"></a>        <span class="fu">MAX</span>(streak_length) <span class="kw">AS</span> longest_streak</span>
<span id="cb32-29"><a href="#cb32-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb32-30"><a href="#cb32-30" aria-hidden="true" tabindex="-1"></a>        streak_lengths</span>
<span id="cb32-31"><a href="#cb32-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">GROUP</span> <span class="kw">BY</span> </span>
<span id="cb32-32"><a href="#cb32-32" aria-hidden="true" tabindex="-1"></a>        player_id</span>
<span id="cb32-33"><a href="#cb32-33" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb32-34"><a href="#cb32-34" aria-hidden="true" tabindex="-1"></a>all_players <span class="kw">AS</span> (</span>
<span id="cb32-35"><a href="#cb32-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> <span class="kw">DISTINCT</span> player_id</span>
<span id="cb32-36"><a href="#cb32-36" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> Matches</span>
<span id="cb32-37"><a href="#cb32-37" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb32-38"><a href="#cb32-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-39"><a href="#cb32-39" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> </span>
<span id="cb32-40"><a href="#cb32-40" aria-hidden="true" tabindex="-1"></a>    ap.player_id,</span>
<span id="cb32-41"><a href="#cb32-41" aria-hidden="true" tabindex="-1"></a>    <span class="fu">COALESCE</span>(ms.longest_streak, <span class="dv">0</span>) <span class="kw">AS</span> longest_streak</span>
<span id="cb32-42"><a href="#cb32-42" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> </span>
<span id="cb32-43"><a href="#cb32-43" aria-hidden="true" tabindex="-1"></a>    all_players ap</span>
<span id="cb32-44"><a href="#cb32-44" aria-hidden="true" tabindex="-1"></a><span class="kw">LEFT</span> <span class="kw">JOIN</span> </span>
<span id="cb32-45"><a href="#cb32-45" aria-hidden="true" tabindex="-1"></a>    max_streaks ms <span class="kw">ON</span> ap.player_id <span class="op">=</span> ms.player_id</span>
<span id="cb32-46"><a href="#cb32-46" aria-hidden="true" tabindex="-1"></a><span class="kw">ORDER</span> <span class="kw">BY</span> </span>
<span id="cb32-47"><a href="#cb32-47" aria-hidden="true" tabindex="-1"></a>    ap.player_id;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Explanation:</strong></p>
<ul>
<li>This query identifies each player’s longest winning streak (consecutive matches won).</li>
<li>The solution uses a four-step approach with Common Table Expressions (CTEs):
<ul>
<li>The <code>match_groups</code> CTE uses the “islands and gaps” technique to identify consecutive win sequences.</li>
<li>The <code>streak_lengths</code> CTE counts the length of each winning streak.</li>
<li>The <code>max_streaks</code> CTE finds the maximum streak length for each player.</li>
<li>The <code>all_players</code> CTE ensures all players are included in the results, even those without wins.</li>
</ul></li>
<li>The key insight is using “match_day - ROW_NUMBER()” to create a constant group_id for consecutive wins.</li>
<li>When dates are consecutive and only wins are included, this difference creates the same value for a streak.</li>
<li>The main query joins all_players with max_streaks to include players with no wins (who get a longest_streak of 0).</li>
<li>Time complexity: O(n log n) where n is the number of matches, due to the sorting operations.</li>
<li>Space complexity: O(n) for the intermediate results.</li>
<li>This solution correctly handles edge cases:
<ul>
<li>Players with no wins</li>
<li>Players with multiple winning streaks of the same length</li>
<li>Non-consecutive match days</li>
</ul></li>
<li>For large datasets, indexes on player_id and match_day would improve performance.</li>
<li>COALESCE ensures players without any wins show a longest_streak of 0 rather than NULL.</li>
<li>The WHERE clause in match_groups efficiently filters for wins only, simplifying the grouping logic.</li>
<li>The LEFT JOIN ensures all players appear in the results, regardless of their win record.</li>
<li>The approach elegantly handles the streak identification without complex self-joins or recursive queries.</li>
<li>The query follows the requirement to order results by player_id.</li>
<li>The ROW_NUMBER() window function partitions by both player_id and result to create proper groupings within each player’s wins.</li>
</ul>
</section>
<section id="finding-the-topic-of-each-post" class="level4">
<h4 class="anchored" data-anchor-id="finding-the-topic-of-each-post">2199. Finding the Topic of Each Post</h4>
<p><strong>Description:</strong></p>
<table class="caption-top table">
<caption>Keywords</caption>
<colgroup>
<col style="width: 19%">
<col style="width: 13%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>topic_id word</td>
<td>int varchar</td>
</tr>
</tbody>
</table>
<p>(topic_id, word) is the primary key for this table. Each row of this table contains the id of a topic and a word that belongs to that topic.</p>
<table class="caption-top table">
<caption>Posts</caption>
<colgroup>
<col style="width: 19%">
<col style="width: 13%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>post_id content</td>
<td>int varchar</td>
</tr>
</tbody>
</table>
<p>post_id is the primary key for this table. Each row of this table contains the ID of a post and its content.</p>
<p>The topics of a post are the topics that the post’s content belongs to. The topic of a content is detected by the following rules:</p>
<p>If the content contains the exact word from a keyword of a topic, then the content has the topic of that keyword. Same content can have multiple topics.</p>
<p>Write an SQL query to find the topics of each post according to the rules above. Return the result table ordered by post_id in ascending order. In case of a tie, order by topic_id in ascending order.</p>
<p>Note that:</p>
<ul>
<li>The word in the Keywords table is case-sensitive, and the content should match exactly the word in the Keywords table.</li>
<li>A string like “Leetcode” is not equal to “leetcode”.</li>
</ul>
<p><strong>Solution:</strong></p>
<div class="sourceCode" id="cb33"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">WITH</span> topic_matches <span class="kw">AS</span> (</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>        p.post_id,</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>        k.topic_id</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>        Posts p</span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">JOIN</span> </span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>        Keywords k <span class="kw">ON</span> p.content ~<span class="op">*</span> <span class="fu">CONCAT</span>(<span class="st">'</span><span class="ch">\\</span><span class="st">m'</span>, k.word, <span class="st">'</span><span class="ch">\\</span><span class="st">M'</span>)</span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">GROUP</span> <span class="kw">BY</span> </span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a>        p.post_id, k.topic_id</span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> </span>
<span id="cb33-14"><a href="#cb33-14" aria-hidden="true" tabindex="-1"></a>    post_id,</span>
<span id="cb33-15"><a href="#cb33-15" aria-hidden="true" tabindex="-1"></a>    <span class="fu">COALESCE</span>(</span>
<span id="cb33-16"><a href="#cb33-16" aria-hidden="true" tabindex="-1"></a>        (</span>
<span id="cb33-17"><a href="#cb33-17" aria-hidden="true" tabindex="-1"></a>            <span class="kw">SELECT</span> STRING_AGG(topic_id:<span class="ch">:text</span>, <span class="st">','</span>) </span>
<span id="cb33-18"><a href="#cb33-18" aria-hidden="true" tabindex="-1"></a>            <span class="kw">FROM</span> (</span>
<span id="cb33-19"><a href="#cb33-19" aria-hidden="true" tabindex="-1"></a>                <span class="kw">SELECT</span> topic_id </span>
<span id="cb33-20"><a href="#cb33-20" aria-hidden="true" tabindex="-1"></a>                <span class="kw">FROM</span> topic_matches tm </span>
<span id="cb33-21"><a href="#cb33-21" aria-hidden="true" tabindex="-1"></a>                <span class="kw">WHERE</span> tm.post_id <span class="op">=</span> p.post_id </span>
<span id="cb33-22"><a href="#cb33-22" aria-hidden="true" tabindex="-1"></a>                <span class="kw">ORDER</span> <span class="kw">BY</span> topic_id</span>
<span id="cb33-23"><a href="#cb33-23" aria-hidden="true" tabindex="-1"></a>            ) <span class="kw">AS</span> ordered_topics</span>
<span id="cb33-24"><a href="#cb33-24" aria-hidden="true" tabindex="-1"></a>        ),</span>
<span id="cb33-25"><a href="#cb33-25" aria-hidden="true" tabindex="-1"></a>        <span class="st">'Ambiguous!'</span></span>
<span id="cb33-26"><a href="#cb33-26" aria-hidden="true" tabindex="-1"></a>    ) <span class="kw">AS</span> topic</span>
<span id="cb33-27"><a href="#cb33-27" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> </span>
<span id="cb33-28"><a href="#cb33-28" aria-hidden="true" tabindex="-1"></a>    Posts p</span>
<span id="cb33-29"><a href="#cb33-29" aria-hidden="true" tabindex="-1"></a><span class="kw">ORDER</span> <span class="kw">BY</span> </span>
<span id="cb33-30"><a href="#cb33-30" aria-hidden="true" tabindex="-1"></a>    post_id;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Explanation:</strong></p>
<ul>
<li>This query identifies the topics of each post based on keyword matching, with special attention to exact word matches.</li>
<li>The solution uses a Common Table Expression (CTE) approach:
<ul>
<li>The <code>topic_matches</code> CTE finds all matches between posts and keywords using regular expression matching.</li>
<li>The PostgreSQL pattern <code>\\m</code> and <code>\\M</code> match word boundaries, ensuring exact word matches.</li>
</ul></li>
<li>The main query aggregates all matched topics for each post using STRING_AGG, ordering them by topic_id.</li>
<li>The COALESCE function handles posts with no matched topics, labeling them as ‘Ambiguous!’.</li>
<li>Time complexity: O(p × k) where p is the number of posts and k is the number of keywords.</li>
<li>Space complexity: O(p × k) in the worst case if all posts match all topics.</li>
<li>This solution correctly handles edge cases:
<ul>
<li>Posts matching multiple topics</li>
<li>Posts matching no topics</li>
<li>Case-sensitive matching requirements</li>
</ul></li>
<li>For large datasets, a full-text search index would significantly improve performance over regular expression matching.</li>
<li>The <code>~*</code> operator in PostgreSQL performs case-insensitive pattern matching.</li>
<li>The word boundary patterns <code>\\m</code> and <code>\\M</code> ensure only complete words are matched, not partial matches within larger words.</li>
<li>The GROUP BY in the topic_matches CTE ensures each post-topic pair is counted only once, even if a keyword appears multiple times.</li>
<li>STRING_AGG with proper ordering ensures consistent results for posts with multiple topics.</li>
<li>The subquery with ORDER BY inside STRING_AGG ensures topics are sorted before aggregation.</li>
<li>The final ORDER BY ensures results are returned in post_id order as required.</li>
</ul>
</section>
<section id="dynamic-pivoting-of-a-table" class="level4">
<h4 class="anchored" data-anchor-id="dynamic-pivoting-of-a-table">2252. Dynamic Pivoting of a Table</h4>
<p><strong>Description:</strong></p>
<table class="caption-top table">
<caption>Products</caption>
<colgroup>
<col style="width: 19%">
<col style="width: 13%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>product_id store price</td>
<td>int varchar int</td>
</tr>
</tbody>
</table>
<p>(product_id, store) is the primary key for this table. Each row of this table indicates the price of product_id in store.</p>
<p>Write an SQL query to pivot the table so that each row shows the product_id and a separate column for the price in each store. If the price is not available in a particular store, set the price to null.</p>
<p>Return the result table in any order.</p>
<p><strong>Solution:</strong></p>
<div class="sourceCode" id="cb34"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="kw">WITH</span> stores <span class="kw">AS</span> (</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> <span class="kw">DISTINCT</span> <span class="kw">store</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> Products</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">ORDER</span> <span class="kw">BY</span> <span class="kw">store</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>store_columns <span class="kw">AS</span> (</span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>        STRING_AGG(</span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>            FORMAT(<span class="st">'MAX(CASE WHEN store = </span><span class="ch">''</span><span class="st">%s</span><span class="ch">''</span><span class="st"> THEN price END) AS "%s"'</span>, <span class="kw">store</span>, <span class="kw">store</span>),</span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a>            <span class="st">', '</span></span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a>        ) <span class="kw">AS</span> store_columns</span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a>        stores</span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> format(<span class="st">'</span></span>
<span id="cb34-17"><a href="#cb34-17" aria-hidden="true" tabindex="-1"></a><span class="st">    SELECT </span></span>
<span id="cb34-18"><a href="#cb34-18" aria-hidden="true" tabindex="-1"></a><span class="st">        product_id, </span></span>
<span id="cb34-19"><a href="#cb34-19" aria-hidden="true" tabindex="-1"></a><span class="st">        %s</span></span>
<span id="cb34-20"><a href="#cb34-20" aria-hidden="true" tabindex="-1"></a><span class="st">    FROM </span></span>
<span id="cb34-21"><a href="#cb34-21" aria-hidden="true" tabindex="-1"></a><span class="st">        Products</span></span>
<span id="cb34-22"><a href="#cb34-22" aria-hidden="true" tabindex="-1"></a><span class="st">    GROUP BY </span></span>
<span id="cb34-23"><a href="#cb34-23" aria-hidden="true" tabindex="-1"></a><span class="st">        product_id</span></span>
<span id="cb34-24"><a href="#cb34-24" aria-hidden="true" tabindex="-1"></a><span class="st">'</span>, (<span class="kw">SELECT</span> store_columns <span class="kw">FROM</span> store_columns)) <span class="kw">AS</span> pivot_query;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Explanation:</strong></p>
<ul>
<li>This query dynamically generates a pivot table SQL statement based on the unique store values in the Products table.</li>
<li>The solution uses a two-step approach with Common Table Expressions (CTEs):
<ul>
<li>The <code>stores</code> CTE extracts all distinct store names, ordered alphabetically.</li>
<li>The <code>store_columns</code> CTE generates the dynamic column expressions for each store.</li>
</ul></li>
<li>The query uses STRING_AGG to concatenate all the CASE expressions that will form the pivot columns.</li>
<li>The FORMAT function creates properly quoted SQL statements with the store names.</li>
<li>The main query wraps everything in a template that includes the SELECT, FROM, and GROUP BY clauses.</li>
<li>Since PostgreSQL doesn’t have a direct PIVOT function like some other SQL dialects, this approach dynamically generates the pivot query.</li>
<li>Time complexity: O(n) where n is the number of unique stores.</li>
<li>Space complexity: O(n) for the generated query.</li>
<li>This solution has some important characteristics to note:
<ul>
<li>It doesn’t execute the pivot directly but generates the SQL that would perform the pivot.</li>
<li>The generated SQL would need to be executed separately to get the actual pivoted data.</li>
<li>This is a meta-programming approach to dynamic pivoting.</li>
</ul></li>
<li>For large datasets, indexes on product_id and store would improve the performance of the generated query.</li>
<li>The approach handles an arbitrary number of stores without hardcoding column names.</li>
<li>The CASE expressions in the generated query ensure NULL values for missing price data.</li>
<li>The GROUP BY in the generated query ensures each product appears once with all its store prices.</li>
<li>This solution is particularly useful for administrative tasks and reporting where the number of pivot columns might change over time.</li>
<li>An alternative would be to use PostgreSQL’s crosstab function from the tablefunc extension, but the generated SQL approach is more portable.</li>
<li>The double quotes around the column names in the generated SQL ensure proper identifier handling, especially for stores with spaces or special characters.</li>
</ul>
</section>
<section id="dynamic-unpivoting-of-a-table" class="level4">
<h4 class="anchored" data-anchor-id="dynamic-unpivoting-of-a-table">2253. Dynamic Unpivoting of a Table</h4>
<p><strong>Description:</strong></p>
<table class="caption-top table">
<caption>Products</caption>
<colgroup>
<col style="width: 19%">
<col style="width: 13%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>product_id store1 store2 store3</td>
<td>int int int int</td>
</tr>
</tbody>
</table>
<p>product_id is the primary key for this table. Each row in this table indicates the product’s price in 3 different stores: store1, store2, and store3. If the product is not available in a store, the price will be null in that store’s column.</p>
<p>Write an SQL query to rearrange the Products table so that each row has (product_id, store, price). If a product is not available in a store, do not include a row with that product_id and store combination in the result table.</p>
<p>Return the result table in any order.</p>
<p><strong>Solution:</strong></p>
<div class="sourceCode" id="cb35"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> </span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>    product_id,</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">'store1'</span> <span class="kw">AS</span> <span class="kw">store</span>,</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>    store1 <span class="kw">AS</span> price</span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> </span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>    Products</span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a><span class="kw">WHERE</span> </span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>    store1 <span class="kw">IS</span> <span class="kw">NOT</span> <span class="kw">NULL</span></span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a><span class="kw">UNION</span> <span class="kw">ALL</span></span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> </span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true" tabindex="-1"></a>    product_id,</span>
<span id="cb35-14"><a href="#cb35-14" aria-hidden="true" tabindex="-1"></a>    <span class="st">'store2'</span> <span class="kw">AS</span> <span class="kw">store</span>,</span>
<span id="cb35-15"><a href="#cb35-15" aria-hidden="true" tabindex="-1"></a>    store2 <span class="kw">AS</span> price</span>
<span id="cb35-16"><a href="#cb35-16" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> </span>
<span id="cb35-17"><a href="#cb35-17" aria-hidden="true" tabindex="-1"></a>    Products</span>
<span id="cb35-18"><a href="#cb35-18" aria-hidden="true" tabindex="-1"></a><span class="kw">WHERE</span> </span>
<span id="cb35-19"><a href="#cb35-19" aria-hidden="true" tabindex="-1"></a>    store2 <span class="kw">IS</span> <span class="kw">NOT</span> <span class="kw">NULL</span></span>
<span id="cb35-20"><a href="#cb35-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-21"><a href="#cb35-21" aria-hidden="true" tabindex="-1"></a><span class="kw">UNION</span> <span class="kw">ALL</span></span>
<span id="cb35-22"><a href="#cb35-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-23"><a href="#cb35-23" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> </span>
<span id="cb35-24"><a href="#cb35-24" aria-hidden="true" tabindex="-1"></a>    product_id,</span>
<span id="cb35-25"><a href="#cb35-25" aria-hidden="true" tabindex="-1"></a>    <span class="st">'store3'</span> <span class="kw">AS</span> <span class="kw">store</span>,</span>
<span id="cb35-26"><a href="#cb35-26" aria-hidden="true" tabindex="-1"></a>    store3 <span class="kw">AS</span> price</span>
<span id="cb35-27"><a href="#cb35-27" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> </span>
<span id="cb35-28"><a href="#cb35-28" aria-hidden="true" tabindex="-1"></a>    Products</span>
<span id="cb35-29"><a href="#cb35-29" aria-hidden="true" tabindex="-1"></a><span class="kw">WHERE</span> </span>
<span id="cb35-30"><a href="#cb35-30" aria-hidden="true" tabindex="-1"></a>    store3 <span class="kw">IS</span> <span class="kw">NOT</span> <span class="kw">NULL</span>;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Explanation:</strong></p>
<ul>
<li>This query performs unpivoting (also known as “melting”) of a wide-format table into a long-format table.</li>
<li>The solution uses a straightforward UNION ALL approach:
<ul>
<li>Each SELECT statement extracts data for one store column.</li>
<li>The store name is hardcoded as a string literal in each query.</li>
<li>The WHERE clauses filter out NULL prices as required.</li>
</ul></li>
<li>UNION ALL combines the results from all three queries into a single result set.</li>
<li>This approach effectively transforms the data from a “wide” format (one row per product with multiple store columns) to a “long” format (multiple rows per product, one for each store with a price).</li>
<li>Time complexity: O(n) where n is the number of products.</li>
<li>Space complexity: O(n × s) where s is the number of stores (3 in this case).</li>
<li>This solution correctly handles the requirement to exclude rows where the price is NULL.</li>
<li>For large datasets, indexes on product_id would improve performance.</li>
<li>The solution is simple and efficient for a fixed number of store columns.</li>
<li>Unlike the previous problem (Dynamic Pivoting), this unpivoting operation can be performed directly without generating intermediary SQL.</li>
<li>The approach works well for the specific case of 3 stores but would become verbose for tables with many columns.</li>
<li>For tables with a large or variable number of columns, PostgreSQL’s crosstab function (from the tablefunc extension) or a dynamic SQL approach would be more scalable.</li>
<li>The UNION ALL operation preserves all rows from each subquery, which is appropriate since there should be no duplicates.</li>
<li>Each subquery explicitly names the store, ensuring clear identification in the output.</li>
<li>This pattern effectively “normalizes” the denormalized data structure of the original table.</li>
<li>The solution follows good practice by explicitly naming all columns in the result set.</li>
</ul>
</section>
<section id="generate-the-invoice" class="level4">
<h4 class="anchored" data-anchor-id="generate-the-invoice">2362. Generate the Invoice</h4>
<p><strong>Description:</strong></p>
<table class="caption-top table">
<caption>Products</caption>
<colgroup>
<col style="width: 19%">
<col style="width: 9%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>product_id price</td>
<td>int int</td>
</tr>
</tbody>
</table>
<p>product_id is the primary key for this table. Each row in this table shows the ID of a product and its price.</p>
<table class="caption-top table">
<caption>Purchases</caption>
<colgroup>
<col style="width: 19%">
<col style="width: 9%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>invoice_id product_id quantity</td>
<td>int int int</td>
</tr>
</tbody>
</table>
<p>(invoice_id, product_id) is the primary key for this table. Each row in this table shows the quantity ordered from one product in an invoice.</p>
<p>Write an SQL query to show the details of the invoice with the highest price. If there are multiple invoices with the same price, return the details of the one with the smallest invoice_id.</p>
<p>The details of an invoice include the invoice_id, product_id, quantity, and price. The price of an invoice is equal to the sum of the prices of all the products present in the invoice, with their respective quantities.</p>
<p>Return the result table ordered by product_id in ascending order.</p>
<p><strong>Solution:</strong></p>
<div class="sourceCode" id="cb36"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="kw">WITH</span> invoice_totals <span class="kw">AS</span> (</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>        p.invoice_id,</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>        <span class="fu">SUM</span>(pr.price <span class="op">*</span> p.quantity) <span class="kw">AS</span> total_price</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>        Purchases p</span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">JOIN</span> </span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a>        Products pr <span class="kw">ON</span> p.product_id <span class="op">=</span> pr.product_id</span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">GROUP</span> <span class="kw">BY</span> </span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a>        p.invoice_id</span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a>highest_invoice <span class="kw">AS</span> (</span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb36-14"><a href="#cb36-14" aria-hidden="true" tabindex="-1"></a>        invoice_id</span>
<span id="cb36-15"><a href="#cb36-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb36-16"><a href="#cb36-16" aria-hidden="true" tabindex="-1"></a>        invoice_totals</span>
<span id="cb36-17"><a href="#cb36-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">ORDER</span> <span class="kw">BY</span> </span>
<span id="cb36-18"><a href="#cb36-18" aria-hidden="true" tabindex="-1"></a>        total_price <span class="kw">DESC</span>, invoice_id</span>
<span id="cb36-19"><a href="#cb36-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">LIMIT</span> <span class="dv">1</span></span>
<span id="cb36-20"><a href="#cb36-20" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb36-21"><a href="#cb36-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-22"><a href="#cb36-22" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> </span>
<span id="cb36-23"><a href="#cb36-23" aria-hidden="true" tabindex="-1"></a>    p.invoice_id,</span>
<span id="cb36-24"><a href="#cb36-24" aria-hidden="true" tabindex="-1"></a>    p.product_id,</span>
<span id="cb36-25"><a href="#cb36-25" aria-hidden="true" tabindex="-1"></a>    p.quantity,</span>
<span id="cb36-26"><a href="#cb36-26" aria-hidden="true" tabindex="-1"></a>    pr.price <span class="op">*</span> p.quantity <span class="kw">AS</span> price</span>
<span id="cb36-27"><a href="#cb36-27" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> </span>
<span id="cb36-28"><a href="#cb36-28" aria-hidden="true" tabindex="-1"></a>    Purchases p</span>
<span id="cb36-29"><a href="#cb36-29" aria-hidden="true" tabindex="-1"></a><span class="kw">JOIN</span> </span>
<span id="cb36-30"><a href="#cb36-30" aria-hidden="true" tabindex="-1"></a>    Products pr <span class="kw">ON</span> p.product_id <span class="op">=</span> pr.product_id</span>
<span id="cb36-31"><a href="#cb36-31" aria-hidden="true" tabindex="-1"></a><span class="kw">JOIN</span> </span>
<span id="cb36-32"><a href="#cb36-32" aria-hidden="true" tabindex="-1"></a>    highest_invoice hi <span class="kw">ON</span> p.invoice_id <span class="op">=</span> hi.invoice_id</span>
<span id="cb36-33"><a href="#cb36-33" aria-hidden="true" tabindex="-1"></a><span class="kw">ORDER</span> <span class="kw">BY</span> </span>
<span id="cb36-34"><a href="#cb36-34" aria-hidden="true" tabindex="-1"></a>    p.product_id;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Explanation:</strong></p>
<ul>
<li>This query identifies the invoice with the highest total price and returns its detailed line items.</li>
<li>The solution uses a three-step approach with Common Table Expressions (CTEs):
<ul>
<li>The <code>invoice_totals</code> CTE calculates the total price of each invoice by summing the product of price and quantity.</li>
<li>The <code>highest_invoice</code> CTE identifies the invoice with the highest total price (or the smallest invoice_id in case of a tie).</li>
<li>The main query retrieves all line items from the selected invoice with their details.</li>
</ul></li>
<li>The JOIN between Purchases and Products calculates the price for each line item.</li>
<li>The ORDER BY clause ensures results are sorted by product_id as required.</li>
<li>Time complexity: O(n log n) where n is the number of purchases, due to the sorting operations.</li>
<li>Space complexity: O(i + p) where i is the number of invoices and p is the number of purchases for the highest invoice.</li>
<li>This solution correctly handles edge cases:
<ul>
<li>Multiple invoices with the same total price (resolved by selecting the smallest invoice_id)</li>
<li>Invoices with multiple product line items</li>
</ul></li>
<li>For large datasets, indexes on invoice_id and product_id would improve join performance.</li>
<li>The LIMIT 1 in the highest_invoice CTE efficiently selects just the top invoice without unnecessarily sorting all invoices.</li>
<li>The approach separates the invoice selection logic from the detail retrieval, making the query more readable and maintainable.</li>
<li>The price calculation is repeated in both CTEs to ensure accurate results.</li>
<li>The JOIN with the highest_invoice CTE acts as a filter to include only line items from the selected invoice.</li>
<li>The solution follows the requirement to order results by product_id.</li>
<li>An alternative approach could use a window function to rank invoices, but the CTE method is cleaner for this specific requirement.</li>
</ul>
</section>
<section id="customers-with-strictly-increasing-purchases" class="level4">
<h4 class="anchored" data-anchor-id="customers-with-strictly-increasing-purchases">2474. Customers With Strictly Increasing Purchases</h4>
<p><strong>Description:</strong></p>
<table class="caption-top table">
<caption>Orders</caption>
<colgroup>
<col style="width: 22%">
<col style="width: 9%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>order_id customer_id order_date price</td>
<td>int int date int</td>
</tr>
</tbody>
</table>
<p>order_id is the primary key for this table. Each row contains the id of an order, the id of the customer that ordered it, the date of the order, and its price.</p>
<p>Write an SQL query to report the IDs of the customers with strictly increasing annual spends.</p>
<p>The annual spend for a customer is the sum of the prices of all orders of that customer in that year. If for some year the customer did not make any order, the annual spend for that year is considered to be 0.</p>
<p>A customer has a strictly increasing annual spend if their annual spend for each year is strictly higher than the previous year.</p>
<p>Return the result table ordered by customer_id in ascending order.</p>
<p><strong>Solution:</strong></p>
<div class="sourceCode" id="cb37"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">WITH</span> yearly_spend <span class="kw">AS</span> (</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>        customer_id,</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>        <span class="fu">EXTRACT</span>(<span class="dt">YEAR</span> <span class="kw">FROM</span> order_date) <span class="kw">AS</span> <span class="dt">year</span>,</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>        <span class="fu">SUM</span>(price) <span class="kw">AS</span> annual_spend</span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>        Orders</span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">GROUP</span> <span class="kw">BY</span> </span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a>        customer_id, <span class="fu">EXTRACT</span>(<span class="dt">YEAR</span> <span class="kw">FROM</span> order_date)</span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a>all_years <span class="kw">AS</span> (</span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true" tabindex="-1"></a>        <span class="kw">DISTINCT</span> customer_id</span>
<span id="cb37-14"><a href="#cb37-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb37-15"><a href="#cb37-15" aria-hidden="true" tabindex="-1"></a>        Orders</span>
<span id="cb37-16"><a href="#cb37-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">CROSS</span> <span class="kw">JOIN</span> </span>
<span id="cb37-17"><a href="#cb37-17" aria-hidden="true" tabindex="-1"></a>        (<span class="kw">SELECT</span> <span class="kw">DISTINCT</span> <span class="fu">EXTRACT</span>(<span class="dt">YEAR</span> <span class="kw">FROM</span> order_date) <span class="kw">AS</span> <span class="dt">year</span> <span class="kw">FROM</span> Orders) <span class="kw">AS</span> years</span>
<span id="cb37-18"><a href="#cb37-18" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb37-19"><a href="#cb37-19" aria-hidden="true" tabindex="-1"></a>complete_spend <span class="kw">AS</span> (</span>
<span id="cb37-20"><a href="#cb37-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb37-21"><a href="#cb37-21" aria-hidden="true" tabindex="-1"></a>        ay.customer_id,</span>
<span id="cb37-22"><a href="#cb37-22" aria-hidden="true" tabindex="-1"></a>        ay.<span class="dt">year</span>,</span>
<span id="cb37-23"><a href="#cb37-23" aria-hidden="true" tabindex="-1"></a>        <span class="fu">COALESCE</span>(ys.annual_spend, <span class="dv">0</span>) <span class="kw">AS</span> annual_spend</span>
<span id="cb37-24"><a href="#cb37-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb37-25"><a href="#cb37-25" aria-hidden="true" tabindex="-1"></a>        all_years ay</span>
<span id="cb37-26"><a href="#cb37-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">LEFT</span> <span class="kw">JOIN</span> </span>
<span id="cb37-27"><a href="#cb37-27" aria-hidden="true" tabindex="-1"></a>        yearly_spend ys <span class="kw">ON</span> ay.customer_id <span class="op">=</span> ys.customer_id <span class="kw">AND</span> ay.<span class="dt">year</span> <span class="op">=</span> ys.<span class="dt">year</span></span>
<span id="cb37-28"><a href="#cb37-28" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb37-29"><a href="#cb37-29" aria-hidden="true" tabindex="-1"></a>spend_changes <span class="kw">AS</span> (</span>
<span id="cb37-30"><a href="#cb37-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb37-31"><a href="#cb37-31" aria-hidden="true" tabindex="-1"></a>        customer_id,</span>
<span id="cb37-32"><a href="#cb37-32" aria-hidden="true" tabindex="-1"></a>        <span class="dt">year</span>,</span>
<span id="cb37-33"><a href="#cb37-33" aria-hidden="true" tabindex="-1"></a>        annual_spend,</span>
<span id="cb37-34"><a href="#cb37-34" aria-hidden="true" tabindex="-1"></a>        <span class="fu">LAG</span>(annual_spend) <span class="kw">OVER</span> (<span class="kw">PARTITION</span> <span class="kw">BY</span> customer_id <span class="kw">ORDER</span> <span class="kw">BY</span> <span class="dt">year</span>) <span class="kw">AS</span> prev_year_spend</span>
<span id="cb37-35"><a href="#cb37-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb37-36"><a href="#cb37-36" aria-hidden="true" tabindex="-1"></a>        complete_spend</span>
<span id="cb37-37"><a href="#cb37-37" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb37-38"><a href="#cb37-38" aria-hidden="true" tabindex="-1"></a>customer_trends <span class="kw">AS</span> (</span>
<span id="cb37-39"><a href="#cb37-39" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb37-40"><a href="#cb37-40" aria-hidden="true" tabindex="-1"></a>        customer_id,</span>
<span id="cb37-41"><a href="#cb37-41" aria-hidden="true" tabindex="-1"></a>        BOOL_AND(annual_spend <span class="op">&gt;</span> <span class="fu">COALESCE</span>(prev_year_spend, <span class="op">-</span><span class="dv">1</span>)) <span class="kw">AS</span> is_strictly_increasing</span>
<span id="cb37-42"><a href="#cb37-42" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb37-43"><a href="#cb37-43" aria-hidden="true" tabindex="-1"></a>        spend_changes</span>
<span id="cb37-44"><a href="#cb37-44" aria-hidden="true" tabindex="-1"></a>    <span class="kw">GROUP</span> <span class="kw">BY</span> </span>
<span id="cb37-45"><a href="#cb37-45" aria-hidden="true" tabindex="-1"></a>        customer_id</span>
<span id="cb37-46"><a href="#cb37-46" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb37-47"><a href="#cb37-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-48"><a href="#cb37-48" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> </span>
<span id="cb37-49"><a href="#cb37-49" aria-hidden="true" tabindex="-1"></a>    customer_id</span>
<span id="cb37-50"><a href="#cb37-50" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> </span>
<span id="cb37-51"><a href="#cb37-51" aria-hidden="true" tabindex="-1"></a>    customer_trends</span>
<span id="cb37-52"><a href="#cb37-52" aria-hidden="true" tabindex="-1"></a><span class="kw">WHERE</span> </span>
<span id="cb37-53"><a href="#cb37-53" aria-hidden="true" tabindex="-1"></a>    is_strictly_increasing <span class="op">=</span> <span class="kw">true</span></span>
<span id="cb37-54"><a href="#cb37-54" aria-hidden="true" tabindex="-1"></a><span class="kw">ORDER</span> <span class="kw">BY</span> </span>
<span id="cb37-55"><a href="#cb37-55" aria-hidden="true" tabindex="-1"></a>    customer_id;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Explanation:</strong></p>
<ul>
<li>This query identifies customers whose annual spending has strictly increased each year.</li>
<li>The solution uses a comprehensive approach with multiple Common Table Expressions (CTEs):
<ul>
<li>The <code>yearly_spend</code> CTE calculates each customer’s total spend per year.</li>
<li>The <code>all_years</code> CTE creates a complete cartesian product of customers and years to ensure no years are missed.</li>
<li>The <code>complete_spend</code> CTE fills in missing years with zero spend using a LEFT JOIN.</li>
<li>The <code>spend_changes</code> CTE uses the LAG window function to compare each year’s spend with the previous year.</li>
<li>The <code>customer_trends</code> CTE uses BOOL_AND to check if all year-to-year changes are strictly increasing.</li>
</ul></li>
<li>BOOL_AND returns true only if all comparisons in the group are true, ensuring the strictly increasing requirement.</li>
<li>The main query filters for customers where all year-to-year changes are strictly increasing.</li>
<li>Time complexity: O(n log n) where n is the number of orders, due to the sorting and grouping operations.</li>
<li>Space complexity: O(c × y) where c is the number of customers and y is the number of distinct years.</li>
<li>This solution correctly handles edge cases:
<ul>
<li>Years where a customer made no purchases (counted as zero spend)</li>
<li>Customers with only a single year of purchases (considered strictly increasing by default)</li>
<li>Missing years in the data (filled in with zero spend)</li>
</ul></li>
<li>For large datasets, indexes on customer_id and order_date would improve performance.</li>
<li>COALESCE in the complete_spend CTE ensures years without orders show zero spend.</li>
<li>COALESCE in the spend_changes CTE handles the first year comparison by using -1 as a default.</li>
<li>The CROSS JOIN ensures all possible customer-year combinations are considered.</li>
<li>The approach efficiently separates the data preparation from the trend analysis logic.</li>
<li>The solution follows the requirement to order results by customer_id.</li>
<li>Using EXTRACT(YEAR FROM order_date) isolates just the year component from the date.</li>
</ul>
</section>
<section id="merge-overlapping-events-in-the-same-hall" class="level4">
<h4 class="anchored" data-anchor-id="merge-overlapping-events-in-the-same-hall">2494. Merge Overlapping Events in the Same Hall</h4>
<p><strong>Description:</strong></p>
<table class="caption-top table">
<caption>HallEvents</caption>
<colgroup>
<col style="width: 19%">
<col style="width: 9%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>hall_id start_day end_day</td>
<td>int date date</td>
</tr>
</tbody>
</table>
<p>(hall_id, start_day) is the primary key for this table. Each row of this table indicates the start day and end day of an event and the hall in which the event is held.</p>
<p>Write an SQL query to merge all the overlapping events that are held in the same hall. Two events overlap if they have at least one day in common.</p>
<p>Return the result table in any order.</p>
<p><strong>Solution:</strong></p>
<div class="sourceCode" id="cb38"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="kw">WITH</span> recursive event_groups <span class="kw">AS</span> (</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Base case: Start with the first event for each hall</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>        hall_id,</span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>        <span class="fu">MIN</span>(start_day) <span class="kw">AS</span> group_start,</span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>        <span class="fu">MAX</span>(end_day) <span class="kw">AS</span> group_end</span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a>        HallEvents</span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">GROUP</span> <span class="kw">BY</span> </span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a>        hall_id</span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">UNION</span> <span class="kw">ALL</span></span>
<span id="cb38-13"><a href="#cb38-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb38-14"><a href="#cb38-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Recursive case: Find events that don't overlap with any existing group</span></span>
<span id="cb38-15"><a href="#cb38-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb38-16"><a href="#cb38-16" aria-hidden="true" tabindex="-1"></a>        h.hall_id,</span>
<span id="cb38-17"><a href="#cb38-17" aria-hidden="true" tabindex="-1"></a>        h.start_day,</span>
<span id="cb38-18"><a href="#cb38-18" aria-hidden="true" tabindex="-1"></a>        h.end_day</span>
<span id="cb38-19"><a href="#cb38-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb38-20"><a href="#cb38-20" aria-hidden="true" tabindex="-1"></a>        HallEvents h</span>
<span id="cb38-21"><a href="#cb38-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">LEFT</span> <span class="kw">JOIN</span> </span>
<span id="cb38-22"><a href="#cb38-22" aria-hidden="true" tabindex="-1"></a>        event_groups eg <span class="kw">ON</span> h.hall_id <span class="op">=</span> eg.hall_id <span class="kw">AND</span> </span>
<span id="cb38-23"><a href="#cb38-23" aria-hidden="true" tabindex="-1"></a>                          (h.start_day <span class="op">&lt;=</span> eg.group_end <span class="kw">AND</span> h.end_day <span class="op">&gt;=</span> eg.group_start)</span>
<span id="cb38-24"><a href="#cb38-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">WHERE</span> </span>
<span id="cb38-25"><a href="#cb38-25" aria-hidden="true" tabindex="-1"></a>        eg.hall_id <span class="kw">IS</span> <span class="kw">NULL</span></span>
<span id="cb38-26"><a href="#cb38-26" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb38-27"><a href="#cb38-27" aria-hidden="true" tabindex="-1"></a>overlapping_events <span class="kw">AS</span> (</span>
<span id="cb38-28"><a href="#cb38-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb38-29"><a href="#cb38-29" aria-hidden="true" tabindex="-1"></a>        e1.hall_id,</span>
<span id="cb38-30"><a href="#cb38-30" aria-hidden="true" tabindex="-1"></a>        e1.start_day,</span>
<span id="cb38-31"><a href="#cb38-31" aria-hidden="true" tabindex="-1"></a>        e1.end_day,</span>
<span id="cb38-32"><a href="#cb38-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">CASE</span> </span>
<span id="cb38-33"><a href="#cb38-33" aria-hidden="true" tabindex="-1"></a>            <span class="cf">WHEN</span> <span class="kw">EXISTS</span> (</span>
<span id="cb38-34"><a href="#cb38-34" aria-hidden="true" tabindex="-1"></a>                <span class="kw">SELECT</span> <span class="dv">1</span> </span>
<span id="cb38-35"><a href="#cb38-35" aria-hidden="true" tabindex="-1"></a>                <span class="kw">FROM</span> HallEvents e2 </span>
<span id="cb38-36"><a href="#cb38-36" aria-hidden="true" tabindex="-1"></a>                <span class="kw">WHERE</span> e1.hall_id <span class="op">=</span> e2.hall_id <span class="kw">AND</span> </span>
<span id="cb38-37"><a href="#cb38-37" aria-hidden="true" tabindex="-1"></a>                      e1.start_day <span class="op">&lt;&gt;</span> e2.start_day <span class="kw">AND</span></span>
<span id="cb38-38"><a href="#cb38-38" aria-hidden="true" tabindex="-1"></a>                      e1.start_day <span class="op">&lt;=</span> e2.end_day <span class="kw">AND</span> </span>
<span id="cb38-39"><a href="#cb38-39" aria-hidden="true" tabindex="-1"></a>                      e1.end_day <span class="op">&gt;=</span> e2.start_day</span>
<span id="cb38-40"><a href="#cb38-40" aria-hidden="true" tabindex="-1"></a>            ) <span class="cf">THEN</span> <span class="dv">1</span></span>
<span id="cb38-41"><a href="#cb38-41" aria-hidden="true" tabindex="-1"></a>            <span class="cf">ELSE</span> <span class="dv">0</span></span>
<span id="cb38-42"><a href="#cb38-42" aria-hidden="true" tabindex="-1"></a>        <span class="cf">END</span> <span class="kw">AS</span> <span class="kw">overlaps</span></span>
<span id="cb38-43"><a href="#cb38-43" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb38-44"><a href="#cb38-44" aria-hidden="true" tabindex="-1"></a>        HallEvents e1</span>
<span id="cb38-45"><a href="#cb38-45" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb38-46"><a href="#cb38-46" aria-hidden="true" tabindex="-1"></a>group_markers <span class="kw">AS</span> (</span>
<span id="cb38-47"><a href="#cb38-47" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb38-48"><a href="#cb38-48" aria-hidden="true" tabindex="-1"></a>        hall_id,</span>
<span id="cb38-49"><a href="#cb38-49" aria-hidden="true" tabindex="-1"></a>        start_day,</span>
<span id="cb38-50"><a href="#cb38-50" aria-hidden="true" tabindex="-1"></a>        end_day,</span>
<span id="cb38-51"><a href="#cb38-51" aria-hidden="true" tabindex="-1"></a>        <span class="fu">SUM</span>(<span class="cf">CASE</span> <span class="cf">WHEN</span> <span class="kw">overlaps</span> <span class="op">=</span> <span class="dv">0</span> <span class="cf">THEN</span> <span class="dv">1</span> <span class="cf">ELSE</span> <span class="dv">0</span> <span class="cf">END</span>) <span class="kw">OVER</span> (</span>
<span id="cb38-52"><a href="#cb38-52" aria-hidden="true" tabindex="-1"></a>            <span class="kw">PARTITION</span> <span class="kw">BY</span> hall_id </span>
<span id="cb38-53"><a href="#cb38-53" aria-hidden="true" tabindex="-1"></a>            <span class="kw">ORDER</span> <span class="kw">BY</span> start_day</span>
<span id="cb38-54"><a href="#cb38-54" aria-hidden="true" tabindex="-1"></a>            <span class="kw">ROWS</span> <span class="kw">UNBOUNDED</span> <span class="kw">PRECEDING</span></span>
<span id="cb38-55"><a href="#cb38-55" aria-hidden="true" tabindex="-1"></a>        ) <span class="kw">AS</span> <span class="fu">group_id</span></span>
<span id="cb38-56"><a href="#cb38-56" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb38-57"><a href="#cb38-57" aria-hidden="true" tabindex="-1"></a>        overlapping_events</span>
<span id="cb38-58"><a href="#cb38-58" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb38-59"><a href="#cb38-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-60"><a href="#cb38-60" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> </span>
<span id="cb38-61"><a href="#cb38-61" aria-hidden="true" tabindex="-1"></a>    hall_id,</span>
<span id="cb38-62"><a href="#cb38-62" aria-hidden="true" tabindex="-1"></a>    <span class="fu">MIN</span>(start_day) <span class="kw">AS</span> start_day,</span>
<span id="cb38-63"><a href="#cb38-63" aria-hidden="true" tabindex="-1"></a>    <span class="fu">MAX</span>(end_day) <span class="kw">AS</span> end_day</span>
<span id="cb38-64"><a href="#cb38-64" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> </span>
<span id="cb38-65"><a href="#cb38-65" aria-hidden="true" tabindex="-1"></a>    group_markers</span>
<span id="cb38-66"><a href="#cb38-66" aria-hidden="true" tabindex="-1"></a><span class="kw">GROUP</span> <span class="kw">BY</span> </span>
<span id="cb38-67"><a href="#cb38-67" aria-hidden="true" tabindex="-1"></a>    hall_id, <span class="fu">group_id</span></span>
<span id="cb38-68"><a href="#cb38-68" aria-hidden="true" tabindex="-1"></a><span class="kw">ORDER</span> <span class="kw">BY</span> </span>
<span id="cb38-69"><a href="#cb38-69" aria-hidden="true" tabindex="-1"></a>    hall_id, start_day;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Explanation:</strong></p>
<ul>
<li>This query merges overlapping events held in the same hall, where events overlap if they share at least one day.</li>
<li>The solution uses a multi-step approach with Common Table Expressions (CTEs):
<ul>
<li>The recursive <code>event_groups</code> CTE attempts to find non-overlapping groups of events.</li>
<li>The <code>overlapping_events</code> CTE marks events that overlap with at least one other event.</li>
<li>The <code>group_markers</code> CTE assigns a group ID to each event, incrementing at the start of each non-overlapping sequence.</li>
</ul></li>
<li>The EXISTS subquery in overlapping_events efficiently checks if an event overlaps with any other event.</li>
<li>The window function in group_markers creates a running sum that increases only at the start of a new non-overlapping group.</li>
<li>The main query then aggregates events by hall_id and group_id to merge overlapping events.</li>
<li>Time complexity: O(n²) where n is the number of events, due to the overlap checking.</li>
<li>Space complexity: O(n) for the intermediate results.</li>
<li>This solution correctly handles edge cases:
<ul>
<li>Events that touch exactly (end_day of one equals start_day of another)</li>
<li>Multiple overlapping event chains</li>
<li>Events with no overlaps</li>
</ul></li>
<li>For large datasets, indexes on hall_id, start_day, and end_day would improve performance.</li>
<li>The recursive CTE approach provides one way to tackle the problem, but the window function method in the final solution is more efficient.</li>
<li>The combination of EXISTS and window functions efficiently identifies and groups overlapping events.</li>
<li>The solution maintains the requirement to preserve the hall_id in the output.</li>
<li>The approach handles complex overlap patterns where events might form chains of overlaps.</li>
<li>The final ORDER BY ensures consistent results, though the problem allows any order.</li>
<li>An alternative approach could use the “islands and gaps” technique with date arithmetic, but the window function method is more intuitive for this problem.</li>
</ul>
</section>
<section id="consecutive-transactions-with-increasing-amounts" class="level4">
<h4 class="anchored" data-anchor-id="consecutive-transactions-with-increasing-amounts">2701. Consecutive Transactions with Increasing Amounts</h4>
<p><strong>Description:</strong></p>
<table class="caption-top table">
<caption>Transactions</caption>
<colgroup>
<col style="width: 23%">
<col style="width: 9%">
<col style="width: 2%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
<td></td>
</tr>
<tr class="even">
<td colspan="3">transaction_id | int | customer_id | int | transaction_date | date amount | int |</td>
</tr>
</tbody>
</table>
<p>transaction_id is the primary key for this table. Each row contains information about a transaction with the customer customer_id on transaction_date with amount.</p>
<p>Write an SQL query to find customers with increasing transactions.</p>
<p>A customer has increasing transactions if the amount of at least one transaction is strictly greater than the previous transaction (ignoring the very first transaction of each customer).</p>
<p>Return the customer_id of these customers sorted in ascending order.</p>
<p><strong>Solution:</strong></p>
<div class="sourceCode" id="cb39"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="kw">WITH</span> customer_transactions <span class="kw">AS</span> (</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>        customer_id,</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>        transaction_date,</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>        amount,</span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>        <span class="fu">LAG</span>(amount) <span class="kw">OVER</span> (</span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>            <span class="kw">PARTITION</span> <span class="kw">BY</span> customer_id </span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a>            <span class="kw">ORDER</span> <span class="kw">BY</span> transaction_date</span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a>        ) <span class="kw">AS</span> prev_amount</span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a>        Transactions</span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a>increasing_customers <span class="kw">AS</span> (</span>
<span id="cb39-14"><a href="#cb39-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> <span class="kw">DISTINCT</span></span>
<span id="cb39-15"><a href="#cb39-15" aria-hidden="true" tabindex="-1"></a>        customer_id</span>
<span id="cb39-16"><a href="#cb39-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb39-17"><a href="#cb39-17" aria-hidden="true" tabindex="-1"></a>        customer_transactions</span>
<span id="cb39-18"><a href="#cb39-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">WHERE</span> </span>
<span id="cb39-19"><a href="#cb39-19" aria-hidden="true" tabindex="-1"></a>        amount <span class="op">&gt;</span> prev_amount</span>
<span id="cb39-20"><a href="#cb39-20" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb39-21"><a href="#cb39-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-22"><a href="#cb39-22" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> </span>
<span id="cb39-23"><a href="#cb39-23" aria-hidden="true" tabindex="-1"></a>    customer_id</span>
<span id="cb39-24"><a href="#cb39-24" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> </span>
<span id="cb39-25"><a href="#cb39-25" aria-hidden="true" tabindex="-1"></a>    increasing_customers</span>
<span id="cb39-26"><a href="#cb39-26" aria-hidden="true" tabindex="-1"></a><span class="kw">ORDER</span> <span class="kw">BY</span> </span>
<span id="cb39-27"><a href="#cb39-27" aria-hidden="true" tabindex="-1"></a>    customer_id;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Explanation:</strong></p>
<ul>
<li>This query identifies customers who have at least one transaction where the amount is strictly greater than their previous transaction.</li>
<li>The solution uses a two-step approach with Common Table Expressions (CTEs):
<ul>
<li>The <code>customer_transactions</code> CTE uses the LAG window function to access the amount of each customer’s previous transaction.</li>
<li>The <code>increasing_customers</code> CTE filters for customers with at least one transaction where amount &gt; prev_amount.</li>
</ul></li>
<li>The LAG function partitions by customer_id and orders by transaction_date to ensure we’re comparing each transaction with the chronologically previous one from the same customer.</li>
<li>The DISTINCT keyword ensures each customer is listed only once, even if they have multiple increasing transactions.</li>
<li>Time complexity: O(n log n) where n is the number of transactions, due to the sorting operations.</li>
<li>Space complexity: O(n) for the intermediate results.</li>
<li>This solution correctly handles edge cases:
<ul>
<li>Customers with only one transaction (excluded since there’s no “previous” transaction to compare)</li>
<li>Customers with transactions on the same date (ordered by transaction_date)</li>
<li>Customers with no increasing transactions (excluded from results)</li>
</ul></li>
<li>For large datasets, indexes on customer_id and transaction_date would improve performance.</li>
<li>The approach efficiently implements the “strictly greater than the previous transaction” requirement using window functions.</li>
<li>The ORDER BY in the final query ensures results are returned in customer_id order as required.</li>
<li>The solution excludes comparisons with the first transaction (where prev_amount is NULL) by requiring amount &gt; prev_amount.</li>
<li>The approach is concise and focuses directly on the requirement without unnecessary calculations.</li>
<li>This pattern of using LAG with a window function is a common technique for analyzing sequential data in SQL.</li>
<li>The DISTINCT in the second CTE ensures the final result doesn’t include duplicate customer IDs.</li>
</ul>
</section>
<section id="popularity-percentage" class="level4">
<h4 class="anchored" data-anchor-id="popularity-percentage">2720. Popularity Percentage</h4>
<p><strong>Description:</strong></p>
<table class="caption-top table">
<caption>Friends</caption>
<colgroup>
<col style="width: 19%">
<col style="width: 9%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>user1_id user2_id</td>
<td>int int</td>
</tr>
</tbody>
</table>
<p>(user1_id, user2_id) is the primary key for this table. Each row of this table indicates that the users user1_id and user2_id are friends. Note that user1_id &lt; user2_id.</p>
<p>Write an SQL query to find the popularity percentage for each user on the platform. The popularity percentage is defined as the number of friends the user has divided by the total number of users on the platform (including themself), times 100. If the popularity percentage is a decimal number, round it to 2 decimal places.</p>
<p>Return the result table ordered by user_id in ascending order.</p>
<p><strong>Solution:</strong></p>
<div class="sourceCode" id="cb40"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="kw">WITH</span> user_list <span class="kw">AS</span> (</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> user1_id <span class="kw">AS</span> user_id <span class="kw">FROM</span> Friends</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">UNION</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> user2_id <span class="kw">AS</span> user_id <span class="kw">FROM</span> Friends</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>all_users <span class="kw">AS</span> (</span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> <span class="kw">DISTINCT</span> user_id </span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> user_list</span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a>total_users <span class="kw">AS</span> (</span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> <span class="fu">COUNT</span>(<span class="op">*</span>) <span class="kw">AS</span> total </span>
<span id="cb40-12"><a href="#cb40-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> all_users</span>
<span id="cb40-13"><a href="#cb40-13" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb40-14"><a href="#cb40-14" aria-hidden="true" tabindex="-1"></a>friend_counts <span class="kw">AS</span> (</span>
<span id="cb40-15"><a href="#cb40-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb40-16"><a href="#cb40-16" aria-hidden="true" tabindex="-1"></a>        user1_id <span class="kw">AS</span> user_id,</span>
<span id="cb40-17"><a href="#cb40-17" aria-hidden="true" tabindex="-1"></a>        <span class="fu">COUNT</span>(<span class="op">*</span>) <span class="kw">AS</span> friend_count</span>
<span id="cb40-18"><a href="#cb40-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb40-19"><a href="#cb40-19" aria-hidden="true" tabindex="-1"></a>        Friends</span>
<span id="cb40-20"><a href="#cb40-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">GROUP</span> <span class="kw">BY</span> </span>
<span id="cb40-21"><a href="#cb40-21" aria-hidden="true" tabindex="-1"></a>        user1_id</span>
<span id="cb40-22"><a href="#cb40-22" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb40-23"><a href="#cb40-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">UNION</span> <span class="kw">ALL</span></span>
<span id="cb40-24"><a href="#cb40-24" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb40-25"><a href="#cb40-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb40-26"><a href="#cb40-26" aria-hidden="true" tabindex="-1"></a>        user2_id <span class="kw">AS</span> user_id,</span>
<span id="cb40-27"><a href="#cb40-27" aria-hidden="true" tabindex="-1"></a>        <span class="fu">COUNT</span>(<span class="op">*</span>) <span class="kw">AS</span> friend_count</span>
<span id="cb40-28"><a href="#cb40-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb40-29"><a href="#cb40-29" aria-hidden="true" tabindex="-1"></a>        Friends</span>
<span id="cb40-30"><a href="#cb40-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">GROUP</span> <span class="kw">BY</span> </span>
<span id="cb40-31"><a href="#cb40-31" aria-hidden="true" tabindex="-1"></a>        user2_id</span>
<span id="cb40-32"><a href="#cb40-32" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb40-33"><a href="#cb40-33" aria-hidden="true" tabindex="-1"></a>user_popularity <span class="kw">AS</span> (</span>
<span id="cb40-34"><a href="#cb40-34" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb40-35"><a href="#cb40-35" aria-hidden="true" tabindex="-1"></a>        user_id,</span>
<span id="cb40-36"><a href="#cb40-36" aria-hidden="true" tabindex="-1"></a>        <span class="fu">SUM</span>(friend_count) <span class="kw">AS</span> total_friends</span>
<span id="cb40-37"><a href="#cb40-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb40-38"><a href="#cb40-38" aria-hidden="true" tabindex="-1"></a>        friend_counts</span>
<span id="cb40-39"><a href="#cb40-39" aria-hidden="true" tabindex="-1"></a>    <span class="kw">GROUP</span> <span class="kw">BY</span> </span>
<span id="cb40-40"><a href="#cb40-40" aria-hidden="true" tabindex="-1"></a>        user_id</span>
<span id="cb40-41"><a href="#cb40-41" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb40-42"><a href="#cb40-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-43"><a href="#cb40-43" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> </span>
<span id="cb40-44"><a href="#cb40-44" aria-hidden="true" tabindex="-1"></a>    au.user_id,</span>
<span id="cb40-45"><a href="#cb40-45" aria-hidden="true" tabindex="-1"></a>    <span class="fu">ROUND</span>((<span class="fu">COALESCE</span>(up.total_friends, <span class="dv">0</span>) <span class="op">*</span> <span class="fl">100.0</span> <span class="op">/</span> tu.total), <span class="dv">2</span>) <span class="kw">AS</span> popularity_percent</span>
<span id="cb40-46"><a href="#cb40-46" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> </span>
<span id="cb40-47"><a href="#cb40-47" aria-hidden="true" tabindex="-1"></a>    all_users au</span>
<span id="cb40-48"><a href="#cb40-48" aria-hidden="true" tabindex="-1"></a><span class="kw">LEFT</span> <span class="kw">JOIN</span> </span>
<span id="cb40-49"><a href="#cb40-49" aria-hidden="true" tabindex="-1"></a>    user_popularity up <span class="kw">ON</span> au.user_id <span class="op">=</span> up.user_id</span>
<span id="cb40-50"><a href="#cb40-50" aria-hidden="true" tabindex="-1"></a><span class="kw">CROSS</span> <span class="kw">JOIN</span> </span>
<span id="cb40-51"><a href="#cb40-51" aria-hidden="true" tabindex="-1"></a>    total_users tu</span>
<span id="cb40-52"><a href="#cb40-52" aria-hidden="true" tabindex="-1"></a><span class="kw">ORDER</span> <span class="kw">BY</span> </span>
<span id="cb40-53"><a href="#cb40-53" aria-hidden="true" tabindex="-1"></a>    au.user_id;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Explanation:</strong></p>
<ul>
<li>This query calculates the popularity percentage for each user based on their friendship count relative to the total user count.</li>
<li>The solution uses a multi-step approach with Common Table Expressions (CTEs):
<ul>
<li>The <code>user_list</code> CTE collects all user IDs from both sides of the friendship table.</li>
<li>The <code>all_users</code> CTE gets a distinct list of users to ensure each user is counted only once.</li>
<li>The <code>total_users</code> CTE counts the total number of users on the platform.</li>
<li>The <code>friend_counts</code> CTE counts friendships for each user, considering both user1_id and user2_id.</li>
<li>The <code>user_popularity</code> CTE sums friendship counts for users who appear on both sides of the friendship table.</li>
</ul></li>
<li>The main query calculates the popularity percentage by dividing the friendship count by the total user count.</li>
<li>ROUND(…, 2) ensures the percentage is rounded to 2 decimal places as required.</li>
<li>Time complexity: O(n log n) where n is the number of friendship records, due to the sorting and grouping operations.</li>
<li>Space complexity: O(u) where u is the number of unique users.</li>
<li>This solution correctly handles edge cases:
<ul>
<li>Users with no friends (assigned a popularity of 0%)</li>
<li>Users who appear only as user1_id or only as user2_id in the Friends table</li>
</ul></li>
<li>For large datasets, indexes on user1_id and user2_id would improve performance.</li>
<li>The LEFT JOIN ensures all users are included in the result, even those with no friends.</li>
<li>The CROSS JOIN with total_users makes the total count available for each row’s percentage calculation.</li>
<li>COALESCE handles users with no friends by defaulting to 0 for the count.</li>
<li>The multiplication by 100.0 (not just 100) ensures decimal division for accurate percentage calculation.</li>
<li>The approach correctly accounts for the bidirectional nature of friendships.</li>
<li>The solution follows the requirement to order results by user_id.</li>
<li>The UNION in user_list (not UNION ALL) eliminates duplicates, ensuring each user is counted only once.</li>
</ul>
</section>
<section id="customers-with-maximum-number-of-transactions-on-consecutive-days" class="level4">
<h4 class="anchored" data-anchor-id="customers-with-maximum-number-of-transactions-on-consecutive-days">2752. Customers with Maximum Number of Transactions on Consecutive Days</h4>
<p><strong>Description:</strong></p>
<table class="caption-top table">
<caption>Transactions</caption>
<colgroup>
<col style="width: 26%">
<col style="width: 9%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>transaction_id customer_id transaction_date amount</td>
<td>int int date int</td>
</tr>
</tbody>
</table>
<p>transaction_id is the primary key for this table. Each row contains information about a transaction with customer_id on transaction_date with amount.</p>
<p>Write an SQL query to find the customers who have made the maximum number of consecutive transactions. If more than one customer has the same number of consecutive transactions, return all of them.</p>
<p>Note that:</p>
<ul>
<li>Consecutive transactions by a customer are transactions made on consecutive days.</li>
<li>There may be multiple transactions made on the same day, but transactions on different days may be considered consecutive if they’re made on consecutive days.</li>
</ul>
<p>Return the result table ordered by customer_id in ascending order.</p>
<p><strong>Solution:</strong></p>
<div class="sourceCode" id="cb41"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="kw">WITH</span> daily_transactions <span class="kw">AS</span> (</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Count transactions per customer per day</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>        customer_id,</span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>        transaction_date,</span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>        <span class="fu">COUNT</span>(<span class="op">*</span>) <span class="kw">AS</span> transactions_count</span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>        Transactions</span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">GROUP</span> <span class="kw">BY</span> </span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a>        customer_id, transaction_date</span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb41-12"><a href="#cb41-12" aria-hidden="true" tabindex="-1"></a>consecutive_days <span class="kw">AS</span> (</span>
<span id="cb41-13"><a href="#cb41-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Identify groups of consecutive days</span></span>
<span id="cb41-14"><a href="#cb41-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb41-15"><a href="#cb41-15" aria-hidden="true" tabindex="-1"></a>        customer_id,</span>
<span id="cb41-16"><a href="#cb41-16" aria-hidden="true" tabindex="-1"></a>        transaction_date,</span>
<span id="cb41-17"><a href="#cb41-17" aria-hidden="true" tabindex="-1"></a>        transaction_date <span class="op">-</span> <span class="fu">ROW_NUMBER</span>() <span class="kw">OVER</span> (</span>
<span id="cb41-18"><a href="#cb41-18" aria-hidden="true" tabindex="-1"></a>            <span class="kw">PARTITION</span> <span class="kw">BY</span> customer_id </span>
<span id="cb41-19"><a href="#cb41-19" aria-hidden="true" tabindex="-1"></a>            <span class="kw">ORDER</span> <span class="kw">BY</span> transaction_date</span>
<span id="cb41-20"><a href="#cb41-20" aria-hidden="true" tabindex="-1"></a>        ):<span class="ch">:integer</span> <span class="kw">AS</span> <span class="fu">group_id</span></span>
<span id="cb41-21"><a href="#cb41-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb41-22"><a href="#cb41-22" aria-hidden="true" tabindex="-1"></a>        daily_transactions</span>
<span id="cb41-23"><a href="#cb41-23" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb41-24"><a href="#cb41-24" aria-hidden="true" tabindex="-1"></a>consecutive_counts <span class="kw">AS</span> (</span>
<span id="cb41-25"><a href="#cb41-25" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Count consecutive days for each group</span></span>
<span id="cb41-26"><a href="#cb41-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb41-27"><a href="#cb41-27" aria-hidden="true" tabindex="-1"></a>        customer_id,</span>
<span id="cb41-28"><a href="#cb41-28" aria-hidden="true" tabindex="-1"></a>        <span class="fu">group_id</span>,</span>
<span id="cb41-29"><a href="#cb41-29" aria-hidden="true" tabindex="-1"></a>        <span class="fu">COUNT</span>(<span class="op">*</span>) <span class="kw">AS</span> consecutive_days_count</span>
<span id="cb41-30"><a href="#cb41-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb41-31"><a href="#cb41-31" aria-hidden="true" tabindex="-1"></a>        consecutive_days</span>
<span id="cb41-32"><a href="#cb41-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">GROUP</span> <span class="kw">BY</span> </span>
<span id="cb41-33"><a href="#cb41-33" aria-hidden="true" tabindex="-1"></a>        customer_id, <span class="fu">group_id</span></span>
<span id="cb41-34"><a href="#cb41-34" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb41-35"><a href="#cb41-35" aria-hidden="true" tabindex="-1"></a>max_consecutive_per_customer <span class="kw">AS</span> (</span>
<span id="cb41-36"><a href="#cb41-36" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Find maximum consecutive days for each customer</span></span>
<span id="cb41-37"><a href="#cb41-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb41-38"><a href="#cb41-38" aria-hidden="true" tabindex="-1"></a>        customer_id,</span>
<span id="cb41-39"><a href="#cb41-39" aria-hidden="true" tabindex="-1"></a>        <span class="fu">MAX</span>(consecutive_days_count) <span class="kw">AS</span> max_consecutive</span>
<span id="cb41-40"><a href="#cb41-40" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb41-41"><a href="#cb41-41" aria-hidden="true" tabindex="-1"></a>        consecutive_counts</span>
<span id="cb41-42"><a href="#cb41-42" aria-hidden="true" tabindex="-1"></a>    <span class="kw">GROUP</span> <span class="kw">BY</span> </span>
<span id="cb41-43"><a href="#cb41-43" aria-hidden="true" tabindex="-1"></a>        customer_id</span>
<span id="cb41-44"><a href="#cb41-44" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb41-45"><a href="#cb41-45" aria-hidden="true" tabindex="-1"></a>overall_max_consecutive <span class="kw">AS</span> (</span>
<span id="cb41-46"><a href="#cb41-46" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Find the overall maximum consecutive days</span></span>
<span id="cb41-47"><a href="#cb41-47" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb41-48"><a href="#cb41-48" aria-hidden="true" tabindex="-1"></a>        <span class="fu">MAX</span>(max_consecutive) <span class="kw">AS</span> max_consecutive</span>
<span id="cb41-49"><a href="#cb41-49" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb41-50"><a href="#cb41-50" aria-hidden="true" tabindex="-1"></a>        max_consecutive_per_customer</span>
<span id="cb41-51"><a href="#cb41-51" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb41-52"><a href="#cb41-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-53"><a href="#cb41-53" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> </span>
<span id="cb41-54"><a href="#cb41-54" aria-hidden="true" tabindex="-1"></a>    mpc.customer_id</span>
<span id="cb41-55"><a href="#cb41-55" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> </span>
<span id="cb41-56"><a href="#cb41-56" aria-hidden="true" tabindex="-1"></a>    max_consecutive_per_customer mpc</span>
<span id="cb41-57"><a href="#cb41-57" aria-hidden="true" tabindex="-1"></a><span class="kw">JOIN</span> </span>
<span id="cb41-58"><a href="#cb41-58" aria-hidden="true" tabindex="-1"></a>    overall_max_consecutive omc <span class="kw">ON</span> mpc.max_consecutive <span class="op">=</span> omc.max_consecutive</span>
<span id="cb41-59"><a href="#cb41-59" aria-hidden="true" tabindex="-1"></a><span class="kw">ORDER</span> <span class="kw">BY</span> </span>
<span id="cb41-60"><a href="#cb41-60" aria-hidden="true" tabindex="-1"></a>    mpc.customer_id;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Explanation:</strong></p>
<ul>
<li>This query identifies customers with the longest streak of consecutive days with transactions.</li>
<li>The solution uses a five-step approach with Common Table Expressions (CTEs):
<ul>
<li>The <code>daily_transactions</code> CTE aggregates multiple transactions on the same day into a single daily record.</li>
<li>The <code>consecutive_days</code> CTE uses the “islands and gaps” technique to identify groups of consecutive days.</li>
<li>The <code>consecutive_counts</code> CTE counts the number of days in each consecutive group.</li>
<li>The <code>max_consecutive_per_customer</code> CTE finds the longest streak for each customer.</li>
<li>The <code>overall_max_consecutive</code> CTE identifies the maximum streak across all customers.</li>
</ul></li>
<li>The key insight is using “transaction_date - ROW_NUMBER()” to create a constant group_id for consecutive dates.</li>
<li>The main query joins the customer maximums with the overall maximum to find customers with the longest streaks.</li>
<li>Time complexity: O(n log n) where n is the number of transactions, due to the sorting operations.</li>
<li>Space complexity: O(n) for the intermediate results.</li>
<li>This solution correctly handles edge cases:
<ul>
<li>Multiple transactions on the same day (counted as one day in the streak)</li>
<li>Multiple streaks for the same customer (only the longest is considered)</li>
<li>Multiple customers with the same maximum streak length (all are included)</li>
</ul></li>
<li>For large datasets, indexes on customer_id and transaction_date would improve performance.</li>
<li>The GROUP BY in daily_transactions ensures multiple transactions on the same day are counted as one day.</li>
<li>The ROW_NUMBER() window function partitions by customer_id to track streaks for each customer separately.</li>
<li>The approach efficiently identifies consecutive day sequences without recursive queries.</li>
<li>The solution follows the requirement to order results by customer_id.</li>
<li>The JOIN with overall_max_consecutive ensures only customers with the maximum streak are included.</li>
<li>The ::integer cast ensures proper date arithmetic when calculating group_id.</li>
</ul>
</section>
<section id="status-of-flight-tickets" class="level4">
<h4 class="anchored" data-anchor-id="status-of-flight-tickets">2793. Status of Flight Tickets</h4>
<p><strong>Description:</strong></p>
<table class="caption-top table">
<caption>Flights</caption>
<colgroup>
<col style="width: 19%">
<col style="width: 9%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>flight_id capacity</td>
<td>int int</td>
</tr>
</tbody>
</table>
<p>flight_id is the primary key for this table. Each row of this table contains flight id and the capacity.</p>
<table class="caption-top table">
<caption>Passengers</caption>
<colgroup>
<col style="width: 20%">
<col style="width: 9%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>passenger_id flight_id booking_time</td>
<td>int int date</td>
</tr>
</tbody>
</table>
<p>passenger_id is the primary key for this table. The booking_time represents when the passenger booked the ticket. each passenger book at most 1 flight.</p>
<p>Write an SQL query to report the status of each flight and the last passenger who booked a ticket on the flight.</p>
<p>Return the result table ordered by status and flight_id.</p>
<p>status should be as follows: - If the flight still has capacity, the status is “Available”. - Otherwise, status is “Booked”, and you need to include the passenger_id of the last passenger who booked the last ticket of the flight.</p>
<p><strong>Solution:</strong></p>
<div class="sourceCode" id="cb42"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="kw">WITH</span> flight_bookings <span class="kw">AS</span> (</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>        f.flight_id,</span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>        f.capacity,</span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>        <span class="fu">COUNT</span>(p.passenger_id) <span class="kw">AS</span> booked_count,</span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>        <span class="fu">MAX</span>(p.booking_time) <span class="kw">AS</span> last_booking_time</span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>        Flights f</span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">LEFT</span> <span class="kw">JOIN</span> </span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a>        Passengers p <span class="kw">ON</span> f.flight_id <span class="op">=</span> p.flight_id</span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">GROUP</span> <span class="kw">BY</span> </span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a>        f.flight_id, f.capacity</span>
<span id="cb42-13"><a href="#cb42-13" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb42-14"><a href="#cb42-14" aria-hidden="true" tabindex="-1"></a>last_passengers <span class="kw">AS</span> (</span>
<span id="cb42-15"><a href="#cb42-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb42-16"><a href="#cb42-16" aria-hidden="true" tabindex="-1"></a>        p.flight_id,</span>
<span id="cb42-17"><a href="#cb42-17" aria-hidden="true" tabindex="-1"></a>        p.passenger_id,</span>
<span id="cb42-18"><a href="#cb42-18" aria-hidden="true" tabindex="-1"></a>        p.booking_time</span>
<span id="cb42-19"><a href="#cb42-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb42-20"><a href="#cb42-20" aria-hidden="true" tabindex="-1"></a>        Passengers p</span>
<span id="cb42-21"><a href="#cb42-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">JOIN</span> </span>
<span id="cb42-22"><a href="#cb42-22" aria-hidden="true" tabindex="-1"></a>        flight_bookings fb <span class="kw">ON</span> p.flight_id <span class="op">=</span> fb.flight_id <span class="kw">AND</span> p.booking_time <span class="op">=</span> fb.last_booking_time</span>
<span id="cb42-23"><a href="#cb42-23" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb42-24"><a href="#cb42-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-25"><a href="#cb42-25" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> </span>
<span id="cb42-26"><a href="#cb42-26" aria-hidden="true" tabindex="-1"></a>    fb.flight_id,</span>
<span id="cb42-27"><a href="#cb42-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">CASE</span> </span>
<span id="cb42-28"><a href="#cb42-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">WHEN</span> fb.booked_count <span class="op">&lt;</span> fb.capacity <span class="cf">THEN</span> <span class="st">'Available'</span></span>
<span id="cb42-29"><a href="#cb42-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">ELSE</span> <span class="st">'Booked'</span></span>
<span id="cb42-30"><a href="#cb42-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">END</span> <span class="kw">AS</span> status,</span>
<span id="cb42-31"><a href="#cb42-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">CASE</span> </span>
<span id="cb42-32"><a href="#cb42-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">WHEN</span> fb.booked_count <span class="op">&gt;=</span> fb.capacity <span class="cf">THEN</span> lp.passenger_id</span>
<span id="cb42-33"><a href="#cb42-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">ELSE</span> <span class="kw">NULL</span></span>
<span id="cb42-34"><a href="#cb42-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">END</span> <span class="kw">AS</span> last_passenger_id</span>
<span id="cb42-35"><a href="#cb42-35" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> </span>
<span id="cb42-36"><a href="#cb42-36" aria-hidden="true" tabindex="-1"></a>    flight_bookings fb</span>
<span id="cb42-37"><a href="#cb42-37" aria-hidden="true" tabindex="-1"></a><span class="kw">LEFT</span> <span class="kw">JOIN</span> </span>
<span id="cb42-38"><a href="#cb42-38" aria-hidden="true" tabindex="-1"></a>    last_passengers lp <span class="kw">ON</span> fb.flight_id <span class="op">=</span> lp.flight_id</span>
<span id="cb42-39"><a href="#cb42-39" aria-hidden="true" tabindex="-1"></a><span class="kw">ORDER</span> <span class="kw">BY</span> </span>
<span id="cb42-40"><a href="#cb42-40" aria-hidden="true" tabindex="-1"></a>    status, fb.flight_id;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Explanation:</strong></p>
<ul>
<li>This query determines the status of each flight based on its capacity and bookings, and identifies the last passenger to book a ticket on full flights.</li>
<li>The solution uses a two-step approach with Common Table Expressions (CTEs):
<ul>
<li>The <code>flight_bookings</code> CTE calculates the number of bookings for each flight and identifies the time of the last booking.</li>
<li>The <code>last_passengers</code> CTE identifies the passenger(s) who made the last booking for each flight.</li>
</ul></li>
<li>The main query then determines the status of each flight based on capacity and includes the last passenger ID for fully booked flights.</li>
<li>The CASE expressions handle the status determination and conditional inclusion of the last passenger ID.</li>
<li>Time complexity: O(n log n) where n is the number of passengers, due to the sorting and grouping operations.</li>
<li>Space complexity: O(f) where f is the number of flights.</li>
<li>This solution correctly handles edge cases:
<ul>
<li>Flights with no bookings (status will be “Available”)</li>
<li>Flights with multiple passengers booking at the same time (joins will match multiple rows)</li>
</ul></li>
<li>For large datasets, indexes on flight_id and booking_time would improve performance.</li>
<li>The LEFT JOIN in flight_bookings ensures all flights are included, even those with no bookings.</li>
<li>The JOIN in last_passengers matches the last booking time to identify the correct passenger.</li>
<li>The status determination compares booked_count with capacity to accurately categorize flights.</li>
<li>The solution follows the requirement to order results by status and flight_id.</li>
<li>The approach efficiently combines aggregate functions with joins to solve the problem.</li>
<li>The LEFT JOIN in the main query ensures all flights appear in the result, even if the flight has no “last passenger”.</li>
</ul>
</section>
<section id="top-three-wineries" class="level4">
<h4 class="anchored" data-anchor-id="top-three-wineries">2991. Top Three Wineries</h4>
<p><strong>Description:</strong></p>
<table class="caption-top table">
<caption>Wineries</caption>
<colgroup>
<col style="width: 22%">
<col style="width: 13%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>winery_id country points</td>
<td>int varchar int</td>
</tr>
</tbody>
</table>
<p>winery_id is the primary key for this table. Each row in this table shows a winery and its average points.</p>
<p>Write an SQL query to find the top three wineries in each country based on their points. If there is a tie for the third position, choose all tied wineries. If there are fewer than three wineries in a country, include all of them.</p>
<p>Return the result table ordered by country in ascending order and points in descending order for each country.</p>
<p><strong>Solution:</strong></p>
<div class="sourceCode" id="cb43"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="kw">WITH</span> ranked_wineries <span class="kw">AS</span> (</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>        winery_id,</span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>        country,</span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>        points,</span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>        <span class="fu">DENSE_RANK</span>() <span class="kw">OVER</span> (</span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>            <span class="kw">PARTITION</span> <span class="kw">BY</span> country </span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a>            <span class="kw">ORDER</span> <span class="kw">BY</span> points <span class="kw">DESC</span></span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a>        ) <span class="kw">AS</span> country_rank</span>
<span id="cb43-10"><a href="#cb43-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb43-11"><a href="#cb43-11" aria-hidden="true" tabindex="-1"></a>        Wineries</span>
<span id="cb43-12"><a href="#cb43-12" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb43-13"><a href="#cb43-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-14"><a href="#cb43-14" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> </span>
<span id="cb43-15"><a href="#cb43-15" aria-hidden="true" tabindex="-1"></a>    winery_id,</span>
<span id="cb43-16"><a href="#cb43-16" aria-hidden="true" tabindex="-1"></a>    country,</span>
<span id="cb43-17"><a href="#cb43-17" aria-hidden="true" tabindex="-1"></a>    points</span>
<span id="cb43-18"><a href="#cb43-18" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> </span>
<span id="cb43-19"><a href="#cb43-19" aria-hidden="true" tabindex="-1"></a>    ranked_wineries</span>
<span id="cb43-20"><a href="#cb43-20" aria-hidden="true" tabindex="-1"></a><span class="kw">WHERE</span> </span>
<span id="cb43-21"><a href="#cb43-21" aria-hidden="true" tabindex="-1"></a>    country_rank <span class="op">&lt;=</span> <span class="dv">3</span></span>
<span id="cb43-22"><a href="#cb43-22" aria-hidden="true" tabindex="-1"></a><span class="kw">ORDER</span> <span class="kw">BY</span> </span>
<span id="cb43-23"><a href="#cb43-23" aria-hidden="true" tabindex="-1"></a>    country, points <span class="kw">DESC</span>, winery_id;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Explanation:</strong></p>
<ul>
<li>This query identifies the top three wineries in each country based on their points.</li>
<li>The solution uses a single Common Table Expression (CTE) with a window function:
<ul>
<li>The <code>ranked_wineries</code> CTE assigns a rank to each winery within its country using DENSE_RANK().</li>
<li>DENSE_RANK() ensures tied wineries receive the same rank, which is crucial for handling ties.</li>
</ul></li>
<li>The main query then filters for wineries with rank &lt;= 3 to get the top three in each country.</li>
<li>Time complexity: O(n log n) where n is the number of wineries, due to the sorting operations.</li>
<li>Space complexity: O(n) for the ranked wineries.</li>
<li>This solution correctly handles edge cases:
<ul>
<li>Ties for third place (all tied wineries are included)</li>
<li>Countries with fewer than three wineries (all are included)</li>
<li>Multiple wineries with the same points (all receive the same rank)</li>
</ul></li>
<li>For large datasets, indexes on country and points would improve performance.</li>
<li>DENSE_RANK() is specifically chosen over RANK() or ROW_NUMBER() because:
<ul>
<li>Unlike ROW_NUMBER(), it assigns the same rank to ties</li>
<li>Unlike RANK(), it doesn’t skip ranks after ties, ensuring we get exactly the top three positions</li>
</ul></li>
<li>The ORDER BY clause in the main query ensures results are sorted by country ascending and points descending as required.</li>
<li>The approach efficiently combines partitioning and ordering within the window function.</li>
<li>The solution is concise and directly focuses on the ranking requirement without complex subqueries.</li>
<li>The addition of winery_id in the final ORDER BY ensures consistent results when multiple wineries have the same country and points.</li>
</ul>
</section>
<section id="employees-project-allocation" class="level4">
<h4 class="anchored" data-anchor-id="employees-project-allocation">3057. Employees Project Allocation</h4>
<p><strong>Description:</strong></p>
<table class="caption-top table">
<caption>Employees</caption>
<colgroup>
<col style="width: 19%">
<col style="width: 13%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>emp_id emp_name team_id</td>
<td>int varchar int</td>
</tr>
</tbody>
</table>
<p>emp_id is the primary key for this table. Each row of this table contains emp_id, emp_name, and team_id.</p>
<table class="caption-top table">
<caption>Projects</caption>
<colgroup>
<col style="width: 19%">
<col style="width: 9%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>project_id team_id capacity</td>
<td>int int int</td>
</tr>
</tbody>
</table>
<p>project_id is the primary key for this table. Each row of this table contains project_id, team_id, and capacity of the project.</p>
<p>Write an SQL query to calculate employee allocations. The allocation is the number of projects that an employee can participate in, limited by the capacity of each project.</p>
<ul>
<li>Each team is in charge of zero or more projects.</li>
<li>Each employee belongs to exactly one team.</li>
<li>The team cannot exceed the capacity of each project it participates in.</li>
<li>Each employee at most participates in one project. If there are no projects or the capacity is not enough, some employees may not have any allocated projects.</li>
</ul>
<p>Return the result table ordered by emp_id in ascending order.</p>
<p><strong>Solution:</strong></p>
<div class="sourceCode" id="cb44"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="kw">WITH</span> team_projects <span class="kw">AS</span> (</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>        p.project_id,</span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>        p.team_id,</span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>        p.capacity,</span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a>        <span class="fu">COUNT</span>(e.emp_id) <span class="kw">OVER</span> (<span class="kw">PARTITION</span> <span class="kw">BY</span> e.team_id) <span class="kw">AS</span> team_size,</span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a>        <span class="fu">ROW_NUMBER</span>() <span class="kw">OVER</span> (<span class="kw">PARTITION</span> <span class="kw">BY</span> p.team_id <span class="kw">ORDER</span> <span class="kw">BY</span> p.capacity <span class="kw">DESC</span>) <span class="kw">AS</span> project_priority</span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a>        Projects p</span>
<span id="cb44-10"><a href="#cb44-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">JOIN</span> </span>
<span id="cb44-11"><a href="#cb44-11" aria-hidden="true" tabindex="-1"></a>        Employees e <span class="kw">ON</span> p.team_id <span class="op">=</span> e.team_id</span>
<span id="cb44-12"><a href="#cb44-12" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb44-13"><a href="#cb44-13" aria-hidden="true" tabindex="-1"></a>employee_ranks <span class="kw">AS</span> (</span>
<span id="cb44-14"><a href="#cb44-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb44-15"><a href="#cb44-15" aria-hidden="true" tabindex="-1"></a>        e.emp_id,</span>
<span id="cb44-16"><a href="#cb44-16" aria-hidden="true" tabindex="-1"></a>        e.emp_name,</span>
<span id="cb44-17"><a href="#cb44-17" aria-hidden="true" tabindex="-1"></a>        e.team_id,</span>
<span id="cb44-18"><a href="#cb44-18" aria-hidden="true" tabindex="-1"></a>        <span class="fu">ROW_NUMBER</span>() <span class="kw">OVER</span> (<span class="kw">PARTITION</span> <span class="kw">BY</span> e.team_id <span class="kw">ORDER</span> <span class="kw">BY</span> e.emp_id) <span class="kw">AS</span> emp_rank</span>
<span id="cb44-19"><a href="#cb44-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb44-20"><a href="#cb44-20" aria-hidden="true" tabindex="-1"></a>        Employees e</span>
<span id="cb44-21"><a href="#cb44-21" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb44-22"><a href="#cb44-22" aria-hidden="true" tabindex="-1"></a>project_allocation <span class="kw">AS</span> (</span>
<span id="cb44-23"><a href="#cb44-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb44-24"><a href="#cb44-24" aria-hidden="true" tabindex="-1"></a>        tp.project_id,</span>
<span id="cb44-25"><a href="#cb44-25" aria-hidden="true" tabindex="-1"></a>        tp.team_id,</span>
<span id="cb44-26"><a href="#cb44-26" aria-hidden="true" tabindex="-1"></a>        tp.capacity,</span>
<span id="cb44-27"><a href="#cb44-27" aria-hidden="true" tabindex="-1"></a>        <span class="fu">LEAST</span>(tp.capacity, tp.team_size) <span class="kw">AS</span> allocated_count</span>
<span id="cb44-28"><a href="#cb44-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb44-29"><a href="#cb44-29" aria-hidden="true" tabindex="-1"></a>        team_projects tp</span>
<span id="cb44-30"><a href="#cb44-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">WHERE</span> </span>
<span id="cb44-31"><a href="#cb44-31" aria-hidden="true" tabindex="-1"></a>        tp.project_priority <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb44-32"><a href="#cb44-32" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb44-33"><a href="#cb44-33" aria-hidden="true" tabindex="-1"></a>employee_allocation <span class="kw">AS</span> (</span>
<span id="cb44-34"><a href="#cb44-34" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb44-35"><a href="#cb44-35" aria-hidden="true" tabindex="-1"></a>        er.emp_id,</span>
<span id="cb44-36"><a href="#cb44-36" aria-hidden="true" tabindex="-1"></a>        er.emp_name,</span>
<span id="cb44-37"><a href="#cb44-37" aria-hidden="true" tabindex="-1"></a>        pa.project_id</span>
<span id="cb44-38"><a href="#cb44-38" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb44-39"><a href="#cb44-39" aria-hidden="true" tabindex="-1"></a>        employee_ranks er</span>
<span id="cb44-40"><a href="#cb44-40" aria-hidden="true" tabindex="-1"></a>    <span class="kw">LEFT</span> <span class="kw">JOIN</span> </span>
<span id="cb44-41"><a href="#cb44-41" aria-hidden="true" tabindex="-1"></a>        project_allocation pa <span class="kw">ON</span> er.team_id <span class="op">=</span> pa.team_id</span>
<span id="cb44-42"><a href="#cb44-42" aria-hidden="true" tabindex="-1"></a>    <span class="kw">WHERE</span> </span>
<span id="cb44-43"><a href="#cb44-43" aria-hidden="true" tabindex="-1"></a>        pa.project_id <span class="kw">IS</span> <span class="kw">NOT</span> <span class="kw">NULL</span> <span class="kw">AND</span> er.emp_rank <span class="op">&lt;=</span> pa.allocated_count</span>
<span id="cb44-44"><a href="#cb44-44" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb44-45"><a href="#cb44-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-46"><a href="#cb44-46" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> </span>
<span id="cb44-47"><a href="#cb44-47" aria-hidden="true" tabindex="-1"></a>    e.emp_id,</span>
<span id="cb44-48"><a href="#cb44-48" aria-hidden="true" tabindex="-1"></a>    e.emp_name,</span>
<span id="cb44-49"><a href="#cb44-49" aria-hidden="true" tabindex="-1"></a>    ea.project_id</span>
<span id="cb44-50"><a href="#cb44-50" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> </span>
<span id="cb44-51"><a href="#cb44-51" aria-hidden="true" tabindex="-1"></a>    Employees e</span>
<span id="cb44-52"><a href="#cb44-52" aria-hidden="true" tabindex="-1"></a><span class="kw">LEFT</span> <span class="kw">JOIN</span> </span>
<span id="cb44-53"><a href="#cb44-53" aria-hidden="true" tabindex="-1"></a>    employee_allocation ea <span class="kw">ON</span> e.emp_id <span class="op">=</span> ea.emp_id</span>
<span id="cb44-54"><a href="#cb44-54" aria-hidden="true" tabindex="-1"></a><span class="kw">ORDER</span> <span class="kw">BY</span> </span>
<span id="cb44-55"><a href="#cb44-55" aria-hidden="true" tabindex="-1"></a>    e.emp_id;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Explanation:</strong></p>
<ul>
<li>This query allocates employees to projects based on project capacity and team assignments.</li>
<li>The solution uses a multi-step approach with Common Table Expressions (CTEs):
<ul>
<li>The <code>team_projects</code> CTE calculates team sizes and ranks projects by capacity for each team.</li>
<li>The <code>employee_ranks</code> CTE assigns a rank to each employee within their team.</li>
<li>The <code>project_allocation</code> CTE determines how many employees can be allocated to each project.</li>
<li>The <code>employee_allocation</code> CTE matches employees to projects based on their rank and project allocation.</li>
</ul></li>
<li>The LEAST function ensures project allocations don’t exceed capacity.</li>
<li>The main query joins all employees with their allocations, ensuring all employees appear in the results.</li>
<li>Time complexity: O(n log n) where n is the number of employees, due to the sorting operations.</li>
<li>Space complexity: O(n + p) where p is the number of projects.</li>
<li>This solution correctly handles edge cases:
<ul>
<li>Teams with no projects (employees remain unallocated)</li>
<li>Projects with capacity less than team size (only some employees are allocated)</li>
<li>Employees with no allocated project (show NULL for project_id)</li>
</ul></li>
<li>For large datasets, indexes on team_id, emp_id, and project_id would improve performance.</li>
<li>The ROW_NUMBER() functions efficiently rank both employees and projects for allocation.</li>
<li>The WHERE clause in employee_allocation ensures only employees within the allocated count are assigned projects.</li>
<li>The LEFT JOIN in the main query ensures all employees appear in the result, even those without allocated projects.</li>
<li>The solution follows the requirement to order results by emp_id.</li>
<li>The approach efficiently models the allocation constraints using a combination of window functions and joins.</li>
<li>The project_priority ranking ensures teams prioritize projects with larger capacity first.</li>
</ul>
</section>
<section id="user-activities-within-time-bounds" class="level4">
<h4 class="anchored" data-anchor-id="user-activities-within-time-bounds">3060. User Activities within Time Bounds</h4>
<p><strong>Description:</strong></p>
<table class="caption-top table">
<caption>UserActivity</caption>
<colgroup>
<col style="width: 19%">
<col style="width: 9%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>user_id activity timestamp</td>
<td>int int date</td>
</tr>
</tbody>
</table>
<p>(user_id, timestamp) is the primary key for this table. Each row contains the user’s id, the activity they performed, and the timestamp of the activity.</p>
<p>Write an SQL query to find, for each user, the activity they performed just after the first occurrence of a specific activity and within a specific time frame.</p>
<p>For each user who performed activity 2 at least once, find the activity they performed right after their first occurrence of activity 2, if it’s within 30 days. If there is no next activity within 30 days, then for that user, the result is null.</p>
<p>Return the result table containing user_id and the next_activity. You may return the result table in any order.</p>
<p><strong>Solution:</strong></p>
<div class="sourceCode" id="cb45"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="kw">WITH</span> first_activity_2 <span class="kw">AS</span> (</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>        user_id,</span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">timestamp</span> <span class="kw">AS</span> first_a2_timestamp</span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a>        UserActivity</span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">WHERE</span> </span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a>        activity <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">GROUP</span> <span class="kw">BY</span> </span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true" tabindex="-1"></a>        user_id</span>
<span id="cb45-11"><a href="#cb45-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">HAVING</span> </span>
<span id="cb45-12"><a href="#cb45-12" aria-hidden="true" tabindex="-1"></a>        <span class="dt">timestamp</span> <span class="op">=</span> <span class="fu">MIN</span>(<span class="dt">timestamp</span>)</span>
<span id="cb45-13"><a href="#cb45-13" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb45-14"><a href="#cb45-14" aria-hidden="true" tabindex="-1"></a>next_activities <span class="kw">AS</span> (</span>
<span id="cb45-15"><a href="#cb45-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb45-16"><a href="#cb45-16" aria-hidden="true" tabindex="-1"></a>        ua.user_id,</span>
<span id="cb45-17"><a href="#cb45-17" aria-hidden="true" tabindex="-1"></a>        ua.activity,</span>
<span id="cb45-18"><a href="#cb45-18" aria-hidden="true" tabindex="-1"></a>        ua.<span class="dt">timestamp</span>,</span>
<span id="cb45-19"><a href="#cb45-19" aria-hidden="true" tabindex="-1"></a>        fa.first_a2_timestamp,</span>
<span id="cb45-20"><a href="#cb45-20" aria-hidden="true" tabindex="-1"></a>        <span class="fu">ROW_NUMBER</span>() <span class="kw">OVER</span> (</span>
<span id="cb45-21"><a href="#cb45-21" aria-hidden="true" tabindex="-1"></a>            <span class="kw">PARTITION</span> <span class="kw">BY</span> ua.user_id </span>
<span id="cb45-22"><a href="#cb45-22" aria-hidden="true" tabindex="-1"></a>            <span class="kw">ORDER</span> <span class="kw">BY</span> ua.<span class="dt">timestamp</span></span>
<span id="cb45-23"><a href="#cb45-23" aria-hidden="true" tabindex="-1"></a>        ) <span class="kw">AS</span> activity_rank</span>
<span id="cb45-24"><a href="#cb45-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb45-25"><a href="#cb45-25" aria-hidden="true" tabindex="-1"></a>        UserActivity ua</span>
<span id="cb45-26"><a href="#cb45-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">JOIN</span> </span>
<span id="cb45-27"><a href="#cb45-27" aria-hidden="true" tabindex="-1"></a>        first_activity_2 fa <span class="kw">ON</span> ua.user_id <span class="op">=</span> fa.user_id</span>
<span id="cb45-28"><a href="#cb45-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">WHERE</span> </span>
<span id="cb45-29"><a href="#cb45-29" aria-hidden="true" tabindex="-1"></a>        ua.<span class="dt">timestamp</span> <span class="op">&gt;</span> fa.first_a2_timestamp <span class="kw">AND</span> </span>
<span id="cb45-30"><a href="#cb45-30" aria-hidden="true" tabindex="-1"></a>        ua.<span class="dt">timestamp</span> <span class="op">&lt;=</span> fa.first_a2_timestamp <span class="op">+</span> <span class="dt">INTERVAL</span> <span class="st">'30 days'</span></span>
<span id="cb45-31"><a href="#cb45-31" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb45-32"><a href="#cb45-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-33"><a href="#cb45-33" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> </span>
<span id="cb45-34"><a href="#cb45-34" aria-hidden="true" tabindex="-1"></a>    fa.user_id,</span>
<span id="cb45-35"><a href="#cb45-35" aria-hidden="true" tabindex="-1"></a>    na.activity <span class="kw">AS</span> next_activity</span>
<span id="cb45-36"><a href="#cb45-36" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> </span>
<span id="cb45-37"><a href="#cb45-37" aria-hidden="true" tabindex="-1"></a>    first_activity_2 fa</span>
<span id="cb45-38"><a href="#cb45-38" aria-hidden="true" tabindex="-1"></a><span class="kw">LEFT</span> <span class="kw">JOIN</span> </span>
<span id="cb45-39"><a href="#cb45-39" aria-hidden="true" tabindex="-1"></a>    next_activities na <span class="kw">ON</span> fa.user_id <span class="op">=</span> na.user_id <span class="kw">AND</span> na.activity_rank <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb45-40"><a href="#cb45-40" aria-hidden="true" tabindex="-1"></a><span class="kw">ORDER</span> <span class="kw">BY</span> </span>
<span id="cb45-41"><a href="#cb45-41" aria-hidden="true" tabindex="-1"></a>    fa.user_id;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Explanation:</strong></p>
<ul>
<li>This query finds the activity each user performed immediately after their first occurrence of activity 2, if within 30 days.</li>
<li>The solution uses a two-step approach with Common Table Expressions (CTEs):
<ul>
<li>The <code>first_activity_2</code> CTE identifies the timestamp of each user’s first occurrence of activity 2.</li>
<li>The <code>next_activities</code> CTE finds all activities that occurred after the first activity 2 and within 30 days.</li>
</ul></li>
<li>ROW_NUMBER() assigns a rank to each subsequent activity, with rank 1 being the first activity after activity 2.</li>
<li>The main query joins the first activity timestamps with the next activities, filtering for just the immediately following activity.</li>
<li>The INTERVAL ‘30 days’ syntax is used for date arithmetic to establish the 30-day time window.</li>
<li>The LEFT JOIN ensures all users with activity 2 appear in the results, even those with no subsequent activity in the time window.</li>
<li>Time complexity: O(n log n) where n is the number of activities, due to the sorting operations.</li>
<li>Space complexity: O(u) where u is the number of users with activity 2.</li>
<li>This solution correctly handles edge cases:
<ul>
<li>Users with no activities after their first activity 2 (null result)</li>
<li>Users with activities after 30 days (excluded from results)</li>
<li>Users who never performed activity 2 (excluded from first_activity_2)</li>
</ul></li>
<li>For large datasets, indexes on user_id, activity, and timestamp would improve performance.</li>
<li>The GROUP BY with HAVING in first_activity_2 efficiently finds the first occurrence of activity 2 for each user.</li>
<li>The WHERE clause in next_activities applies the time bound constraints directly.</li>
<li>The solution follows a logical flow from finding the reference point (first activity 2) to identifying the next activity within the time window.</li>
<li>The approach properly handles the time window requirement using PostgreSQL’s date arithmetic.</li>
<li>The activity_rank = 1 condition ensures only the immediately following activity is selected.</li>
</ul>
</section>
<section id="calculate-trapping-rain-water" class="level4">
<h4 class="anchored" data-anchor-id="calculate-trapping-rain-water">3061. Calculate Trapping Rain Water</h4>
<p><strong>Description:</strong></p>
<table class="caption-top table">
<caption>Heights</caption>
<colgroup>
<col style="width: 19%">
<col style="width: 9%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>id height</td>
<td>int int</td>
</tr>
</tbody>
</table>
<p>id is the primary key for this table. Each row of this table contains an id and a height. There are no consecutive identical heights.</p>
<p>Write an SQL query to calculate the amount of water that can be trapped after raining.</p>
<p>The query result is in the following format:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 19%">
</colgroup>
<tbody>
<tr class="odd">
<td>total_water</td>
</tr>
<tr class="even">
<td>6</td>
</tr>
</tbody>
</table>
<p>For details on the calculation, see the LeetCode “Trapping Rain Water” problem.</p>
<p><strong>Solution:</strong></p>
<div class="sourceCode" id="cb46"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="kw">WITH</span> height_bounds <span class="kw">AS</span> (</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>        h.<span class="kw">id</span>,</span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>        h.height,</span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a>        (<span class="kw">SELECT</span> <span class="fu">MAX</span>(height) <span class="kw">FROM</span> Heights h2 <span class="kw">WHERE</span> h2.<span class="kw">id</span> <span class="op">&lt;=</span> h.<span class="kw">id</span>) <span class="kw">AS</span> left_max,</span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a>        (<span class="kw">SELECT</span> <span class="fu">MAX</span>(height) <span class="kw">FROM</span> Heights h2 <span class="kw">WHERE</span> h2.<span class="kw">id</span> <span class="op">&gt;=</span> h.<span class="kw">id</span>) <span class="kw">AS</span> right_max</span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a>        Heights h</span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true" tabindex="-1"></a>water_heights <span class="kw">AS</span> (</span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb46-12"><a href="#cb46-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">id</span>,</span>
<span id="cb46-13"><a href="#cb46-13" aria-hidden="true" tabindex="-1"></a>        height,</span>
<span id="cb46-14"><a href="#cb46-14" aria-hidden="true" tabindex="-1"></a>        <span class="fu">LEAST</span>(left_max, right_max) <span class="kw">AS</span> water_level,</span>
<span id="cb46-15"><a href="#cb46-15" aria-hidden="true" tabindex="-1"></a>        <span class="fu">GREATEST</span>(<span class="dv">0</span>, <span class="fu">LEAST</span>(left_max, right_max) <span class="op">-</span> height) <span class="kw">AS</span> water_at_position</span>
<span id="cb46-16"><a href="#cb46-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb46-17"><a href="#cb46-17" aria-hidden="true" tabindex="-1"></a>        height_bounds</span>
<span id="cb46-18"><a href="#cb46-18" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb46-19"><a href="#cb46-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-20"><a href="#cb46-20" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> </span>
<span id="cb46-21"><a href="#cb46-21" aria-hidden="true" tabindex="-1"></a>    <span class="fu">SUM</span>(water_at_position) <span class="kw">AS</span> total_water</span>
<span id="cb46-22"><a href="#cb46-22" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> </span>
<span id="cb46-23"><a href="#cb46-23" aria-hidden="true" tabindex="-1"></a>    water_heights;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Explanation:</strong></p>
<ul>
<li>This query calculates the total amount of water that can be trapped between elevation heights, a classic algorithmic problem.</li>
<li>The solution uses a two-step approach with Common Table Expressions (CTEs):
<ul>
<li>The <code>height_bounds</code> CTE calculates the maximum height to the left and right of each position.</li>
<li>The <code>water_heights</code> CTE calculates the water level and amount of water at each position.</li>
</ul></li>
<li>For each position, the water level is determined by the minimum of the maximum heights to the left and right.</li>
<li>The water at each position is the difference between the water level and the height at that position (or 0 if negative).</li>
<li>The correlated subqueries efficiently find the maximum heights in each direction.</li>
<li>The main query sums the water at each position to get the total trapped water.</li>
<li>Time complexity: O(n²) where n is the number of heights, due to the correlated subqueries.</li>
<li>Space complexity: O(n) for the intermediate results.</li>
<li>This solution correctly implements the “Trapping Rain Water” algorithm:
<ul>
<li>Water can only be trapped between higher elevations</li>
<li>The water level at each position is limited by the lower of the maximum heights to the left and right</li>
<li>No water is trapped at the highest points</li>
</ul></li>
<li>For large datasets, a dynamic programming approach with window functions could be more efficient.</li>
<li>The LEAST function ensures we use the lower of the two maximum heights to determine the water level.</li>
<li>The GREATEST function ensures we don’t count negative water (when a position is higher than the water level).</li>
<li>The approach directly translates the algorithmic solution to SQL, demonstrating SQL’s ability to solve complex problems.</li>
<li>Alternative approaches could use window functions to calculate left_max and right_max more efficiently, but this solution is more readable.</li>
<li>The solution handles edge cases where no water is trapped (returns 0) and where water is trapped at multiple positions.</li>
</ul>
</section>
<section id="find-trending-hashtags-ii" class="level4">
<h4 class="anchored" data-anchor-id="find-trending-hashtags-ii">3103. Find Trending Hashtags II</h4>
<p><strong>Description:</strong></p>
<table class="caption-top table">
<caption>Posts</caption>
<colgroup>
<col style="width: 19%">
<col style="width: 9%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>post_id user_id content created_at</td>
<td>int int text date</td>
</tr>
</tbody>
</table>
<p>post_id is the primary key for this table. Each row of this table contains post_id, user_id, content, and created_at.</p>
<p>Write an SQL query to find the top 3 trending hashtags in February 2024. A hashtag is a word beginning with the ‘#’ symbol.</p>
<ul>
<li>A hashtag’s word length is the number of characters it contains excluding the ‘#’ symbol.</li>
<li>To extract hashtags from the content of a post, you need to find all words that start with ‘#’ followed by one or more non-space characters. The hashtag ends when a space or the end of the content is encountered.</li>
<li>If there are fewer than 3 trending hashtags, return all of them. If multiple hashtags have the same frequency, prioritize the alphabetically smaller ones.</li>
</ul>
<p>Return the result table ordered by frequency in descending order and hashtag in ascending order for equal frequency.</p>
<p><strong>Solution:</strong></p>
<div class="sourceCode" id="cb47"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="kw">WITH</span> content_with_hashtags <span class="kw">AS</span> (</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>        post_id,</span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>        user_id,</span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>        created_at,</span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a>        regexp_matches(content, <span class="st">'#([^ ]+)'</span>, <span class="st">'g'</span>) <span class="kw">AS</span> hashtag</span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a>        Posts</span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">WHERE</span> </span>
<span id="cb47-10"><a href="#cb47-10" aria-hidden="true" tabindex="-1"></a>        created_at <span class="op">&gt;=</span> <span class="st">'2024-02-01'</span> <span class="kw">AND</span></span>
<span id="cb47-11"><a href="#cb47-11" aria-hidden="true" tabindex="-1"></a>        created_at <span class="op">&lt;</span> <span class="st">'2024-03-01'</span></span>
<span id="cb47-12"><a href="#cb47-12" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb47-13"><a href="#cb47-13" aria-hidden="true" tabindex="-1"></a>extracted_hashtags <span class="kw">AS</span> (</span>
<span id="cb47-14"><a href="#cb47-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb47-15"><a href="#cb47-15" aria-hidden="true" tabindex="-1"></a>        post_id,</span>
<span id="cb47-16"><a href="#cb47-16" aria-hidden="true" tabindex="-1"></a>        user_id,</span>
<span id="cb47-17"><a href="#cb47-17" aria-hidden="true" tabindex="-1"></a>        created_at,</span>
<span id="cb47-18"><a href="#cb47-18" aria-hidden="true" tabindex="-1"></a>        <span class="fu">lower</span>(<span class="st">'#'</span> <span class="op">||</span> hashtag[<span class="dv">1</span>]) <span class="kw">AS</span> hashtag_text</span>
<span id="cb47-19"><a href="#cb47-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb47-20"><a href="#cb47-20" aria-hidden="true" tabindex="-1"></a>        content_with_hashtags</span>
<span id="cb47-21"><a href="#cb47-21" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb47-22"><a href="#cb47-22" aria-hidden="true" tabindex="-1"></a>hashtag_counts <span class="kw">AS</span> (</span>
<span id="cb47-23"><a href="#cb47-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb47-24"><a href="#cb47-24" aria-hidden="true" tabindex="-1"></a>        hashtag_text,</span>
<span id="cb47-25"><a href="#cb47-25" aria-hidden="true" tabindex="-1"></a>        <span class="fu">COUNT</span>(<span class="op">*</span>) <span class="kw">AS</span> frequency</span>
<span id="cb47-26"><a href="#cb47-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb47-27"><a href="#cb47-27" aria-hidden="true" tabindex="-1"></a>        extracted_hashtags</span>
<span id="cb47-28"><a href="#cb47-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">GROUP</span> <span class="kw">BY</span> </span>
<span id="cb47-29"><a href="#cb47-29" aria-hidden="true" tabindex="-1"></a>        hashtag_text</span>
<span id="cb47-30"><a href="#cb47-30" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb47-31"><a href="#cb47-31" aria-hidden="true" tabindex="-1"></a>ranked_hashtags <span class="kw">AS</span> (</span>
<span id="cb47-32"><a href="#cb47-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb47-33"><a href="#cb47-33" aria-hidden="true" tabindex="-1"></a>        hashtag_text,</span>
<span id="cb47-34"><a href="#cb47-34" aria-hidden="true" tabindex="-1"></a>        frequency,</span>
<span id="cb47-35"><a href="#cb47-35" aria-hidden="true" tabindex="-1"></a>        <span class="fu">ROW_NUMBER</span>() <span class="kw">OVER</span> (</span>
<span id="cb47-36"><a href="#cb47-36" aria-hidden="true" tabindex="-1"></a>            <span class="kw">ORDER</span> <span class="kw">BY</span> frequency <span class="kw">DESC</span>, hashtag_text</span>
<span id="cb47-37"><a href="#cb47-37" aria-hidden="true" tabindex="-1"></a>        ) <span class="kw">AS</span> hashtag_rank</span>
<span id="cb47-38"><a href="#cb47-38" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb47-39"><a href="#cb47-39" aria-hidden="true" tabindex="-1"></a>        hashtag_counts</span>
<span id="cb47-40"><a href="#cb47-40" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb47-41"><a href="#cb47-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-42"><a href="#cb47-42" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> </span>
<span id="cb47-43"><a href="#cb47-43" aria-hidden="true" tabindex="-1"></a>    hashtag_text <span class="kw">AS</span> hashtag,</span>
<span id="cb47-44"><a href="#cb47-44" aria-hidden="true" tabindex="-1"></a>    frequency</span>
<span id="cb47-45"><a href="#cb47-45" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> </span>
<span id="cb47-46"><a href="#cb47-46" aria-hidden="true" tabindex="-1"></a>    ranked_hashtags</span>
<span id="cb47-47"><a href="#cb47-47" aria-hidden="true" tabindex="-1"></a><span class="kw">WHERE</span> </span>
<span id="cb47-48"><a href="#cb47-48" aria-hidden="true" tabindex="-1"></a>    hashtag_rank <span class="op">&lt;=</span> <span class="dv">3</span></span>
<span id="cb47-49"><a href="#cb47-49" aria-hidden="true" tabindex="-1"></a><span class="kw">ORDER</span> <span class="kw">BY</span> </span>
<span id="cb47-50"><a href="#cb47-50" aria-hidden="true" tabindex="-1"></a>    frequency <span class="kw">DESC</span>, hashtag;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Explanation:</strong></p>
<ul>
<li>This query identifies the top 3 trending hashtags in February 2024 based on their frequency of occurrence.</li>
<li>The solution uses a four-step approach with Common Table Expressions (CTEs):
<ul>
<li>The <code>content_with_hashtags</code> CTE uses regexp_matches to extract all hashtags from post content.</li>
<li>The <code>extracted_hashtags</code> CTE formats the extracted hashtags and converts them to lowercase for consistent counting.</li>
<li>The <code>hashtag_counts</code> CTE counts the frequency of each hashtag.</li>
<li>The <code>ranked_hashtags</code> CTE ranks hashtags by frequency and alphabetical order.</li>
</ul></li>
<li>The regular expression ‘#([^ ]+)’ matches a ‘#’ followed by one or more non-space characters.</li>
<li>The ‘g’ flag in regexp_matches ensures all matches in the content are found, not just the first one.</li>
<li>The main query filters for the top 3 hashtags based on their rank.</li>
<li>Time complexity: O(n * m) where n is the number of posts and m is the average number of words per post.</li>
<li>Space complexity: O(h) where h is the total number of hashtags extracted.</li>
<li>This solution correctly handles edge cases:
<ul>
<li>Hashtags with the same frequency (ordered alphabetically)</li>
<li>Fewer than 3 unique hashtags (returns all available hashtags)</li>
<li>Case-insensitive counting (converts all hashtags to lowercase)</li>
</ul></li>
<li>For large datasets, indexes on created_at would improve performance, and full-text indexing could speed up hashtag extraction.</li>
<li>The lower() function ensures case-insensitive counting and sorting of hashtags.</li>
<li>The WHERE clause in the first CTE efficiently filters for posts in February 2024.</li>
<li>The ROW_NUMBER() window function with ordering by frequency DESC and hashtag_text ensures correct ranking.</li>
<li>The solution correctly implements the hashtag extraction logic according to the problem definition.</li>
<li>The final ORDER BY ensures results are displayed in the required order.</li>
</ul>
</section>
<section id="employee-task-duration-and-concurrent-tasks" class="level4">
<h4 class="anchored" data-anchor-id="employee-task-duration-and-concurrent-tasks">3156. Employee Task Duration and Concurrent Tasks</h4>
<p><strong>Description:</strong></p>
<table class="caption-top table">
<caption>Tasks</caption>
<colgroup>
<col style="width: 19%">
<col style="width: 9%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>emp_id task_id start_time end_time</td>
<td>int int int int</td>
</tr>
</tbody>
</table>
<p>(emp_id, task_id) is the primary key for this table. Each row of this table indicates a task assigned to emp_id with the unique task_id, which started at start_time and ended at end_time. All times are presented in seconds.</p>
<p>Write an SQL query to report the following for each employee:</p>
<ul>
<li>total_task_duration: total duration across all tasks</li>
<li>max_concurrent_tasks: maximum number of concurrent tasks the employee worked on</li>
<li>max_concurrent_duration: total duration during which the employee was working on the maximum number of concurrent tasks</li>
</ul>
<p>Return the result table in any order.</p>
<p><strong>Solution:</strong></p>
<div class="sourceCode" id="cb48"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="kw">WITH</span> task_boundaries <span class="kw">AS</span> (</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Generate boundary points (start and end) for each task</span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>        emp_id,</span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>        start_time <span class="kw">AS</span> time_point,</span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a>        <span class="dv">1</span> <span class="kw">AS</span> transition <span class="co">-- +1 for task start</span></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a>        Tasks</span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">UNION</span> <span class="kw">ALL</span></span>
<span id="cb48-11"><a href="#cb48-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb48-12"><a href="#cb48-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb48-13"><a href="#cb48-13" aria-hidden="true" tabindex="-1"></a>        emp_id,</span>
<span id="cb48-14"><a href="#cb48-14" aria-hidden="true" tabindex="-1"></a>        end_time <span class="kw">AS</span> time_point,</span>
<span id="cb48-15"><a href="#cb48-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">-</span><span class="dv">1</span> <span class="kw">AS</span> transition <span class="co">-- -1 for task end</span></span>
<span id="cb48-16"><a href="#cb48-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb48-17"><a href="#cb48-17" aria-hidden="true" tabindex="-1"></a>        Tasks</span>
<span id="cb48-18"><a href="#cb48-18" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb48-19"><a href="#cb48-19" aria-hidden="true" tabindex="-1"></a>running_counts <span class="kw">AS</span> (</span>
<span id="cb48-20"><a href="#cb48-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Calculate running count of concurrent tasks at each boundary</span></span>
<span id="cb48-21"><a href="#cb48-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb48-22"><a href="#cb48-22" aria-hidden="true" tabindex="-1"></a>        emp_id,</span>
<span id="cb48-23"><a href="#cb48-23" aria-hidden="true" tabindex="-1"></a>        time_point,</span>
<span id="cb48-24"><a href="#cb48-24" aria-hidden="true" tabindex="-1"></a>        <span class="fu">SUM</span>(transition) <span class="kw">OVER</span> (</span>
<span id="cb48-25"><a href="#cb48-25" aria-hidden="true" tabindex="-1"></a>            <span class="kw">PARTITION</span> <span class="kw">BY</span> emp_id </span>
<span id="cb48-26"><a href="#cb48-26" aria-hidden="true" tabindex="-1"></a>            <span class="kw">ORDER</span> <span class="kw">BY</span> time_point</span>
<span id="cb48-27"><a href="#cb48-27" aria-hidden="true" tabindex="-1"></a>            <span class="kw">ROWS</span> <span class="kw">BETWEEN</span> <span class="kw">UNBOUNDED</span> <span class="kw">PRECEDING</span> <span class="kw">AND</span> <span class="kw">CURRENT</span> <span class="kw">ROW</span></span>
<span id="cb48-28"><a href="#cb48-28" aria-hidden="true" tabindex="-1"></a>        ) <span class="kw">AS</span> concurrent_tasks,</span>
<span id="cb48-29"><a href="#cb48-29" aria-hidden="true" tabindex="-1"></a>        <span class="fu">LEAD</span>(time_point) <span class="kw">OVER</span> (</span>
<span id="cb48-30"><a href="#cb48-30" aria-hidden="true" tabindex="-1"></a>            <span class="kw">PARTITION</span> <span class="kw">BY</span> emp_id </span>
<span id="cb48-31"><a href="#cb48-31" aria-hidden="true" tabindex="-1"></a>            <span class="kw">ORDER</span> <span class="kw">BY</span> time_point</span>
<span id="cb48-32"><a href="#cb48-32" aria-hidden="true" tabindex="-1"></a>        ) <span class="op">-</span> time_point <span class="kw">AS</span> duration</span>
<span id="cb48-33"><a href="#cb48-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb48-34"><a href="#cb48-34" aria-hidden="true" tabindex="-1"></a>        task_boundaries</span>
<span id="cb48-35"><a href="#cb48-35" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb48-36"><a href="#cb48-36" aria-hidden="true" tabindex="-1"></a>employee_stats <span class="kw">AS</span> (</span>
<span id="cb48-37"><a href="#cb48-37" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Calculate statistics for each employee</span></span>
<span id="cb48-38"><a href="#cb48-38" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb48-39"><a href="#cb48-39" aria-hidden="true" tabindex="-1"></a>        emp_id,</span>
<span id="cb48-40"><a href="#cb48-40" aria-hidden="true" tabindex="-1"></a>        <span class="fu">SUM</span>(<span class="cf">CASE</span> <span class="cf">WHEN</span> concurrent_tasks <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">THEN</span> duration <span class="cf">ELSE</span> <span class="dv">0</span> <span class="cf">END</span>) <span class="kw">AS</span> total_task_duration,</span>
<span id="cb48-41"><a href="#cb48-41" aria-hidden="true" tabindex="-1"></a>        <span class="fu">MAX</span>(concurrent_tasks) <span class="kw">AS</span> max_concurrent_tasks</span>
<span id="cb48-42"><a href="#cb48-42" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb48-43"><a href="#cb48-43" aria-hidden="true" tabindex="-1"></a>        running_counts</span>
<span id="cb48-44"><a href="#cb48-44" aria-hidden="true" tabindex="-1"></a>    <span class="kw">GROUP</span> <span class="kw">BY</span> </span>
<span id="cb48-45"><a href="#cb48-45" aria-hidden="true" tabindex="-1"></a>        emp_id</span>
<span id="cb48-46"><a href="#cb48-46" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb48-47"><a href="#cb48-47" aria-hidden="true" tabindex="-1"></a>max_concurrent_durations <span class="kw">AS</span> (</span>
<span id="cb48-48"><a href="#cb48-48" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Calculate duration at maximum concurrency</span></span>
<span id="cb48-49"><a href="#cb48-49" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb48-50"><a href="#cb48-50" aria-hidden="true" tabindex="-1"></a>        rc.emp_id,</span>
<span id="cb48-51"><a href="#cb48-51" aria-hidden="true" tabindex="-1"></a>        <span class="fu">SUM</span>(<span class="cf">CASE</span> <span class="cf">WHEN</span> rc.concurrent_tasks <span class="op">=</span> es.max_concurrent_tasks <span class="cf">THEN</span> rc.duration <span class="cf">ELSE</span> <span class="dv">0</span> <span class="cf">END</span>) <span class="kw">AS</span> max_concurrent_duration</span>
<span id="cb48-52"><a href="#cb48-52" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb48-53"><a href="#cb48-53" aria-hidden="true" tabindex="-1"></a>        running_counts rc</span>
<span id="cb48-54"><a href="#cb48-54" aria-hidden="true" tabindex="-1"></a>    <span class="kw">JOIN</span> </span>
<span id="cb48-55"><a href="#cb48-55" aria-hidden="true" tabindex="-1"></a>        employee_stats es <span class="kw">ON</span> rc.emp_id <span class="op">=</span> es.emp_id</span>
<span id="cb48-56"><a href="#cb48-56" aria-hidden="true" tabindex="-1"></a>    <span class="kw">WHERE</span> </span>
<span id="cb48-57"><a href="#cb48-57" aria-hidden="true" tabindex="-1"></a>        rc.duration <span class="kw">IS</span> <span class="kw">NOT</span> <span class="kw">NULL</span></span>
<span id="cb48-58"><a href="#cb48-58" aria-hidden="true" tabindex="-1"></a>    <span class="kw">GROUP</span> <span class="kw">BY</span> </span>
<span id="cb48-59"><a href="#cb48-59" aria-hidden="true" tabindex="-1"></a>        rc.emp_id</span>
<span id="cb48-60"><a href="#cb48-60" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb48-61"><a href="#cb48-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-62"><a href="#cb48-62" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> </span>
<span id="cb48-63"><a href="#cb48-63" aria-hidden="true" tabindex="-1"></a>    es.emp_id,</span>
<span id="cb48-64"><a href="#cb48-64" aria-hidden="true" tabindex="-1"></a>    es.total_task_duration,</span>
<span id="cb48-65"><a href="#cb48-65" aria-hidden="true" tabindex="-1"></a>    es.max_concurrent_tasks,</span>
<span id="cb48-66"><a href="#cb48-66" aria-hidden="true" tabindex="-1"></a>    <span class="fu">COALESCE</span>(mcd.max_concurrent_duration, <span class="dv">0</span>) <span class="kw">AS</span> max_concurrent_duration</span>
<span id="cb48-67"><a href="#cb48-67" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> </span>
<span id="cb48-68"><a href="#cb48-68" aria-hidden="true" tabindex="-1"></a>    employee_stats es</span>
<span id="cb48-69"><a href="#cb48-69" aria-hidden="true" tabindex="-1"></a><span class="kw">LEFT</span> <span class="kw">JOIN</span> </span>
<span id="cb48-70"><a href="#cb48-70" aria-hidden="true" tabindex="-1"></a>    max_concurrent_durations mcd <span class="kw">ON</span> es.emp_id <span class="op">=</span> mcd.emp_id;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Explanation:</strong></p>
<ul>
<li>This query calculates employee task statistics including total duration, maximum concurrent tasks, and duration at maximum concurrency.</li>
<li>The solution uses a four-step approach with Common Table Expressions (CTEs):
<ul>
<li>The <code>task_boundaries</code> CTE generates time points for task starts (+1) and ends (-1).</li>
<li>The <code>running_counts</code> CTE calculates the running count of concurrent tasks at each time point.</li>
<li>The <code>employee_stats</code> CTE calculates total duration and maximum concurrency for each employee.</li>
<li>The <code>max_concurrent_durations</code> CTE calculates the duration spent at maximum concurrency.</li>
</ul></li>
<li>The solution uses the “sweep line” algorithm, a technique often used in computational geometry.</li>
<li>Time points are sorted chronologically, and a running sum tracks how many tasks are active at each point.</li>
<li>The LEAD window function calculates the duration between consecutive time points.</li>
<li>Time complexity: O(n log n) where n is the number of tasks, due to the sorting operations.</li>
<li>Space complexity: O(n) for the time points and intermediate results.</li>
<li>This solution correctly handles edge cases:
<ul>
<li>Tasks with zero duration (end_time = start_time)</li>
<li>Overlapping tasks with identical start or end times</li>
<li>Employees with no periods of maximum concurrency</li>
</ul></li>
<li>For large datasets, indexes on emp_id, start_time, and end_time would improve performance.</li>
<li>The SUM with CASE expressions in the CTEs efficiently calculates durations based on conditional logic.</li>
<li>The COALESCE function handles the case where an employee has no periods at maximum concurrency.</li>
<li>The approach elegantly calculates all required metrics without complex self-joins.</li>
<li>The solution works for any number of overlapping tasks and correctly handles transitions between different concurrency levels.</li>
<li>The UNION ALL in task_boundaries is used instead of UNION to preserve duplicate time points that may occur when tasks start or end simultaneously.</li>
</ul>
</section>
<section id="find-top-scoring-students-ii" class="level4">
<h4 class="anchored" data-anchor-id="find-top-scoring-students-ii">3188. Find Top Scoring Students II</h4>
<p><strong>Description:</strong></p>
<table class="caption-top table">
<caption>Students</caption>
<colgroup>
<col style="width: 19%">
<col style="width: 13%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>student_id name age</td>
<td>int varchar int</td>
</tr>
</tbody>
</table>
<p>student_id is the primary key for this table. Each row of this table contains student_id, name, and age.</p>
<table class="caption-top table">
<caption>Scores</caption>
<colgroup>
<col style="width: 19%">
<col style="width: 9%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>student_id subject score</td>
<td>int enum int</td>
</tr>
</tbody>
</table>
<p>(student_id, subject) is the primary key for this table. subject is an ENUM of type (‘Math’, ‘Physics’, ‘Programming’). Each row of this table contains student_id, subject, and score.</p>
<p>Write an SQL query to find the students that score highest in each subject and those who score highest in all subjects.</p>
<p>Return the result table ordered by student_id.</p>
<p><strong>Solution:</strong></p>
<div class="sourceCode" id="cb49"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="kw">WITH</span> subject_max_scores <span class="kw">AS</span> (</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Find maximum score for each subject</span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a>        subject,</span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a>        <span class="fu">MAX</span>(score) <span class="kw">AS</span> max_score</span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a>        Scores</span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">GROUP</span> <span class="kw">BY</span> </span>
<span id="cb49-9"><a href="#cb49-9" aria-hidden="true" tabindex="-1"></a>        subject</span>
<span id="cb49-10"><a href="#cb49-10" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb49-11"><a href="#cb49-11" aria-hidden="true" tabindex="-1"></a>top_students_by_subject <span class="kw">AS</span> (</span>
<span id="cb49-12"><a href="#cb49-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Find students with top scores in each subject</span></span>
<span id="cb49-13"><a href="#cb49-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> <span class="kw">DISTINCT</span></span>
<span id="cb49-14"><a href="#cb49-14" aria-hidden="true" tabindex="-1"></a>        s.student_id,</span>
<span id="cb49-15"><a href="#cb49-15" aria-hidden="true" tabindex="-1"></a>        sc.subject</span>
<span id="cb49-16"><a href="#cb49-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb49-17"><a href="#cb49-17" aria-hidden="true" tabindex="-1"></a>        Scores sc</span>
<span id="cb49-18"><a href="#cb49-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">JOIN</span> </span>
<span id="cb49-19"><a href="#cb49-19" aria-hidden="true" tabindex="-1"></a>        Students s <span class="kw">ON</span> sc.student_id <span class="op">=</span> s.student_id</span>
<span id="cb49-20"><a href="#cb49-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">JOIN</span> </span>
<span id="cb49-21"><a href="#cb49-21" aria-hidden="true" tabindex="-1"></a>        subject_max_scores sms <span class="kw">ON</span> sc.subject <span class="op">=</span> sms.subject <span class="kw">AND</span> sc.score <span class="op">=</span> sms.max_score</span>
<span id="cb49-22"><a href="#cb49-22" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb49-23"><a href="#cb49-23" aria-hidden="true" tabindex="-1"></a>subject_count <span class="kw">AS</span> (</span>
<span id="cb49-24"><a href="#cb49-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Count number of subjects in which each student has top score</span></span>
<span id="cb49-25"><a href="#cb49-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb49-26"><a href="#cb49-26" aria-hidden="true" tabindex="-1"></a>        student_id,</span>
<span id="cb49-27"><a href="#cb49-27" aria-hidden="true" tabindex="-1"></a>        <span class="fu">COUNT</span>(subject) <span class="kw">AS</span> top_subject_count</span>
<span id="cb49-28"><a href="#cb49-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb49-29"><a href="#cb49-29" aria-hidden="true" tabindex="-1"></a>        top_students_by_subject</span>
<span id="cb49-30"><a href="#cb49-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">GROUP</span> <span class="kw">BY</span> </span>
<span id="cb49-31"><a href="#cb49-31" aria-hidden="true" tabindex="-1"></a>        student_id</span>
<span id="cb49-32"><a href="#cb49-32" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb49-33"><a href="#cb49-33" aria-hidden="true" tabindex="-1"></a>total_subjects <span class="kw">AS</span> (</span>
<span id="cb49-34"><a href="#cb49-34" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Count total number of distinct subjects</span></span>
<span id="cb49-35"><a href="#cb49-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb49-36"><a href="#cb49-36" aria-hidden="true" tabindex="-1"></a>        <span class="fu">COUNT</span>(<span class="kw">DISTINCT</span> subject) <span class="kw">AS</span> total</span>
<span id="cb49-37"><a href="#cb49-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb49-38"><a href="#cb49-38" aria-hidden="true" tabindex="-1"></a>        Scores</span>
<span id="cb49-39"><a href="#cb49-39" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb49-40"><a href="#cb49-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-41"><a href="#cb49-41" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> <span class="kw">DISTINCT</span></span>
<span id="cb49-42"><a href="#cb49-42" aria-hidden="true" tabindex="-1"></a>    s.student_id,</span>
<span id="cb49-43"><a href="#cb49-43" aria-hidden="true" tabindex="-1"></a>    s.name,</span>
<span id="cb49-44"><a href="#cb49-44" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Top in all subjects'</span> <span class="kw">AS</span> grade</span>
<span id="cb49-45"><a href="#cb49-45" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> </span>
<span id="cb49-46"><a href="#cb49-46" aria-hidden="true" tabindex="-1"></a>    subject_count sc</span>
<span id="cb49-47"><a href="#cb49-47" aria-hidden="true" tabindex="-1"></a><span class="kw">JOIN</span> </span>
<span id="cb49-48"><a href="#cb49-48" aria-hidden="true" tabindex="-1"></a>    Students s <span class="kw">ON</span> sc.student_id <span class="op">=</span> s.student_id</span>
<span id="cb49-49"><a href="#cb49-49" aria-hidden="true" tabindex="-1"></a><span class="kw">CROSS</span> <span class="kw">JOIN</span> </span>
<span id="cb49-50"><a href="#cb49-50" aria-hidden="true" tabindex="-1"></a>    total_subjects ts</span>
<span id="cb49-51"><a href="#cb49-51" aria-hidden="true" tabindex="-1"></a><span class="kw">WHERE</span> </span>
<span id="cb49-52"><a href="#cb49-52" aria-hidden="true" tabindex="-1"></a>    sc.top_subject_count <span class="op">=</span> ts.total</span>
<span id="cb49-53"><a href="#cb49-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-54"><a href="#cb49-54" aria-hidden="true" tabindex="-1"></a><span class="kw">UNION</span> <span class="kw">ALL</span></span>
<span id="cb49-55"><a href="#cb49-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-56"><a href="#cb49-56" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> <span class="kw">DISTINCT</span></span>
<span id="cb49-57"><a href="#cb49-57" aria-hidden="true" tabindex="-1"></a>    s.student_id,</span>
<span id="cb49-58"><a href="#cb49-58" aria-hidden="true" tabindex="-1"></a>    s.name,</span>
<span id="cb49-59"><a href="#cb49-59" aria-hidden="true" tabindex="-1"></a>    <span class="fu">CONCAT</span>(<span class="st">'Top in '</span>, tsbs.subject) <span class="kw">AS</span> grade</span>
<span id="cb49-60"><a href="#cb49-60" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> </span>
<span id="cb49-61"><a href="#cb49-61" aria-hidden="true" tabindex="-1"></a>    top_students_by_subject tsbs</span>
<span id="cb49-62"><a href="#cb49-62" aria-hidden="true" tabindex="-1"></a><span class="kw">JOIN</span> </span>
<span id="cb49-63"><a href="#cb49-63" aria-hidden="true" tabindex="-1"></a>    Students s <span class="kw">ON</span> tsbs.student_id <span class="op">=</span> s.student_id</span>
<span id="cb49-64"><a href="#cb49-64" aria-hidden="true" tabindex="-1"></a><span class="kw">LEFT</span> <span class="kw">JOIN</span> (</span>
<span id="cb49-65"><a href="#cb49-65" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb49-66"><a href="#cb49-66" aria-hidden="true" tabindex="-1"></a>        student_id </span>
<span id="cb49-67"><a href="#cb49-67" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb49-68"><a href="#cb49-68" aria-hidden="true" tabindex="-1"></a>        subject_count sc</span>
<span id="cb49-69"><a href="#cb49-69" aria-hidden="true" tabindex="-1"></a>    <span class="kw">CROSS</span> <span class="kw">JOIN</span> </span>
<span id="cb49-70"><a href="#cb49-70" aria-hidden="true" tabindex="-1"></a>        total_subjects ts</span>
<span id="cb49-71"><a href="#cb49-71" aria-hidden="true" tabindex="-1"></a>    <span class="kw">WHERE</span> </span>
<span id="cb49-72"><a href="#cb49-72" aria-hidden="true" tabindex="-1"></a>        sc.top_subject_count <span class="op">=</span> ts.total</span>
<span id="cb49-73"><a href="#cb49-73" aria-hidden="true" tabindex="-1"></a>) all_top <span class="kw">ON</span> tsbs.student_id <span class="op">=</span> all_top.student_id</span>
<span id="cb49-74"><a href="#cb49-74" aria-hidden="true" tabindex="-1"></a><span class="kw">WHERE</span> </span>
<span id="cb49-75"><a href="#cb49-75" aria-hidden="true" tabindex="-1"></a>    all_top.student_id <span class="kw">IS</span> <span class="kw">NULL</span></span>
<span id="cb49-76"><a href="#cb49-76" aria-hidden="true" tabindex="-1"></a><span class="kw">ORDER</span> <span class="kw">BY</span> </span>
<span id="cb49-77"><a href="#cb49-77" aria-hidden="true" tabindex="-1"></a>    student_id, grade;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Explanation:</strong></p>
<ul>
<li>This query identifies students who scored highest in each subject and those who scored highest in all subjects.</li>
<li>The solution uses a four-step approach with Common Table Expressions (CTEs):
<ul>
<li>The <code>subject_max_scores</code> CTE finds the maximum score for each subject.</li>
<li>The <code>top_students_by_subject</code> CTE identifies students who achieved the maximum score in each subject.</li>
<li>The <code>subject_count</code> CTE counts the number of subjects in which each student has the top score.</li>
<li>The <code>total_subjects</code> CTE counts the total number of distinct subjects.</li>
</ul></li>
<li>The main query consists of two parts joined with UNION ALL:
<ul>
<li>The first part identifies students who have top scores in all subjects.</li>
<li>The second part identifies students who have top scores in specific subjects but not all.</li>
</ul></li>
<li>The LEFT JOIN with exclusion in the second part ensures students aren’t double-counted.</li>
<li>Time complexity: O(n log n) where n is the number of scores, due to the sorting and grouping operations.</li>
<li>Space complexity: O(s + t) where s is the number of students and t is the number of top scores.</li>
<li>This solution correctly handles edge cases:
<ul>
<li>Students with top scores in multiple but not all subjects</li>
<li>Ties for top scores in a subject (all tied students are included)</li>
<li>Students who don’t have the top score in any subject (excluded from results)</li>
</ul></li>
<li>For large datasets, indexes on student_id, subject, and score would improve performance.</li>
<li>The DISTINCT keyword ensures each student is listed only once for each achievement.</li>
<li>The CONCAT function creates a descriptive grade for each student’s achievement.</li>
<li>The solution efficiently separates students who excel in all subjects from those who excel in specific subjects.</li>
<li>The approach correctly handles the requirement to order results by student_id.</li>
<li>The CROSS JOIN with total_subjects makes the total subject count available for comparison.</li>
<li>The solution follows a structured approach to solving the multi-part problem requirements.</li>
</ul>
</section>
<section id="year-on-year-growth-rate" class="level4">
<h4 class="anchored" data-anchor-id="year-on-year-growth-rate">3214. Year on Year Growth Rate</h4>
<p><strong>Description:</strong></p>
<table class="caption-top table">
<caption>AnnualSales</caption>
<colgroup>
<col style="width: 19%">
<col style="width: 9%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>year sales</td>
<td>int int</td>
</tr>
</tbody>
</table>
<p>year is the primary key for this table. Each row of this table contains the sales of a particular year.</p>
<p>Write an SQL query to calculate the year-on-year growth rate for each year.</p>
<p>The year-on-year growth rate is calculated as (current_year_sales - previous_year_sales) / previous_year_sales * 100.</p>
<p>Return the result table in ascending order by year. Round the growth_rate to 2 decimal places.</p>
<p><strong>Solution:</strong></p>
<div class="sourceCode" id="cb50"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="kw">WITH</span> sales_with_previous <span class="kw">AS</span> (</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">year</span>,</span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>        sales,</span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a>        <span class="fu">LAG</span>(sales) <span class="kw">OVER</span> (<span class="kw">ORDER</span> <span class="kw">BY</span> <span class="dt">year</span>) <span class="kw">AS</span> previous_year_sales</span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a>        AnnualSales</span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> </span>
<span id="cb50-11"><a href="#cb50-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">year</span>,</span>
<span id="cb50-12"><a href="#cb50-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">CASE</span> </span>
<span id="cb50-13"><a href="#cb50-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">WHEN</span> previous_year_sales <span class="kw">IS</span> <span class="kw">NULL</span> <span class="cf">THEN</span> <span class="kw">NULL</span></span>
<span id="cb50-14"><a href="#cb50-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">WHEN</span> previous_year_sales <span class="op">=</span> <span class="dv">0</span> <span class="cf">THEN</span> <span class="kw">NULL</span>  <span class="co">-- Avoid division by zero</span></span>
<span id="cb50-15"><a href="#cb50-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">ELSE</span> <span class="fu">ROUND</span>(((sales <span class="op">-</span> previous_year_sales) <span class="op">*</span> <span class="fl">100.0</span> <span class="op">/</span> previous_year_sales):<span class="ch">:numeric</span>, <span class="dv">2</span>)</span>
<span id="cb50-16"><a href="#cb50-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">END</span> <span class="kw">AS</span> growth_rate</span>
<span id="cb50-17"><a href="#cb50-17" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> </span>
<span id="cb50-18"><a href="#cb50-18" aria-hidden="true" tabindex="-1"></a>    sales_with_previous</span>
<span id="cb50-19"><a href="#cb50-19" aria-hidden="true" tabindex="-1"></a><span class="kw">ORDER</span> <span class="kw">BY</span> </span>
<span id="cb50-20"><a href="#cb50-20" aria-hidden="true" tabindex="-1"></a>    <span class="dt">year</span>;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Explanation:</strong></p>
<ul>
<li>This query calculates the year-on-year growth rate for sales data.</li>
<li>The solution uses a single Common Table Expression (CTE) approach:
<ul>
<li>The <code>sales_with_previous</code> CTE uses the LAG window function to access each year’s previous year sales.</li>
</ul></li>
<li>The main query then calculates the growth rate using the formula: (current - previous) / previous * 100.</li>
<li>ROUND(…, 2) ensures the growth rate is rounded to 2 decimal places as required.</li>
<li>Time complexity: O(n log n) where n is the number of years, due to the sorting operations.</li>
<li>Space complexity: O(n) for the intermediate results.</li>
<li>This solution correctly handles edge cases:
<ul>
<li>The first year (where there is no previous year) shows NULL for growth_rate</li>
<li>Years with zero sales in the previous year show NULL to avoid division by zero</li>
</ul></li>
<li>For large datasets, an index on the year column would improve performance.</li>
<li>The CASE expression handles both the lack of previous year data and division by zero scenarios.</li>
<li>The ::numeric cast ensures proper decimal division and rounding.</li>
<li>The approach elegantly uses the LAG window function to access previous year data without self-joins.</li>
<li>The solution follows the requirement to order results by year in ascending order.</li>
<li>The formula correctly implements the year-on-year growth rate calculation as specified.</li>
<li>The multiplication by 100.0 (not just 100) ensures decimal division for accurate percentage calculation.</li>
<li>This pattern is commonly used for time series analysis in business reporting.</li>
</ul>
</section>
<section id="ceo-subordinate-hierarchy" class="level4">
<h4 class="anchored" data-anchor-id="ceo-subordinate-hierarchy">3236. CEO Subordinate Hierarchy</h4>
<p><strong>Description:</strong></p>
<table class="caption-top table">
<caption>Employees</caption>
<colgroup>
<col style="width: 19%">
<col style="width: 13%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>emp_id name reports_to</td>
<td>int varchar int</td>
</tr>
</tbody>
</table>
<p>emp_id is the primary key for this table. Each row of this table indicates an employee’s ID, name, and the ID of their manager (reports_to). The CEO does not report to anyone and is represented by reports_to = null.</p>
<p>Write an SQL query to report the CEO’s hierarchy, starting from the CEO (level 0) down to level 3 of the company.</p>
<p>Return the result table ordered by level, and for employees at the same level, order them by emp_id.</p>
<p><strong>Solution:</strong></p>
<div class="sourceCode" id="cb51"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="kw">WITH</span> RECURSIVE employee_hierarchy <span class="kw">AS</span> (</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Base case: CEO (level 0)</span></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>        emp_id,</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>        name,</span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0</span> <span class="kw">AS</span> <span class="kw">level</span></span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a>        Employees</span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">WHERE</span> </span>
<span id="cb51-10"><a href="#cb51-10" aria-hidden="true" tabindex="-1"></a>        reports_to <span class="kw">IS</span> <span class="kw">NULL</span></span>
<span id="cb51-11"><a href="#cb51-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb51-12"><a href="#cb51-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">UNION</span> <span class="kw">ALL</span></span>
<span id="cb51-13"><a href="#cb51-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb51-14"><a href="#cb51-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Recursive case: Direct reports (next level)</span></span>
<span id="cb51-15"><a href="#cb51-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb51-16"><a href="#cb51-16" aria-hidden="true" tabindex="-1"></a>        e.emp_id,</span>
<span id="cb51-17"><a href="#cb51-17" aria-hidden="true" tabindex="-1"></a>        e.name,</span>
<span id="cb51-18"><a href="#cb51-18" aria-hidden="true" tabindex="-1"></a>        eh.<span class="kw">level</span> <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb51-19"><a href="#cb51-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb51-20"><a href="#cb51-20" aria-hidden="true" tabindex="-1"></a>        Employees e</span>
<span id="cb51-21"><a href="#cb51-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">JOIN</span> </span>
<span id="cb51-22"><a href="#cb51-22" aria-hidden="true" tabindex="-1"></a>        employee_hierarchy eh <span class="kw">ON</span> e.reports_to <span class="op">=</span> eh.emp_id</span>
<span id="cb51-23"><a href="#cb51-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">WHERE</span> </span>
<span id="cb51-24"><a href="#cb51-24" aria-hidden="true" tabindex="-1"></a>        eh.<span class="kw">level</span> <span class="op">&lt;</span> <span class="dv">3</span>  <span class="co">-- Only go down to level 3</span></span>
<span id="cb51-25"><a href="#cb51-25" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb51-26"><a href="#cb51-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-27"><a href="#cb51-27" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> </span>
<span id="cb51-28"><a href="#cb51-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">level</span>,</span>
<span id="cb51-29"><a href="#cb51-29" aria-hidden="true" tabindex="-1"></a>    emp_id,</span>
<span id="cb51-30"><a href="#cb51-30" aria-hidden="true" tabindex="-1"></a>    name</span>
<span id="cb51-31"><a href="#cb51-31" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> </span>
<span id="cb51-32"><a href="#cb51-32" aria-hidden="true" tabindex="-1"></a>    employee_hierarchy</span>
<span id="cb51-33"><a href="#cb51-33" aria-hidden="true" tabindex="-1"></a><span class="kw">ORDER</span> <span class="kw">BY</span> </span>
<span id="cb51-34"><a href="#cb51-34" aria-hidden="true" tabindex="-1"></a>    <span class="kw">level</span>, emp_id;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Explanation:</strong></p>
<ul>
<li>This query builds a hierarchical view of employees starting from the CEO (level 0) down to level 3.</li>
<li>The solution uses a recursive Common Table Expression (CTE):
<ul>
<li>The base case identifies the CEO as the employee with reports_to IS NULL.</li>
<li>The recursive case finds all employees who report to someone in the previous level.</li>
</ul></li>
<li>The RECURSIVE keyword enables the CTE to reference itself, allowing for hierarchical traversal.</li>
<li>The WHERE eh.level &lt; 3 condition limits the recursion to only include levels 0 through 3.</li>
<li>The main query selects all employees from the hierarchy and orders them by level and emp_id.</li>
<li>Time complexity: O(n) where n is the number of employees, as each employee is processed exactly once.</li>
<li>Space complexity: O(n) for the hierarchy representation.</li>
<li>This solution correctly handles the hierarchical structure:
<ul>
<li>The CEO at level 0</li>
<li>Direct reports to the CEO at level 1</li>
<li>Reports to level 1 employees at level 2</li>
<li>Reports to level 2 employees at level 3</li>
</ul></li>
<li>For large datasets, indexes on emp_id and reports_to would improve join performance.</li>
<li>The recursive CTE elegantly models the hierarchical relationship without complex self-joins.</li>
<li>The solution follows the requirements to order by level and then by emp_id.</li>
<li>This pattern is a standard approach for traversing hierarchical data in PostgreSQL.</li>
<li>The approach efficiently handles any organizational structure, regardless of how many employees report to each manager.</li>
<li>For very deep hierarchies, the recursion depth limit should be increased, but this solution is optimized for the 4-level requirement.</li>
</ul>
</section>
<section id="find-overlapping-shifts-ii" class="level4">
<h4 class="anchored" data-anchor-id="find-overlapping-shifts-ii">3268. Find Overlapping Shifts II</h4>
<p><strong>Description:</strong></p>
<table class="caption-top table">
<caption>Shifts</caption>
<colgroup>
<col style="width: 19%">
<col style="width: 9%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>employee_id shift_date start_time end_time</td>
<td>int date int int</td>
</tr>
</tbody>
</table>
<p>(employee_id, shift_date) is the primary key for this table. Each row of this table indicates the start_time and end_time of the shift of an employee with employee_id on a particular shift_date. All times follow a 24-hour clock system. A valid shift doesn’t have the same end_time as start_time, which means the end_time cannot equal the start_time. Each employee might have more than one shift on the same day.</p>
<p>Write an SQL query to report all employees whose shifts overlap.</p>
<p>Two employees’ shifts overlap if they are working on the same shift_date and there is some time period during which both employees are working.</p>
<p>Return the result table ordered by employee_id1 and employee_id2.</p>
<p><strong>Solution:</strong></p>
<div class="sourceCode" id="cb52"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="kw">WITH</span> normalized_shifts <span class="kw">AS</span> (</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a>        employee_id,</span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a>        shift_date,</span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a>        start_time,</span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a>        end_time</span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true" tabindex="-1"></a>        Shifts</span>
<span id="cb52-9"><a href="#cb52-9" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb52-10"><a href="#cb52-10" aria-hidden="true" tabindex="-1"></a>overlapping_pairs <span class="kw">AS</span> (</span>
<span id="cb52-11"><a href="#cb52-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> <span class="kw">DISTINCT</span></span>
<span id="cb52-12"><a href="#cb52-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">CASE</span> <span class="cf">WHEN</span> s1.employee_id <span class="op">&lt;</span> s2.employee_id <span class="cf">THEN</span> s1.employee_id <span class="cf">ELSE</span> s2.employee_id <span class="cf">END</span> <span class="kw">AS</span> employee_id1,</span>
<span id="cb52-13"><a href="#cb52-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">CASE</span> <span class="cf">WHEN</span> s1.employee_id <span class="op">&lt;</span> s2.employee_id <span class="cf">THEN</span> s2.employee_id <span class="cf">ELSE</span> s1.employee_id <span class="cf">END</span> <span class="kw">AS</span> employee_id2</span>
<span id="cb52-14"><a href="#cb52-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb52-15"><a href="#cb52-15" aria-hidden="true" tabindex="-1"></a>        normalized_shifts s1</span>
<span id="cb52-16"><a href="#cb52-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">JOIN</span> </span>
<span id="cb52-17"><a href="#cb52-17" aria-hidden="true" tabindex="-1"></a>        normalized_shifts s2 <span class="kw">ON</span> </span>
<span id="cb52-18"><a href="#cb52-18" aria-hidden="true" tabindex="-1"></a>            s1.employee_id <span class="op">!=</span> s2.employee_id <span class="kw">AND</span></span>
<span id="cb52-19"><a href="#cb52-19" aria-hidden="true" tabindex="-1"></a>            s1.shift_date <span class="op">=</span> s2.shift_date <span class="kw">AND</span></span>
<span id="cb52-20"><a href="#cb52-20" aria-hidden="true" tabindex="-1"></a>            (</span>
<span id="cb52-21"><a href="#cb52-21" aria-hidden="true" tabindex="-1"></a>                (s1.start_time <span class="op">&lt;=</span> s2.start_time <span class="kw">AND</span> s1.end_time <span class="op">&gt;</span> s2.start_time) <span class="kw">OR</span></span>
<span id="cb52-22"><a href="#cb52-22" aria-hidden="true" tabindex="-1"></a>                (s2.start_time <span class="op">&lt;=</span> s1.start_time <span class="kw">AND</span> s2.end_time <span class="op">&gt;</span> s1.start_time)</span>
<span id="cb52-23"><a href="#cb52-23" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb52-24"><a href="#cb52-24" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb52-25"><a href="#cb52-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-26"><a href="#cb52-26" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> </span>
<span id="cb52-27"><a href="#cb52-27" aria-hidden="true" tabindex="-1"></a>    employee_id1,</span>
<span id="cb52-28"><a href="#cb52-28" aria-hidden="true" tabindex="-1"></a>    employee_id2</span>
<span id="cb52-29"><a href="#cb52-29" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> </span>
<span id="cb52-30"><a href="#cb52-30" aria-hidden="true" tabindex="-1"></a>    overlapping_pairs</span>
<span id="cb52-31"><a href="#cb52-31" aria-hidden="true" tabindex="-1"></a><span class="kw">ORDER</span> <span class="kw">BY</span> </span>
<span id="cb52-32"><a href="#cb52-32" aria-hidden="true" tabindex="-1"></a>    employee_id1, employee_id2;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Explanation:</strong></p>
<ul>
<li>This query identifies pairs of employees with overlapping shifts.</li>
<li>The solution uses a two-step approach with Common Table Expressions (CTEs):
<ul>
<li>The <code>normalized_shifts</code> CTE prepares the shift data for analysis.</li>
<li>The <code>overlapping_pairs</code> CTE joins the shifts table to itself to find pairs of shifts that overlap.</li>
</ul></li>
<li>The CASE expressions ensure that employee_id1 &lt; employee_id2 for consistent ordering of pairs.</li>
<li>Two shifts overlap if one shift starts before or at the same time as the other shift ends, and ends after the other shift starts.</li>
<li>The logical condition for overlap is implemented as:
<ul>
<li>(s1.start_time &lt;= s2.start_time AND s1.end_time &gt; s2.start_time) OR</li>
<li>(s2.start_time &lt;= s1.start_time AND s2.end_time &gt; s1.start_time)</li>
</ul></li>
<li>Time complexity: O(n²) where n is the number of shifts, due to the self-join operation.</li>
<li>Space complexity: O(p) where p is the number of overlapping pairs.</li>
<li>This solution correctly handles edge cases:
<ul>
<li>Multiple shifts per employee on the same day</li>
<li>Shifts that touch exactly (end_time of one equals start_time of another) are not considered overlapping</li>
<li>Shifts on different dates never overlap</li>
</ul></li>
<li>For large datasets, indexes on employee_id, shift_date, start_time, and end_time would improve join performance.</li>
<li>The DISTINCT keyword ensures each overlapping pair is reported only once.</li>
<li>The JOIN conditions efficiently filter for shifts that occur on the same date and have different employees.</li>
<li>The solution follows the requirements to order results by employee_id1 and employee_id2.</li>
<li>This approach handles shifts crossing midnight by treating time as a continuous value within a day.</li>
<li>The self-join pattern is a standard approach for finding overlapping intervals.</li>
</ul>
</section>
<section id="team-dominance-by-pass-success" class="level4">
<h4 class="anchored" data-anchor-id="team-dominance-by-pass-success">3384. Team Dominance by Pass Success</h4>
<p><strong>Description:</strong></p>
<table class="caption-top table">
<caption>Passes</caption>
<colgroup>
<col style="width: 23%">
<col style="width: 9%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>pass_id team_id pass_recipient success</td>
<td>int int int int</td>
</tr>
</tbody>
</table>
<p>pass_id is the primary key for this table. Each row of this table indicates a pass by team_id to a player (pass_recipient). success is either 0 (failure) or 1 (success).</p>
<p>Write an SQL query to find teams with a high pass success rate. A team has a high pass success rate if its success rate is strictly greater than the success rate of every other team.</p>
<p>The pass success rate is calculated as the number of successful passes divided by the total number of passes.</p>
<p>Return the result table ordered by team_id.</p>
<p><strong>Solution:</strong></p>
<div class="sourceCode" id="cb53"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="kw">WITH</span> team_success_rates <span class="kw">AS</span> (</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>        team_id,</span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a>        <span class="fu">SUM</span>(success) <span class="kw">AS</span> successful_passes,</span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a>        <span class="fu">COUNT</span>(<span class="op">*</span>) <span class="kw">AS</span> total_passes,</span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a>        <span class="fu">CAST</span>(<span class="fu">SUM</span>(success) <span class="kw">AS</span> <span class="dt">decimal</span>) <span class="op">/</span> <span class="fu">COUNT</span>(<span class="op">*</span>) <span class="kw">AS</span> success_rate</span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a>        Passes</span>
<span id="cb53-9"><a href="#cb53-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">GROUP</span> <span class="kw">BY</span> </span>
<span id="cb53-10"><a href="#cb53-10" aria-hidden="true" tabindex="-1"></a>        team_id</span>
<span id="cb53-11"><a href="#cb53-11" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb53-12"><a href="#cb53-12" aria-hidden="true" tabindex="-1"></a>max_other_team_rates <span class="kw">AS</span> (</span>
<span id="cb53-13"><a href="#cb53-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb53-14"><a href="#cb53-14" aria-hidden="true" tabindex="-1"></a>        t1.team_id,</span>
<span id="cb53-15"><a href="#cb53-15" aria-hidden="true" tabindex="-1"></a>        <span class="fu">MAX</span>(t2.success_rate) <span class="kw">AS</span> max_other_rate</span>
<span id="cb53-16"><a href="#cb53-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb53-17"><a href="#cb53-17" aria-hidden="true" tabindex="-1"></a>        team_success_rates t1</span>
<span id="cb53-18"><a href="#cb53-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">CROSS</span> <span class="kw">JOIN</span> </span>
<span id="cb53-19"><a href="#cb53-19" aria-hidden="true" tabindex="-1"></a>        team_success_rates t2</span>
<span id="cb53-20"><a href="#cb53-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">WHERE</span> </span>
<span id="cb53-21"><a href="#cb53-21" aria-hidden="true" tabindex="-1"></a>        t1.team_id <span class="op">!=</span> t2.team_id</span>
<span id="cb53-22"><a href="#cb53-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">GROUP</span> <span class="kw">BY</span> </span>
<span id="cb53-23"><a href="#cb53-23" aria-hidden="true" tabindex="-1"></a>        t1.team_id</span>
<span id="cb53-24"><a href="#cb53-24" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb53-25"><a href="#cb53-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-26"><a href="#cb53-26" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> </span>
<span id="cb53-27"><a href="#cb53-27" aria-hidden="true" tabindex="-1"></a>    t.team_id</span>
<span id="cb53-28"><a href="#cb53-28" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> </span>
<span id="cb53-29"><a href="#cb53-29" aria-hidden="true" tabindex="-1"></a>    team_success_rates t</span>
<span id="cb53-30"><a href="#cb53-30" aria-hidden="true" tabindex="-1"></a><span class="kw">JOIN</span> </span>
<span id="cb53-31"><a href="#cb53-31" aria-hidden="true" tabindex="-1"></a>    max_other_team_rates m <span class="kw">ON</span> t.team_id <span class="op">=</span> m.team_id</span>
<span id="cb53-32"><a href="#cb53-32" aria-hidden="true" tabindex="-1"></a><span class="kw">WHERE</span> </span>
<span id="cb53-33"><a href="#cb53-33" aria-hidden="true" tabindex="-1"></a>    t.success_rate <span class="op">&gt;</span> m.max_other_rate</span>
<span id="cb53-34"><a href="#cb53-34" aria-hidden="true" tabindex="-1"></a><span class="kw">ORDER</span> <span class="kw">BY</span> </span>
<span id="cb53-35"><a href="#cb53-35" aria-hidden="true" tabindex="-1"></a>    t.team_id;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Explanation:</strong></p>
<ul>
<li>This query identifies teams whose pass success rate is strictly greater than all other teams.</li>
<li>The solution uses a two-step approach with Common Table Expressions (CTEs):
<ul>
<li>The <code>team_success_rates</code> CTE calculates the success rate for each team.</li>
<li>The <code>max_other_team_rates</code> CTE finds the maximum success rate among all other teams for each team.</li>
</ul></li>
<li>The success rate is calculated as successful_passes / total_passes using a CAST to ensure decimal division.</li>
<li>The main query joins these CTEs and filters for teams whose success rate is greater than the maximum rate of other teams.</li>
<li>Time complexity: O(n log n) where n is the number of teams, due to the sorting operations.</li>
<li>Space complexity: O(n) for the intermediate results.</li>
<li>This solution correctly handles edge cases:
<ul>
<li>Teams with the same success rate (neither would be considered dominant)</li>
<li>Teams with 100% success rate (only dominant if all other teams have lower rates)</li>
<li>Teams with very few passes (their rate is still calculated accurately)</li>
</ul></li>
<li>For large datasets, indexes on team_id would improve performance.</li>
<li>The CROSS JOIN in max_other_team_rates efficiently creates all team-to-team comparisons.</li>
<li>The WHERE t1.team_id != t2.team_id condition ensures a team isn’t compared against itself.</li>
<li>The solution follows the requirement to order results by team_id.</li>
<li>The approach efficiently implements the “strictly greater than all others” requirement using the MAX function.</li>
<li>The CAST AS decimal ensures accurate division without integer truncation.</li>
<li>This pattern is useful for identifying dominant entities in comparative analysis.</li>
</ul>
</section>
<section id="find-circular-gift-exchange-chains" class="level4">
<h4 class="anchored" data-anchor-id="find-circular-gift-exchange-chains">3401. Find Circular Gift Exchange Chains</h4>
<p><strong>Description:</strong></p>
<table class="caption-top table">
<caption>Gifts</caption>
<colgroup>
<col style="width: 19%">
<col style="width: 13%">
</colgroup>
<tbody>
<tr class="odd">
<td>Column Name</td>
<td>Type</td>
</tr>
<tr class="even">
<td>giver_id receiver_id gift_date</td>
<td>int int date</td>
</tr>
</tbody>
</table>
<p>(giver_id, receiver_id) is the primary key for this table. Each row of this table indicates that a gift was sent on gift_date by giver_id to receiver_id.</p>
<p>A gift chain is a sequence of gifts where each person receives a gift from the previous person in the chain and gives a gift to the next person in the chain, with the last person giving a gift to the first person in the chain.</p>
<p>Write an SQL query to find circular gift exchange chains. A circular chain needs to have at least three people.</p>
<p>Return the result table ordered by length (number of people in the chain) in descending order. If there are multiple chains with the same length, order them by the minimum giver_id in each chain in ascending order.</p>
<p><strong>Solution:</strong></p>
<div class="sourceCode" id="cb54"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="kw">WITH</span> RECURSIVE gift_chains <span class="kw">AS</span> (</span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Base case: Start with each potential chain beginning</span></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a>        giver_id <span class="kw">AS</span> start_id,</span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a>        receiver_id <span class="kw">AS</span> current_id,</span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">ARRAY</span>[giver_id] <span class="kw">AS</span> chain,</span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a>        <span class="dv">1</span> <span class="kw">AS</span> <span class="fu">length</span></span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a>        Gifts</span>
<span id="cb54-10"><a href="#cb54-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb54-11"><a href="#cb54-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">UNION</span> <span class="kw">ALL</span></span>
<span id="cb54-12"><a href="#cb54-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb54-13"><a href="#cb54-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Recursive case: Extend chains</span></span>
<span id="cb54-14"><a href="#cb54-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb54-15"><a href="#cb54-15" aria-hidden="true" tabindex="-1"></a>        gc.start_id,</span>
<span id="cb54-16"><a href="#cb54-16" aria-hidden="true" tabindex="-1"></a>        g.receiver_id <span class="kw">AS</span> current_id,</span>
<span id="cb54-17"><a href="#cb54-17" aria-hidden="true" tabindex="-1"></a>        gc.chain <span class="op">||</span> g.giver_id <span class="kw">AS</span> chain,</span>
<span id="cb54-18"><a href="#cb54-18" aria-hidden="true" tabindex="-1"></a>        gc.<span class="fu">length</span> <span class="op">+</span> <span class="dv">1</span> <span class="kw">AS</span> <span class="fu">length</span></span>
<span id="cb54-19"><a href="#cb54-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb54-20"><a href="#cb54-20" aria-hidden="true" tabindex="-1"></a>        gift_chains gc</span>
<span id="cb54-21"><a href="#cb54-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">JOIN</span> </span>
<span id="cb54-22"><a href="#cb54-22" aria-hidden="true" tabindex="-1"></a>        Gifts g <span class="kw">ON</span> gc.current_id <span class="op">=</span> g.giver_id</span>
<span id="cb54-23"><a href="#cb54-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">WHERE</span> </span>
<span id="cb54-24"><a href="#cb54-24" aria-hidden="true" tabindex="-1"></a>        <span class="co">-- Avoid cycles before completing the chain</span></span>
<span id="cb54-25"><a href="#cb54-25" aria-hidden="true" tabindex="-1"></a>        <span class="kw">NOT</span> g.giver_id <span class="op">=</span> <span class="kw">ANY</span>(gc.chain) <span class="kw">AND</span></span>
<span id="cb54-26"><a href="#cb54-26" aria-hidden="true" tabindex="-1"></a>        <span class="co">-- Limit chain length to prevent infinite recursion</span></span>
<span id="cb54-27"><a href="#cb54-27" aria-hidden="true" tabindex="-1"></a>        gc.<span class="fu">length</span> <span class="op">&lt;</span> <span class="dv">20</span></span>
<span id="cb54-28"><a href="#cb54-28" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb54-29"><a href="#cb54-29" aria-hidden="true" tabindex="-1"></a>completed_chains <span class="kw">AS</span> (</span>
<span id="cb54-30"><a href="#cb54-30" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Find chains where the last receiver gives to the first giver</span></span>
<span id="cb54-31"><a href="#cb54-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> </span>
<span id="cb54-32"><a href="#cb54-32" aria-hidden="true" tabindex="-1"></a>        chain <span class="op">||</span> current_id <span class="kw">AS</span> full_chain,</span>
<span id="cb54-33"><a href="#cb54-33" aria-hidden="true" tabindex="-1"></a>        <span class="fu">length</span> <span class="op">+</span> <span class="dv">1</span> <span class="kw">AS</span> chain_length</span>
<span id="cb54-34"><a href="#cb54-34" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb54-35"><a href="#cb54-35" aria-hidden="true" tabindex="-1"></a>        gift_chains</span>
<span id="cb54-36"><a href="#cb54-36" aria-hidden="true" tabindex="-1"></a>    <span class="kw">WHERE</span> </span>
<span id="cb54-37"><a href="#cb54-37" aria-hidden="true" tabindex="-1"></a>        current_id <span class="kw">NOT</span> <span class="kw">IN</span> (<span class="kw">SELECT</span> unnest(chain) <span class="kw">FROM</span> gift_chains gc <span class="kw">WHERE</span> gc.chain <span class="op">=</span> chain) <span class="kw">AND</span></span>
<span id="cb54-38"><a href="#cb54-38" aria-hidden="true" tabindex="-1"></a>        <span class="kw">EXISTS</span> (</span>
<span id="cb54-39"><a href="#cb54-39" aria-hidden="true" tabindex="-1"></a>            <span class="kw">SELECT</span> <span class="dv">1</span> </span>
<span id="cb54-40"><a href="#cb54-40" aria-hidden="true" tabindex="-1"></a>            <span class="kw">FROM</span> Gifts g </span>
<span id="cb54-41"><a href="#cb54-41" aria-hidden="true" tabindex="-1"></a>            <span class="kw">WHERE</span> g.giver_id <span class="op">=</span> current_id <span class="kw">AND</span> g.receiver_id <span class="op">=</span> start_id</span>
<span id="cb54-42"><a href="#cb54-42" aria-hidden="true" tabindex="-1"></a>        ) <span class="kw">AND</span></span>
<span id="cb54-43"><a href="#cb54-43" aria-hidden="true" tabindex="-1"></a>        <span class="fu">length</span> <span class="op">&gt;=</span> <span class="dv">2</span>  <span class="co">-- At least 3 people in the chain (including completion)</span></span>
<span id="cb54-44"><a href="#cb54-44" aria-hidden="true" tabindex="-1"></a>),</span>
<span id="cb54-45"><a href="#cb54-45" aria-hidden="true" tabindex="-1"></a>unique_chains <span class="kw">AS</span> (</span>
<span id="cb54-46"><a href="#cb54-46" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Remove duplicate chains that are rotations of each other</span></span>
<span id="cb54-47"><a href="#cb54-47" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> <span class="kw">DISTINCT</span> <span class="kw">ON</span> (canonical_chain)</span>
<span id="cb54-48"><a href="#cb54-48" aria-hidden="true" tabindex="-1"></a>        full_chain,</span>
<span id="cb54-49"><a href="#cb54-49" aria-hidden="true" tabindex="-1"></a>        chain_length,</span>
<span id="cb54-50"><a href="#cb54-50" aria-hidden="true" tabindex="-1"></a>        array_to_string(array_agg(e <span class="kw">ORDER</span> <span class="kw">BY</span> e), <span class="st">','</span>) <span class="kw">AS</span> canonical_chain,</span>
<span id="cb54-51"><a href="#cb54-51" aria-hidden="true" tabindex="-1"></a>        <span class="fu">MIN</span>(e) <span class="kw">AS</span> min_id</span>
<span id="cb54-52"><a href="#cb54-52" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> </span>
<span id="cb54-53"><a href="#cb54-53" aria-hidden="true" tabindex="-1"></a>        completed_chains,</span>
<span id="cb54-54"><a href="#cb54-54" aria-hidden="true" tabindex="-1"></a>        LATERAL unnest(full_chain) <span class="kw">AS</span> e</span>
<span id="cb54-55"><a href="#cb54-55" aria-hidden="true" tabindex="-1"></a>    <span class="kw">GROUP</span> <span class="kw">BY</span> </span>
<span id="cb54-56"><a href="#cb54-56" aria-hidden="true" tabindex="-1"></a>        full_chain, chain_length</span>
<span id="cb54-57"><a href="#cb54-57" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb54-58"><a href="#cb54-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-59"><a href="#cb54-59" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> </span>
<span id="cb54-60"><a href="#cb54-60" aria-hidden="true" tabindex="-1"></a>    chain_length <span class="kw">AS</span> <span class="fu">length</span>,</span>
<span id="cb54-61"><a href="#cb54-61" aria-hidden="true" tabindex="-1"></a>    array_to_string(full_chain, <span class="st">'-&gt;'</span>) <span class="kw">AS</span> chain</span>
<span id="cb54-62"><a href="#cb54-62" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> </span>
<span id="cb54-63"><a href="#cb54-63" aria-hidden="true" tabindex="-1"></a>    unique_chains</span>
<span id="cb54-64"><a href="#cb54-64" aria-hidden="true" tabindex="-1"></a><span class="kw">ORDER</span> <span class="kw">BY</span> </span>
<span id="cb54-65"><a href="#cb54-65" aria-hidden="true" tabindex="-1"></a>    chain_length <span class="kw">DESC</span>, min_id;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Explanation:</strong></p>
<ul>
<li>This query identifies circular gift exchange chains where each person gives a gift to the next person in the chain.</li>
<li>The solution uses a recursive Common Table Expression (CTE) approach:
<ul>
<li>The <code>gift_chains</code> CTE builds possible chains by starting with each gift and recursively extending them.</li>
<li>The <code>completed_chains</code> CTE identifies chains where the last person gives a gift to the first person, completing the circle.</li>
<li>The <code>unique_chains</code> CTE removes duplicate chains that are just rotations of each other.</li>
</ul></li>
<li>The ARRAY type stores the sequence of people in each chain.</li>
<li>The EXISTS subquery in completed_chains verifies that the last person gives to the first person.</li>
<li>Time complexity: O(n^k) where n is the number of gifts and k is the maximum chain length, due to the recursive exploration.</li>
<li>Space complexity: O(c) where c is the number of possible chains.</li>
<li>This solution correctly handles edge cases:
<ul>
<li>Chains with exactly 3 people (the minimum required)</li>
<li>Multiple chains with the same length</li>
<li>Chains that are rotations of each other (counted only once)</li>
</ul></li>
<li>For large datasets, indexes on giver_id and receiver_id would improve join performance.</li>
<li>The NOT IN and NOT = ANY conditions prevent premature cycles in the chains.</li>
<li>The length limit in the recursive case prevents infinite recursion.</li>
<li>The unnest and array_to_string functions convert arrays to a format suitable for display and comparison.</li>
<li>The solution follows the requirements to order by length descending and then by minimum ID.</li>
<li>The array_agg with ORDER BY creates a canonical representation of each chain for deduplication.</li>
<li>The recursive CTE pattern is well-suited for path-finding problems like this circular chain detection.</li>
</ul>
</section>
<section id="find-invalid-ip-addresses" class="level4">
<h4 class="anchored" data-anchor-id="find-invalid-ip-addresses">3451. Find Invalid IP Addresses</h4>
<p><strong>Description:</strong></p>
<p><strong>Solution:</strong></p>
<div class="sourceCode" id="cb55"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Explanation:</strong></p>
<ul>
<li>Need to add explanation</li>
</ul>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>